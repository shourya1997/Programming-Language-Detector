package titanic.weka;
import java.io.File;
import java.io.IOException;
import java.util.Enumeration;

import weka.classifiers.Classifier;
import weka.classifiers.Evaluation;
import weka.classifiers.trees.RandomForest;
import weka.core.Attribute;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.SerializationHelper;
import weka.core.converters.ArffLoader;
import weka.core.converters.CSVLoader;
import weka.core.converters.CSVSaver;
import weka.core.converters.Loader;

/**
 * The Predict class uses the trained Classifier and the test data to create a
 * prediction CSV file. As noted inthe README.md, we modified the original
 * test.csv file to contain the 'survived' column. We do not actually use the
 * values of this column, weka simply requires the train and test data to match.
 * 
 * @author jbirchfield
 * 
 */
public class Predict {

	public static void main(String[] args) throws Exception {

		/*
		 * First we load the test data from our ARFF file
		 */
		ArffLoader testLoader = new ArffLoader();
		testLoader.setSource(new File("test.arff"));
		testLoader.setRetrieval(Loader.BATCH);
		Instances testDataSet = testLoader.getDataSet();

		/*
		 * Now we tell the data set which attribute we want to classify, in our
		 * case, we want to classify the first column: survived
		 */
		Attribute testAttribute = testDataSet.attribute(0);
		testDataSet.setClass(testAttribute);
		testDataSet.deleteStringAttributes();

		/*
		 * Now we read in the serialized model from disk
		 */
		Classifier classifier = (Classifier) SerializationHelper
				.read("titanic.model");

		/*
		 * This part may be a little confusing. We load up the test data again
		 * so we have a prediction data set to populate. As we iterate over the
		 * first data set we also iterate over the second data set. After an
		 * instance is classified, we set the value of the prediction data set
		 * to be the value of the classification
		 */
		ArffLoader test1Loader = new ArffLoader();
		test1Loader.setSource(new File("test.arff"));
		Instances test1DataSet = test1Loader.getDataSet();
		Attribute test1Attribute = test1DataSet.attribute(0);
		test1DataSet.setClass(test1Attribute);

		/*
		 * Now we iterate over the test data and classify each entry and set the
		 * value of the 'survived' column to the result of the classification
		 */
		Enumeration testInstances = testDataSet.enumerateInstances();
		Enumeration test1Instances = test1DataSet.enumerateInstances();
		while (testInstances.hasMoreElements()) {
			Instance instance = (Instance) testInstances.nextElement();
			Instance instance1 = (Instance) test1Instances.nextElement();
			double classification = classifier.classifyInstance(instance);
			instance1.setClassValue(classification);
		}

		/*
		 * Now we want to write out our predictions. The resulting file is in a
		 * format suitable to submit to Kaggle.
		 */
		CSVSaver predictedCsvSaver = new CSVSaver();
		predictedCsvSaver.setFile(new File("predict.csv"));
		predictedCsvSaver.setInstances(test1DataSet);
		predictedCsvSaver.writeBatch();

		System.out.println("Prediciton saved to predict.csv");

	}
}
package titanic.weka;

import java.io.File;

import weka.classifiers.trees.BFTree;
import weka.classifiers.trees.RandomForest;
import weka.core.Attribute;
import weka.core.Instances;
import weka.core.SerializationHelper;
import weka.core.converters.ArffLoader;
import weka.core.converters.Loader;

/**
 * The Train class is responsible for loading the training data, instantiating a
 * Classifier, then building the classifier instance with the training data. It
 * then serializes the Classifier to disk for other operations to use.
 * 
 * As seen in the README.md file, we have converted the given CSV formatted
 * traiing and teat data into ARFF formatted files. This allows us to specify
 * the types of each column (nominal, numeric, string).
 * 
 * @author jbirchfield
 * 
 */
public class Train {

	public static void main(String[] args) throws Exception {
		/*
		 * First we load the training data from our ARFF file
		 */
		ArffLoader trainLoader = new ArffLoader();
		trainLoader.setSource(new File("train.arff"));
		trainLoader.setRetrieval(Loader.BATCH);
		Instances trainDataSet = trainLoader.getDataSet();

		/*
		 * Now we tell the data set which attribute we want to classify, in our
		 * case, we want to classify the first column: survived
		 */
		Attribute trainAttribute = trainDataSet.attribute(0);
		trainDataSet.setClass(trainAttribute);

		/*
		 * The RandomForest implementation cannot handle columns of type string,
		 * so we remove them for now.
		 */
		trainDataSet.deleteStringAttributes();

		/*
		 * Create a new Classifier of type RandomForest and configure it.
		 */
		 RandomForest classifier = new RandomForest();
		 classifier.setNumTrees(500);
		 classifier.setDebug(true);

		/*
		 * Now we train the classifier
		 */
		classifier.buildClassifier(trainDataSet);

		/*
		 * We are done training the classifier, so now we serialize it to disk
		 */
		SerializationHelper.write("titanic.model", classifier);
		System.out.println("Saved trained model to titanic.model");

	}
}
package titanic.weka;

import java.io.File;
import java.io.IOException;
import java.util.Enumeration;

import weka.classifiers.Classifier;
import weka.classifiers.Evaluation;
import weka.classifiers.evaluation.EvaluationUtils;
import weka.classifiers.trees.RandomForest;
import weka.core.Attribute;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.SerializationHelper;
import weka.core.converters.ArffLoader;
import weka.core.converters.CSVLoader;
import weka.core.converters.CSVSaver;
import weka.core.converters.Loader;

/**
 * The Verify class uses the trained model and the predicted data to verify the
 * classification actually worked.
 * 
 * @author jbirchfield
 * 
 */
public class Verify {

	public static void main(String[] args) throws Exception {

		/*
		 * First we load our preditons from the CSV formatted file.
		 */
		CSVLoader predictCsvLoader = new CSVLoader();
		predictCsvLoader.setSource(new File("predict.csv"));

		/*
		 * Since we are not using the ARFF format here, we have to give the
		 * loader a little bit of information about the data types. Columns
		 * 3,8,10 need to be of type string and columns 1,4,11 are nominal
		 * types.
		 */
		predictCsvLoader.setStringAttributes("3,8,10");
		predictCsvLoader.setNominalAttributes("1,4,11");
		Instances predictDataSet = predictCsvLoader.getDataSet();

		/*
		 * Here we set the attribute we want to test the predicitons with
		 */
		Attribute testAttribute = predictDataSet.attribute(0);
		predictDataSet.setClass(testAttribute);

		/*
		 * We still have to remove all string attributes before we can test
		 */
		predictDataSet.deleteStringAttributes();

		/*
		 * Next we load the training data from our ARFF file
		 */
		ArffLoader trainLoader = new ArffLoader();
		trainLoader.setSource(new File("train.arff"));
		trainLoader.setRetrieval(Loader.BATCH);
		Instances trainDataSet = trainLoader.getDataSet();

		/*
		 * Now we tell the data set which attribute we want to classify, in our
		 * case, we want to classify the first column: survived
		 */
		Attribute trainAttribute = trainDataSet.attribute(0);
		trainDataSet.setClass(trainAttribute);

		/*
		 * The RandomForest implementation cannot handle columns of type string,
		 * so we remove them for now.
		 */
		trainDataSet.deleteStringAttributes();
		
		/*
		 * Now we read in the serialized model from disk
		 */
		Classifier classifier = (Classifier) SerializationHelper
				.read("titanic.model");

		/*
		 * Next we will use an Evaluation class to evaluate the performance of
		 * our Classifier.
		 */
		Evaluation evaluation = new Evaluation(trainDataSet);
		evaluation.evaluateModel(classifier, predictDataSet, new Object[] {});

		/*
		 * After we evaluate the Classifier, we write out the summary
		 * information to the screen.
		 */
		System.out.println(classifier);
		System.out.println(evaluation.toSummaryString());

	}
}
package titanic.weka.multi;

import java.util.ArrayList;
import java.util.List;

import weka.classifiers.Classifier;
import weka.core.Instance;
import weka.core.Instances;

public class MultiClassifier extends Classifier {

	/**
	 * 
	 */
	private static final long serialVersionUID = -8996052328536347834L;
	
	List<Classifier> classifiers = new ArrayList<Classifier>();

	@Override
	public void buildClassifier(Instances data) throws Exception {
		for (Classifier classifier : classifiers) {
			classifier.buildClassifier(data);
		}
	}
	
	@Override
	public double classifyInstance(Instance instance) throws Exception {
		double sum = 0.0;
		for (Classifier classifier : classifiers) {
			double classification = classifier.classifyInstance(instance);
			sum += classification;
		}
		if(sum >= classifiers.size()/2) {
			return 1.0;
		}
		return 0.0;
	}

	@Override
	protected Object clone() throws CloneNotSupportedException {
		return super.clone();
	}

	public void addClassifier(Classifier classifier) {
		classifiers.add(classifier);
	}
	
	@Override
	public String toString() {
		StringBuffer buffer = new StringBuffer();
		buffer.append("MultiClassifier\n");
		buffer.append("-----------------\n");
		for (Classifier classifier : classifiers) {
			buffer.append(classifier.toString());
			buffer.append("\n-----------------\n");
		}
		
		return buffer.toString();
	}

}
package com.blankj.structure;

import java.util.ArrayList;
import java.util.List;

/**
 * <pre>
 *     author: Blankj
 *     blog  : http://blankj.com
 *     time  : 2017/10/19
 *     desc  :
 * </pre>
 */
public class Interval {
    public int start;
    public int end;

    public Interval() {
        start = 0;
        end = 0;
    }

    public Interval(int s, int e) {
        start = s;
        end = e;
    }

    /**
     * 创建测试数据
     *
     * @param data [[X,X],[X,X],[X,X]]
     * @return {@link List<Interval>}
     */
    public static List<Interval> createTestData(String data) {
        List<Interval> list = new ArrayList<>();
        String[] d = data.substring(1, data.length() - 1).split("],\\[");
        for (String s : d) {
            String[] sub = s.split(",");
            list.add(new Interval(Integer.valueOf(sub[0]), Integer.valueOf(sub[1])));
        }
        return list;
    }

    public static void print(List<Interval> list) {
        if (list == null) {
            System.out.println("null");
            return;
        }
        StringBuilder sb = new StringBuilder();
        for (Interval interval : list) {
            sb.append("[")
                    .append(interval.start)
                    .append(",")
                    .append(interval.end)
                    .append("],");
        }
        System.out.println(sb.substring(0, sb.length() - 1));
    }
}
package com.blankj.hard._004;

/**
 * <pre>
 *     author: Blankj
 *     blog  : http://blankj.com
 *     time  : 2017/10/12
 *     desc  :
 * </pre>
 */
public class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int len = nums1.length + nums2.length;
        if (len % 2 == 0) {
            return (helper(nums1, 0, nums2, 0, len / 2) + helper(nums1, 0, nums2, 0, len / 2 + 1)) / 2.0;
        }
        return helper(nums1, 0, nums2, 0, (len + 1) / 2);
    }

    private int helper(int[] nums1, int m, int[] nums2, int n, int k) {
        if (m >= nums1.length) return nums2[n + k - 1];
        if (n >= nums2.length) return nums1[m + k - 1];
        if (k == 1) return Math.min(nums1[m], nums2[n]);

        int p1 = m + k / 2 - 1;
        int p2 = n + k / 2 - 1;
        int mid1 = p1 < nums1.length ? nums1[p1] : Integer.MAX_VALUE;
        int mid2 = p2 < nums2.length ? nums2[p2] : Integer.MAX_VALUE;
        if (mid1 < mid2) {
            return helper(nums1, m + k / 2, nums2, n, k - k / 2);
        }
        return helper(nums1, m, nums2, n + k / 2, k - k / 2);
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        System.out.println(solution.findMedianSortedArrays(
                new int[]{1, 3},
                new int[]{2}
        ));
        System.out.println(solution.findMedianSortedArrays(
                new int[]{1, 2},
                new int[]{3, 4}
        ));
    }
}
package com.blankj.hard._068;

import java.util.ArrayList;
import java.util.List;

/**
 * <pre>
 *     author: Blankj
 *     blog  : http://blankj.com
 *     time  : 2017/11/01
 *     desc  :
 * </pre>
 */
public class Solution {

    public List<String> fullJustify(String[] words, int maxWidth) {
        int len = words.length;
        List<String> ans = new ArrayList<>();
        StringBuilder spaces = new StringBuilder();
        for (int i = 0; i < maxWidth; ++i) {
            spaces.append(" ");
        }
        int curLen = -1, start = 0;
        for (int i = 0; i < len; ++i) {
            if (curLen + words[i].length() + 1 <= maxWidth) {
                curLen += words[i].length() + 1;
            } else {
                StringBuilder sub = new StringBuilder(words[start]);
                int rest = maxWidth - curLen;
                int l = i - start - 1;
                if (l <= 0) {
                    sub.append(spaces.substring(0, rest));
                } else {
                    int m = rest / l + 1;
                    int mod = rest % l;
                    for (int j = start + 1; j < i; ++j) {
                        if (mod-- > 0) {
                            sub.append(spaces.substring(0, m + 1)).append(words[j]);
                        } else {
                            sub.append(spaces.substring(0, m)).append(words[j]);
                        }
                    }
                }
                ans.add(sub.toString());
                start = i;
                curLen = words[i].length();
            }
        }
        StringBuilder sub = new StringBuilder(words[start]);
        for (int i = start + 1; i < len; ++i) {
            sub.append(" ").append(words[i]);
        }
        ans.add(sub + spaces.substring(0, maxWidth - sub.length()));
        return ans;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        System.out.println(solution.fullJustify(new String[]{"This", "is", "an", "example", "of", "text", "justification."}, 16));
    }
}
package com.blankj.medium._050;

/**
 * <pre>
 *     author: Blankj
 *     blog  : http://blankj.com
 *     time  : 2017/10/18
 *     desc  :
 * </pre>
 */
public class Solution {
    public double myPow(double x, int n) {
        if (n < 0) return helper(1 / x, -n);
        return helper(x, n);
    }

    private double helper(double x, int n) {
        if (n == 0) return 1;
        if (n == 1) return x;
        double d = helper(x, n >>> 1);
        if (n % 2 == 0) return d * d;
        return d * d * x;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        System.out.println(solution.myPow(8.88023, 3));
    }
}
package com.blankj.medium._002;

import com.blankj.structure.ListNode;

/**
 * <pre>
 *     author: Blankj
 *     blog  : http://blankj.com
 *     time  : 2017/10/11
 *     desc  :
 * </pre>
 */
public class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode node = new ListNode(0);
        ListNode n1 = l1, n2 = l2, t = node;
        int sum = 0;
        while (n1 != null || n2 != null) {
            sum /= 10;
            if (n1 != null) {
                sum += n1.val;
                n1 = n1.next;
            }
            if (n2 != null) {
                sum += n2.val;
                n2 = n2.next;
            }
            t.next = new ListNode(sum % 10);
            t = t.next;
        }
        if (sum / 10 != 0) t.next = new ListNode(1);
        return node.next;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        ListNode.print(solution.addTwoNumbers(
                ListNode.createTestData("[2,4,3]"),
                ListNode.createTestData("[5,6,4]")
        ));
    }
}
package com.blankj.medium._003;

/**
 * <pre>
 *     author: Blankj
 *     blog  : http://blankj.com
 *     time  : 2017/10/11
 *     desc  :
 * </pre>
 */
public class Solution {
    public int lengthOfLongestSubstring(String s) {
        int len;
        if (s == null || (len = s.length()) == 0) return 0;
        int preP = 0, max = 0;
        int[] hash = new int[128];
        for (int i = 0; i < len; ++i) {
            char c = s.charAt(i);
            if (hash[c] > preP) {
                preP = hash[c];
            }
            int l = i - preP + 1;
            hash[c] = i + 1;
            if (l > max) max = l;
        }
        return max;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        System.out.println(solution.lengthOfLongestSubstring("abcabcbb"));
        System.out.println(solution.lengthOfLongestSubstring("bbbbb"));
        System.out.println(solution.lengthOfLongestSubstring("pwwkew"));
        System.out.println(solution.lengthOfLongestSubstring("Abcabcbb"));
    }
}
package com.jeremyfeinstein.slidingmenu.example;

import android.os.Bundle;
import android.support.v4.app.FragmentActivity;

import com.jeremyfeinstein.slidingmenu.lib.SlidingMenu;

public class AttachExample extends FragmentActivity {

	private SlidingMenu menu;

	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);

		setTitle(R.string.attach);

		// set the Above View
		setContentView(R.layout.content_frame);
		getSupportFragmentManager()
		.beginTransaction()
		.replace(R.id.content_frame, new SampleListFragment())
		.commit();

		// configure the SlidingMenu
		menu = new SlidingMenu(this);
		menu.setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN);
		menu.setShadowWidthRes(R.dimen.shadow_width);
		menu.setShadowDrawable(R.drawable.shadow);
		menu.setBehindOffsetRes(R.dimen.slidingmenu_offset);
		menu.setFadeDegree(0.35f);
		menu.attachToActivity(this, SlidingMenu.SLIDING_CONTENT);
		menu.setMenu(R.layout.menu_frame);
		getSupportFragmentManager()
		.beginTransaction()
		.replace(R.id.menu_frame, new SampleListFragment())
		.commit();
	}

	@Override
	public void onBackPressed() {
		if (menu.isMenuShowing()) {
			menu.showContent();
		} else {
			super.onBackPressed();
		}
	}

}
package com.jeremyfeinstein.slidingmenu.example;

import java.util.ArrayList;
import java.util.List;

import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentPagerAdapter;
import android.support.v4.app.FragmentTransaction;
import android.support.v4.app.ListFragment;
import android.support.v4.view.ViewPager;

import com.actionbarsherlock.view.Menu;
import com.actionbarsherlock.view.MenuItem;
import com.jeremyfeinstein.slidingmenu.lib.SlidingMenu;
import com.jeremyfeinstein.slidingmenu.lib.app.SlidingFragmentActivity;

public class BaseActivity extends SlidingFragmentActivity {

	private int mTitleRes;
	protected ListFragment mFrag;

	public BaseActivity(int titleRes) {
		mTitleRes = titleRes;
	}

	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);

		setTitle(mTitleRes);

		// set the Behind View
		setBehindContentView(R.layout.menu_frame);
		if (savedInstanceState == null) {
			FragmentTransaction t = this.getSupportFragmentManager().beginTransaction();
			mFrag = new SampleListFragment();
			t.replace(R.id.menu_frame, mFrag);
			t.commit();
		} else {
			mFrag = (ListFragment)this.getSupportFragmentManager().findFragmentById(R.id.menu_frame);
		}

		// customize the SlidingMenu
		SlidingMenu sm = getSlidingMenu();
		sm.setShadowWidthRes(R.dimen.shadow_width);
		sm.setShadowDrawable(R.drawable.shadow);
		sm.setBehindOffsetRes(R.dimen.slidingmenu_offset);
		sm.setFadeDegree(0.35f);
		sm.setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN);

		getSupportActionBar().setDisplayHomeAsUpEnabled(true);
	}

	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		switch (item.getItemId()) {
		case android.R.id.home:
			toggle();
			return true;
		case R.id.github:
			Util.goToGitHub(this);
			return true;
		}
		return super.onOptionsItemSelected(item);
	}

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		getSupportMenuInflater().inflate(R.menu.main, menu);
		return true;
	}
}
package com.jeremyfeinstein.slidingmenu.example;

import java.net.URLEncoder;

import android.app.AlertDialog;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.preference.Preference;
import android.preference.PreferenceScreen;
import android.text.Html;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.ImageView;
import android.widget.ListView;
import android.widget.TextView;
import android.widget.Toast;

import com.actionbarsherlock.app.SherlockPreferenceActivity;
import com.actionbarsherlock.view.Menu;
import com.actionbarsherlock.view.MenuItem;
import com.crittercism.app.Crittercism;
import com.jeremyfeinstein.slidingmenu.example.anim.CustomScaleAnimation;
import com.jeremyfeinstein.slidingmenu.example.anim.CustomSlideAnimation;
import com.jeremyfeinstein.slidingmenu.example.anim.CustomZoomAnimation;
import com.jeremyfeinstein.slidingmenu.example.fragments.FragmentChangeActivity;
import com.jeremyfeinstein.slidingmenu.example.fragments.ResponsiveUIActivity;

public class ExampleListActivity extends SherlockPreferenceActivity {

	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setTitle(R.string.app_name);
		
//		Crittercism.init(getApplicationContext(), "508ab27601ed857a20000003");
		this.addPreferencesFromResource(R.xml.main);
	}

	@Override
	public boolean onPreferenceTreeClick(PreferenceScreen screen, Preference pref) {
		Class<?> cls = null;
		String title = pref.getTitle().toString();
		if (title.equals(getString(R.string.properties))) {
			cls = PropertiesActivity.class;	
		} else if (title.equals(getString(R.string.attach))) {
			cls = AttachExample.class;
		} else if (title.equals(getString(R.string.changing_fragments))) {
			cls = FragmentChangeActivity.class;
		} else if (title.equals(getString(R.string.left_and_right))) {
			cls = LeftAndRightActivity.class;
		} else if (title.equals(getString(R.string.responsive_ui))) {
			cls = ResponsiveUIActivity.class;
		} else if (title.equals(getString(R.string.viewpager))) {
			cls = ViewPagerActivity.class;
		} else if (title.equals(getString(R.string.title_bar_slide))) {
			cls = SlidingTitleBar.class;
		} else if (title.equals(getString(R.string.title_bar_content))) {
			cls = SlidingContent.class;
		} else if (title.equals(getString(R.string.anim_zoom))) {
			cls = CustomZoomAnimation.class;
		} else if (title.equals(getString(R.string.anim_scale))) {
			cls = CustomScaleAnimation.class;
		} else if (title.equals(getString(R.string.anim_slide))) {
			cls = CustomSlideAnimation.class;
		}
		Intent intent = new Intent(this, cls);
		startActivity(intent);
		return true;
	}

	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		switch (item.getItemId()) {
		case R.id.github:
			Util.goToGitHub(this);
			return true;
		case R.id.about:
			new AlertDialog.Builder(this)
			.setTitle(R.string.about)
			.setMessage(Html.fromHtml(getString(R.string.about_msg)))
			.show();
			break;
		case R.id.licenses:
			new AlertDialog.Builder(this)
			.setTitle(R.string.licenses)
			.setMessage(Html.fromHtml(getString(R.string.apache_license)))
			.show();
			break;
		case R.id.contact:
			final Intent email = new Intent(android.content.Intent.ACTION_SENDTO);
			String uriText = "mailto:jfeinstein10@gmail.com" +
					"?subject=" + URLEncoder.encode("SlidingMenu Demos Feedback"); 
			email.setData(Uri.parse(uriText));
			try {
				startActivity(email);
			} catch (Exception e) {
				Toast.makeText(this, R.string.no_email, Toast.LENGTH_SHORT).show();
			}
			break;
		}
		return super.onOptionsItemSelected(item);
	}

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		getSupportMenuInflater().inflate(R.menu.example_list, menu);
		return true;
	}
	
}
package com.jeremyfeinstein.slidingmenu.example;

import android.os.Bundle;
import android.view.KeyEvent;
import android.view.View;
import android.view.ViewGroup;

import com.jeremyfeinstein.slidingmenu.example.fragments.ColorFragment;
import com.jeremyfeinstein.slidingmenu.lib.SlidingMenu;
import com.jeremyfeinstein.slidingmenu.lib.SlidingMenu.OnClosedListener;
import com.jeremyfeinstein.slidingmenu.lib.SlidingMenu.OnOpenedListener;


public class LeftAndRightActivity extends BaseActivity {

	public LeftAndRightActivity() {
		super(R.string.left_and_right);
	}

	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		getSlidingMenu().setMode(SlidingMenu.LEFT_RIGHT);
		getSlidingMenu().setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN);
		
		setContentView(R.layout.content_frame);
		getSupportFragmentManager()
		.beginTransaction()
		.replace(R.id.content_frame, new SampleListFragment())
		.commit();
		
		getSlidingMenu().setSecondaryMenu(R.layout.menu_frame_two);
		getSlidingMenu().setSecondaryShadowDrawable(R.drawable.shadowright);
		getSupportFragmentManager()
		.beginTransaction()
		.replace(R.id.menu_frame_two, new SampleListFragment())
		.commit();
	}

}
package com.jeremyfeinstein.slidingmenu.example;

import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.RadioGroup;
import android.widget.RadioGroup.OnCheckedChangeListener;
import android.widget.SeekBar;
import android.widget.SeekBar.OnSeekBarChangeListener;

import com.jeremyfeinstein.slidingmenu.lib.SlidingMenu;

public class PropertiesActivity extends BaseActivity {

	public PropertiesActivity() {
		super(R.string.properties);
	}

	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);

		setSlidingActionBarEnabled(true);

		setContentView(R.layout.properties);
		
		// left and right modes
		RadioGroup mode = (RadioGroup) findViewById(R.id.mode);
		mode.check(R.id.left);
		mode.setOnCheckedChangeListener(new OnCheckedChangeListener() {
			@Override
			public void onCheckedChanged(RadioGroup group, int checkedId) {
				SlidingMenu sm = getSlidingMenu();
				switch (checkedId) {
				case R.id.left:
					sm.setMode(SlidingMenu.LEFT);
					sm.setShadowDrawable(R.drawable.shadow);
					break;
				case R.id.right:
					sm.setMode(SlidingMenu.RIGHT);
					sm.setShadowDrawable(R.drawable.shadowright);
					break;
				case R.id.left_right:
					sm.setMode(SlidingMenu.LEFT_RIGHT);
					sm.setSecondaryMenu(R.layout.menu_frame_two);
					getSupportFragmentManager()
					.beginTransaction()
					.replace(R.id.menu_frame_two, new SampleListFragment())
					.commit();					
					sm.setSecondaryShadowDrawable(R.drawable.shadowright);
					sm.setShadowDrawable(R.drawable.shadow);
				}
			}			
		});

		// touch mode stuff
		RadioGroup touchAbove = (RadioGroup) findViewById(R.id.touch_above);
		touchAbove.check(R.id.touch_above_full);
		touchAbove.setOnCheckedChangeListener(new OnCheckedChangeListener() {
			@Override
			public void onCheckedChanged(RadioGroup group, int checkedId) {
				switch (checkedId) {
				case R.id.touch_above_full:
					getSlidingMenu().setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN);
					break;
				case R.id.touch_above_margin:
					getSlidingMenu().setTouchModeAbove(SlidingMenu.TOUCHMODE_MARGIN);
					break;
				case R.id.touch_above_none:
					getSlidingMenu().setTouchModeAbove(SlidingMenu.TOUCHMODE_NONE);
					break;
				}
			}
		});

		// scroll scale stuff
		SeekBar scrollScale = (SeekBar) findViewById(R.id.scroll_scale);
		scrollScale.setMax(1000);
		scrollScale.setProgress(333);
		scrollScale.setOnSeekBarChangeListener(new OnSeekBarChangeListener() {
			@Override
			public void onProgressChanged(SeekBar seekBar, int progress,
					boolean fromUser) { }
			@Override
			public void onStartTrackingTouch(SeekBar seekBar) { }
			@Override
			public void onStopTrackingTouch(SeekBar seekBar) {
				getSlidingMenu().setBehindScrollScale((float) seekBar.getProgress()/seekBar.getMax());
			}
		});


		// behind width stuff
		SeekBar behindWidth = (SeekBar) findViewById(R.id.behind_width);
		behindWidth.setMax(1000);
		behindWidth.setProgress(750);
		behindWidth.setOnSeekBarChangeListener(new OnSeekBarChangeListener() {
			@Override
			public void onProgressChanged(SeekBar seekBar, int progress,
					boolean fromUser) { }
			@Override
			public void onStartTrackingTouch(SeekBar seekBar) { }
			@Override
			public void onStopTrackingTouch(SeekBar seekBar) {
				float percent = (float) seekBar.getProgress()/seekBar.getMax();
				getSlidingMenu().setBehindWidth((int) (percent * getSlidingMenu().getWidth()));
				getSlidingMenu().requestLayout();
			}
		});

		// shadow stuff
		CheckBox shadowEnabled = (CheckBox) findViewById(R.id.shadow_enabled);
		shadowEnabled.setChecked(true);
		shadowEnabled.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
			public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
				if (isChecked)
					getSlidingMenu().setShadowDrawable(
							getSlidingMenu().getMode() == SlidingMenu.LEFT ? 
									R.drawable.shadow : R.drawable.shadowright);
				else
					getSlidingMenu().setShadowDrawable(null);
			}
		});
		SeekBar shadowWidth = (SeekBar) findViewById(R.id.shadow_width);
		shadowWidth.setMax(1000);
		shadowWidth.setProgress(75);
		shadowWidth.setOnSeekBarChangeListener(new OnSeekBarChangeListener() {
			@Override
			public void onProgressChanged(SeekBar arg0, int arg1, boolean arg2) { }
			@Override
			public void onStartTrackingTouch(SeekBar seekBar) { }
			@Override
			public void onStopTrackingTouch(SeekBar seekBar) {
				float percent = (float) seekBar.getProgress()/ (float) seekBar.getMax();
				int width = (int) (percent * (float) getSlidingMenu().getWidth());
				getSlidingMenu().setShadowWidth(width);
				getSlidingMenu().invalidate();
			}
		});

		// fading stuff
		CheckBox fadeEnabled = (CheckBox) findViewById(R.id.fade_enabled);
		fadeEnabled.setChecked(true);
		fadeEnabled.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
			@Override
			public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
				getSlidingMenu().setFadeEnabled(isChecked);
			}			
		});
		SeekBar fadeDeg = (SeekBar) findViewById(R.id.fade_degree);
		fadeDeg.setMax(1000);
		fadeDeg.setProgress(666);
		fadeDeg.setOnSeekBarChangeListener(new OnSeekBarChangeListener() {
			@Override
			public void onProgressChanged(SeekBar seekBar, int progress,
					boolean fromUser) { }
			@Override
			public void onStartTrackingTouch(SeekBar seekBar) { }
			@Override
			public void onStopTrackingTouch(SeekBar seekBar) {
				getSlidingMenu().setFadeDegree((float) seekBar.getProgress()/seekBar.getMax());
			}			
		});
	}

}
package com.jeremyfeinstein.slidingmenu.example;

import android.content.Context;
import android.os.Bundle;
import android.support.v4.app.ListFragment;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.ImageView;
import android.widget.TextView;

public class SampleListFragment extends ListFragment {

	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		return inflater.inflate(R.layout.list, null);
	}

	public void onActivityCreated(Bundle savedInstanceState) {
		super.onActivityCreated(savedInstanceState);
		SampleAdapter adapter = new SampleAdapter(getActivity());
		for (int i = 0; i < 20; i++) {
			adapter.add(new SampleItem("Sample List", android.R.drawable.ic_menu_search));
		}
		setListAdapter(adapter);
	}

	private class SampleItem {
		public String tag;
		public int iconRes;
		public SampleItem(String tag, int iconRes) {
			this.tag = tag; 
			this.iconRes = iconRes;
		}
	}

	public class SampleAdapter extends ArrayAdapter<SampleItem> {

		public SampleAdapter(Context context) {
			super(context, 0);
		}

		public View getView(int position, View convertView, ViewGroup parent) {
			if (convertView == null) {
				convertView = LayoutInflater.from(getContext()).inflate(R.layout.row, null);
			}
			ImageView icon = (ImageView) convertView.findViewById(R.id.row_icon);
			icon.setImageResource(getItem(position).iconRes);
			TextView title = (TextView) convertView.findViewById(R.id.row_title);
			title.setText(getItem(position).tag);

			return convertView;
		}

	}
}
package com.jeremyfeinstein.slidingmenu.example;

import java.util.ArrayList;

import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentPagerAdapter;
import android.support.v4.view.ViewPager;
import android.support.v4.view.ViewPager.OnPageChangeListener;

import com.jeremyfeinstein.slidingmenu.example.fragments.ColorFragment;
import com.jeremyfeinstein.slidingmenu.lib.SlidingMenu;

public class ViewPagerActivity extends BaseActivity {

	public ViewPagerActivity() {
		super(R.string.viewpager);
	}

	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);

		ViewPager vp = new ViewPager(this);
		vp.setId("VP".hashCode());
		vp.setAdapter(new ColorPagerAdapter(getSupportFragmentManager()));
		setContentView(vp);

		vp.setOnPageChangeListener(new OnPageChangeListener() {
			@Override
			public void onPageScrollStateChanged(int arg0) { }

			@Override
			public void onPageScrolled(int arg0, float arg1, int arg2) { }

			@Override
			public void onPageSelected(int position) {
				switch (position) {
				case 0:
					getSlidingMenu().setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN);
					break;
				default:
					getSlidingMenu().setTouchModeAbove(SlidingMenu.TOUCHMODE_MARGIN);
					break;
				}
			}

		});
		
		vp.setCurrentItem(0);
		getSlidingMenu().setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN);
	}

	public class ColorPagerAdapter extends FragmentPagerAdapter {
		
		private ArrayList<Fragment> mFragments;

		private final int[] COLORS = new int[] {
			R.color.red,
			R.color.green,
			R.color.blue,
			R.color.white,
			R.color.black
		};
		
		public ColorPagerAdapter(FragmentManager fm) {
			super(fm);
			mFragments = new ArrayList<Fragment>();
			for (int color : COLORS)
				mFragments.add(new ColorFragment(color));
		}

		@Override
		public int getCount() {
			return mFragments.size();
		}

		@Override
		public Fragment getItem(int position) {
			return mFragments.get(position);
		}

	}

}
package com.jeremyfeinstein.slidingmenu.example.fragments;

import android.app.Activity;
import android.content.Intent;
import android.content.res.TypedArray;
import android.graphics.Color;
import android.graphics.drawable.ColorDrawable;
import android.os.Bundle;
import android.os.Handler;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.Window;
import android.widget.ImageView;
import android.widget.ImageView.ScaleType;

import com.actionbarsherlock.app.SherlockActivity;
import com.actionbarsherlock.view.MenuItem;
import com.jeremyfeinstein.slidingmenu.example.R;

public class BirdActivity extends SherlockActivity {

	private Handler mHandler;
	
	public static Intent newInstance(Activity activity, int pos) {
		Intent intent = new Intent(activity, BirdActivity.class);
		intent.putExtra("pos", pos);
		return intent;
	}
	
	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		int pos = 0;
		if (getIntent().getExtras() != null) {
			pos = getIntent().getExtras().getInt("pos");
		}
		
		String[] birds = getResources().getStringArray(R.array.birds);
		TypedArray imgs = getResources().obtainTypedArray(R.array.birds_img);
		int resId = imgs.getResourceId(pos, -1);
		
		setTitle(birds[pos]);
		getWindow().requestFeature(Window.FEATURE_ACTION_BAR_OVERLAY);
		ColorDrawable color = new ColorDrawable(Color.BLACK);
		color.setAlpha(128);
		getSupportActionBar().setBackgroundDrawable(color);
		getSupportActionBar().setDisplayHomeAsUpEnabled(true);
		mHandler = new Handler();
		
		ImageView imageView = new ImageView(this);
		imageView.setScaleType(ScaleType.CENTER_INSIDE);
		imageView.setImageResource(resId);
		imageView.setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
				getSupportActionBar().show();
				hideActionBarDelayed(mHandler);
			}
		});
		setContentView(imageView);
		this.getWindow().setBackgroundDrawableResource(android.R.color.black);
	}
	
	@Override
	public void onResume() {
		super.onResume();
		getSupportActionBar().show();
		hideActionBarDelayed(mHandler);
	}
	
	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		switch (item.getItemId()) {
		case android.R.id.home:
			finish();
			return true;
		}
		return super.onOptionsItemSelected(item);
	}
	
	private void hideActionBarDelayed(Handler handler) {
		handler.postDelayed(new Runnable() {
			public void run() {
				getSupportActionBar().hide();
			}
		}, 2000);
	}
	
}
package com.jeremyfeinstein.slidingmenu.example.fragments;

import android.content.res.TypedArray;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.BaseAdapter;
import android.widget.GridView;
import android.widget.ImageView;

import com.jeremyfeinstein.slidingmenu.example.R;

public class BirdGridFragment extends Fragment {

	private int mPos = -1;
	private int mImgRes;
	
	public BirdGridFragment() { }
	public BirdGridFragment(int pos) {
		mPos = pos;
	}
	
	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		if (mPos == -1 && savedInstanceState != null)
			mPos = savedInstanceState.getInt("mPos");
		TypedArray imgs = getResources().obtainTypedArray(R.array.birds_img);
		mImgRes = imgs.getResourceId(mPos, -1);
		
		GridView gv = (GridView) inflater.inflate(R.layout.list_grid, null);
		gv.setBackgroundResource(android.R.color.black);
		gv.setAdapter(new GridAdapter());
		gv.setOnItemClickListener(new OnItemClickListener() {
			@Override
			public void onItemClick(AdapterView<?> parent, View view, int position,
					long id) {
				if (getActivity() == null)
					return;
				ResponsiveUIActivity activity = (ResponsiveUIActivity) getActivity();
				activity.onBirdPressed(mPos);
			}			
		});
		return gv;
	}
	
	@Override
	public void onSaveInstanceState(Bundle outState) {
		super.onSaveInstanceState(outState);
		outState.putInt("mPos", mPos);
	}
	
	private class GridAdapter extends BaseAdapter {

		@Override
		public int getCount() {
			return 30;
		}

		@Override
		public Object getItem(int position) {
			return null;
		}

		@Override
		public long getItemId(int position) {
			return position;
		}

		@Override
		public View getView(int position, View convertView, ViewGroup parent) {
			if (convertView == null) {
				convertView = getActivity().getLayoutInflater().inflate(R.layout.grid_item, null);
			}
			ImageView img = (ImageView) convertView.findViewById(R.id.grid_item_img);
			img.setImageResource(mImgRes);
			return convertView;
		}
		
	}
}
package com.jeremyfeinstein.slidingmenu.example.fragments;

import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v4.app.ListFragment;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.ListView;

import com.jeremyfeinstein.slidingmenu.example.R;

public class BirdMenuFragment extends ListFragment {
	
	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		return inflater.inflate(R.layout.list, null);
	}

	@Override
	public void onActivityCreated(Bundle savedInstanceState) {
		super.onActivityCreated(savedInstanceState);
		String[] birds = getResources().getStringArray(R.array.birds);
		ArrayAdapter<String> colorAdapter = new ArrayAdapter<String>(getActivity(), 
				android.R.layout.simple_list_item_1, android.R.id.text1, birds);
		setListAdapter(colorAdapter);
	}
	
	@Override
	public void onListItemClick(ListView lv, View v, int position, long id) {
		Fragment newContent = new BirdGridFragment(position);
		if (newContent != null)
			switchFragment(newContent);
	}
	
	// the meat of switching the above fragment
	private void switchFragment(Fragment fragment) {
		if (getActivity() == null)
			return;

		if (getActivity() instanceof ResponsiveUIActivity) {
			ResponsiveUIActivity ra = (ResponsiveUIActivity) getActivity();
			ra.switchContent(fragment);
		}
	}
}
package com.jeremyfeinstein.slidingmenu.example.fragments;

import com.jeremyfeinstein.slidingmenu.example.R;

import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.RelativeLayout;

public class ColorFragment extends Fragment {
	
	private int mColorRes = -1;
	
	public ColorFragment() { 
		this(R.color.white);
	}
	
	public ColorFragment(int colorRes) {
		mColorRes = colorRes;
		setRetainInstance(true);
	}

	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		if (savedInstanceState != null)
			mColorRes = savedInstanceState.getInt("mColorRes");
		int color = getResources().getColor(mColorRes);
		// construct the RelativeLayout
		RelativeLayout v = new RelativeLayout(getActivity());
		v.setBackgroundColor(color);		
		return v;
	}
	
	@Override
	public void onSaveInstanceState(Bundle outState) {
		super.onSaveInstanceState(outState);
		outState.putInt("mColorRes", mColorRes);
	}
	
}
package com.jeremyfeinstein.slidingmenu.example.fragments;

import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v4.app.ListFragment;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.ListView;

import com.jeremyfeinstein.slidingmenu.example.R;

public class ColorMenuFragment extends ListFragment {

	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		return inflater.inflate(R.layout.list, null);
	}

	@Override
	public void onActivityCreated(Bundle savedInstanceState) {
		super.onActivityCreated(savedInstanceState);
		String[] colors = getResources().getStringArray(R.array.color_names);
		ArrayAdapter<String> colorAdapter = new ArrayAdapter<String>(getActivity(), 
				android.R.layout.simple_list_item_1, android.R.id.text1, colors);
		setListAdapter(colorAdapter);
	}

	@Override
	public void onListItemClick(ListView lv, View v, int position, long id) {
		Fragment newContent = null;
		switch (position) {
		case 0:
			newContent = new ColorFragment(R.color.red);
			break;
		case 1:
			newContent = new ColorFragment(R.color.green);
			break;
		case 2:
			newContent = new ColorFragment(R.color.blue);
			break;
		case 3:
			newContent = new ColorFragment(android.R.color.white);
			break;
		case 4:
			newContent = new ColorFragment(android.R.color.black);
			break;
		}
		if (newContent != null)
			switchFragment(newContent);
	}

	// the meat of switching the above fragment
	private void switchFragment(Fragment fragment) {
		if (getActivity() == null)
			return;
		
		if (getActivity() instanceof FragmentChangeActivity) {
			FragmentChangeActivity fca = (FragmentChangeActivity) getActivity();
			fca.switchContent(fragment);
		} else if (getActivity() instanceof ResponsiveUIActivity) {
			ResponsiveUIActivity ra = (ResponsiveUIActivity) getActivity();
			ra.switchContent(fragment);
		}
	}


}
package com.jeremyfeinstein.slidingmenu.example.fragments;

import android.os.Bundle;
import android.support.v4.app.Fragment;

import com.jeremyfeinstein.slidingmenu.example.BaseActivity;
import com.jeremyfeinstein.slidingmenu.example.R;
import com.jeremyfeinstein.slidingmenu.lib.SlidingMenu;

public class FragmentChangeActivity extends BaseActivity {
	
	private Fragment mContent;
	
	public FragmentChangeActivity() {
		super(R.string.changing_fragments);
	}
	
	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		// set the Above View
		if (savedInstanceState != null)
			mContent = getSupportFragmentManager().getFragment(savedInstanceState, "mContent");
		if (mContent == null)
			mContent = new ColorFragment(R.color.red);	
		
		// set the Above View
		setContentView(R.layout.content_frame);
		getSupportFragmentManager()
		.beginTransaction()
		.replace(R.id.content_frame, mContent)
		.commit();
		
		// set the Behind View
		setBehindContentView(R.layout.menu_frame);
		getSupportFragmentManager()
		.beginTransaction()
		.replace(R.id.menu_frame, new ColorMenuFragment())
		.commit();
		
		// customize the SlidingMenu
		getSlidingMenu().setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN);
	}
	
	@Override
	public void onSaveInstanceState(Bundle outState) {
		super.onSaveInstanceState(outState);
		getSupportFragmentManager().putFragment(outState, "mContent", mContent);
	}
	
	public void switchContent(Fragment fragment) {
		mContent = fragment;
		getSupportFragmentManager()
		.beginTransaction()
		.replace(R.id.content_frame, fragment)
		.commit();
		getSlidingMenu().showContent();
	}

}
package com.jeremyfeinstein.slidingmenu.example.fragments;

import android.app.AlertDialog;
import android.content.Intent;
import android.os.Bundle;
import android.os.Handler;
import android.support.v4.app.Fragment;
import android.view.View;

import com.actionbarsherlock.view.MenuItem;
import com.jeremyfeinstein.slidingmenu.example.R;
import com.jeremyfeinstein.slidingmenu.lib.SlidingMenu;
import com.jeremyfeinstein.slidingmenu.lib.app.SlidingFragmentActivity;

/**
 * This activity is an example of a responsive Android UI.
 * On phones, the SlidingMenu will be enabled only in portrait mode.
 * In landscape mode, it will present itself as a dual pane layout.
 * On tablets, it will will do the same general thing. In portrait
 * mode, it will enable the SlidingMenu, and in landscape mode, it
 * will be a dual pane layout.
 * 
 * @author jeremy
 *
 */
public class ResponsiveUIActivity extends SlidingFragmentActivity {

	private Fragment mContent;

	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setTitle(R.string.responsive_ui);

		setContentView(R.layout.responsive_content_frame);

		// check if the content frame contains the menu frame
		if (findViewById(R.id.menu_frame) == null) {
			setBehindContentView(R.layout.menu_frame);
			getSlidingMenu().setSlidingEnabled(true);
			getSlidingMenu().setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN);
			// show home as up so we can toggle
			getSupportActionBar().setDisplayHomeAsUpEnabled(true);
		} else {
			// add a dummy view
			View v = new View(this);
			setBehindContentView(v);
			getSlidingMenu().setSlidingEnabled(false);
			getSlidingMenu().setTouchModeAbove(SlidingMenu.TOUCHMODE_NONE);
		}

		// set the Above View Fragment
		if (savedInstanceState != null)
			mContent = getSupportFragmentManager().getFragment(savedInstanceState, "mContent");
		if (mContent == null)
			mContent = new BirdGridFragment(0);	
		getSupportFragmentManager()
		.beginTransaction()
		.replace(R.id.content_frame, mContent)
		.commit();

		// set the Behind View Fragment
		getSupportFragmentManager()
		.beginTransaction()
		.replace(R.id.menu_frame, new BirdMenuFragment())
		.commit();

		// customize the SlidingMenu
		SlidingMenu sm = getSlidingMenu();
		sm.setBehindOffsetRes(R.dimen.slidingmenu_offset);
		sm.setShadowWidthRes(R.dimen.shadow_width);
		sm.setShadowDrawable(R.drawable.shadow);
		sm.setBehindScrollScale(0.25f);
		sm.setFadeDegree(0.25f);

		// show the explanation dialog
		if (savedInstanceState == null)
			new AlertDialog.Builder(this)
			.setTitle(R.string.what_is_this)
			.setMessage(R.string.responsive_explanation)
			.show();
	}

	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		switch (item.getItemId()) {
		case android.R.id.home:
			toggle();
		}
		return super.onOptionsItemSelected(item);
	}

	@Override
	public void onSaveInstanceState(Bundle outState) {
		super.onSaveInstanceState(outState);
		getSupportFragmentManager().putFragment(outState, "mContent", mContent);
	}

	public void switchContent(final Fragment fragment) {
		mContent = fragment;
		getSupportFragmentManager()
		.beginTransaction()
		.replace(R.id.content_frame, fragment)
		.commit();
		Handler h = new Handler();
		h.postDelayed(new Runnable() {
			public void run() {
				getSlidingMenu().showContent();
			}
		}, 50);
	}	

	public void onBirdPressed(int pos) {
		Intent intent = BirdActivity.newInstance(this, pos);
		startActivity(intent);
	}

}
package com.jeremyfeinstein.slidingmenu.example.anim;

import android.os.Bundle;
import android.view.Menu;

import com.jeremyfeinstein.slidingmenu.example.BaseActivity;
import com.jeremyfeinstein.slidingmenu.example.R;
import com.jeremyfeinstein.slidingmenu.example.SampleListFragment;
import com.jeremyfeinstein.slidingmenu.example.R.id;
import com.jeremyfeinstein.slidingmenu.example.R.layout;
import com.jeremyfeinstein.slidingmenu.example.R.menu;
import com.jeremyfeinstein.slidingmenu.lib.SlidingMenu;
import com.jeremyfeinstein.slidingmenu.lib.SlidingMenu.CanvasTransformer;

public abstract class CustomAnimation extends BaseActivity {
	
	private CanvasTransformer mTransformer;
	
	public CustomAnimation(int titleRes, CanvasTransformer transformer) {
		super(titleRes);
		mTransformer = transformer;
	}

	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		// set the Above View
		setContentView(R.layout.content_frame);
		getSupportFragmentManager()
		.beginTransaction()
		.replace(R.id.content_frame, new SampleListFragment())
		.commit();
		
		SlidingMenu sm = getSlidingMenu();
		setSlidingActionBarEnabled(true);
		sm.setBehindScrollScale(0.0f);
		sm.setBehindCanvasTransformer(mTransformer);
	}

}
package com.jeremyfeinstein.slidingmenu.lib.app;

import android.os.Bundle;
import android.view.KeyEvent;
import android.view.View;
import android.view.ViewGroup.LayoutParams;

import com.google.android.maps.MapActivity;
import com.jeremyfeinstein.slidingmenu.lib.SlidingMenu;

public abstract class SlidingMapActivity extends MapActivity implements SlidingActivityBase {

	private SlidingActivityHelper mHelper;

	/* (non-Javadoc)
	 * @see com.google.android.maps.MapActivity#onCreate(android.os.Bundle)
	 */
	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		mHelper = new SlidingActivityHelper(this);
		mHelper.onCreate(savedInstanceState);
	}

	/* (non-Javadoc)
	 * @see android.app.Activity#onPostCreate(android.os.Bundle)
	 */
	@Override
	public void onPostCreate(Bundle savedInstanceState) {
		super.onPostCreate(savedInstanceState);
		mHelper.onPostCreate(savedInstanceState);
	}

	/* (non-Javadoc)
	 * @see android.app.Activity#findViewById(int)
	 */
	@Override
	public View findViewById(int id) {
		View v = super.findViewById(id);
		if (v != null)
			return v;
		return mHelper.findViewById(id);
	}

	/* (non-Javadoc)
	 * @see android.app.Activity#onSaveInstanceState(android.os.Bundle)
	 */
	@Override
	protected void onSaveInstanceState(Bundle outState) {
		super.onSaveInstanceState(outState);
		mHelper.onSaveInstanceState(outState);
	}

	/* (non-Javadoc)
	 * @see android.app.Activity#setContentView(int)
	 */
	@Override
	public void setContentView(int id) {
		setContentView(getLayoutInflater().inflate(id, null));
	}

	/* (non-Javadoc)
	 * @see android.app.Activity#setContentView(android.view.View)
	 */
	@Override
	public void setContentView(View v) {
		setContentView(v, new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
	}

	/* (non-Javadoc)
	 * @see android.app.Activity#setContentView(android.view.View, android.view.ViewGroup.LayoutParams)
	 */
	@Override
	public void setContentView(View v, LayoutParams params) {
		super.setContentView(v, params);
		mHelper.registerAboveContentView(v, params);
	}

	/* (non-Javadoc)
	 * @see com.jeremyfeinstein.slidingmenu.lib.app.SlidingActivityBase#setBehindContentView(int)
	 */
	public void setBehindContentView(int id) {
		setBehindContentView(getLayoutInflater().inflate(id, null));
	}

	/* (non-Javadoc)
	 * @see com.jeremyfeinstein.slidingmenu.lib.app.SlidingActivityBase#setBehindContentView(android.view.View)
	 */
	public void setBehindContentView(View v) {
		setBehindContentView(v, new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
	}

	/* (non-Javadoc)
	 * @see com.jeremyfeinstein.slidingmenu.lib.app.SlidingActivityBase#setBehindContentView(android.view.View, android.view.ViewGroup.LayoutParams)
	 */
	public void setBehindContentView(View v, LayoutParams params) {
		mHelper.setBehindContentView(v, params);
	}

	/* (non-Javadoc)
	 * @see com.jeremyfeinstein.slidingmenu.lib.app.SlidingActivityBase#getSlidingMenu()
	 */
	public SlidingMenu getSlidingMenu() {
		return mHelper.getSlidingMenu();
	}

	/* (non-Javadoc)
	 * @see com.jeremyfeinstein.slidingmenu.lib.app.SlidingActivityBase#toggle()
	 */
	public void toggle() {
		mHelper.toggle();
	}

	/* (non-Javadoc)
	 * @see com.jeremyfeinstein.slidingmenu.lib.app.SlidingActivityBase#showAbove()
	 */
	public void showContent() {
		mHelper.showContent();
	}

	/* (non-Javadoc)
	 * @see com.jeremyfeinstein.slidingmenu.lib.app.SlidingActivityBase#showBehind()
	 */
	public void showMenu() {
		mHelper.showMenu();
	}

	/* (non-Javadoc)
	 * @see com.jeremyfeinstein.slidingmenu.lib.app.SlidingActivityBase#showSecondaryMenu()
	 */
	public void showSecondaryMenu() {
		mHelper.showSecondaryMenu();
	}

	/* (non-Javadoc)
	 * @see com.jeremyfeinstein.slidingmenu.lib.app.SlidingActivityBase#setSlidingActionBarEnabled(boolean)
	 */
	public void setSlidingActionBarEnabled(boolean b) {
		mHelper.setSlidingActionBarEnabled(b);
	}

	/* (non-Javadoc)
	 * @see android.app.Activity#onKeyUp(int, android.view.KeyEvent)
	 */
	@Override
	public boolean onKeyUp(int keyCode, KeyEvent event) {
		boolean b = mHelper.onKeyUp(keyCode, event);
		if (b) return b;
		return super.onKeyUp(keyCode, event);
	}

}
package com.wakaleo.gameoflife.webtests;

import com.wakaleo.gameoflife.webtests.requirements.GameOfLifeApplication;
import com.wakaleo.gameoflife.webtests.steps.PlayerSteps;
import net.thucydides.core.annotations.Feature;
import net.thucydides.core.annotations.Managed;
import net.thucydides.core.annotations.ManagedPages;
import net.thucydides.core.annotations.Steps;
import net.thucydides.core.annotations.Story;
import net.thucydides.core.annotations.WithTag;
import net.thucydides.core.pages.Pages;
import net.thucydides.junit.runners.ThucydidesRunner;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.openqa.selenium.WebDriver;

@RunWith(ThucydidesRunner.class)
@WithTag("Starting a new simulation")
public class WhenTheUserEntersAnInitialGrid {

    @Managed(uniqueSession = true)
    WebDriver driver;

    @ManagedPages(defaultUrl = "http://localhost:9090")
    public Pages pages;

    @Steps
    PlayerSteps player;


    final static String[][] EMPTY_GRID
            = new String[][]{{".", ".", "."},
            {".", ".", "."},
            {".", ".", "."}};


    @Test
    public void userShouldBeAbleChooseToCreateANewGameOnTheHomePage() {
        player.opens_home_page();
        player.chooses_to_start_a_new_game();
        player.should_see_a_page_containing_text("Please seed your universe");

    }

    @Test
    public void userShouldBeAbleToSeedAnEmptyGridOnTheNewGamePage() {
        player.opens_home_page();
        player.chooses_to_start_a_new_game();
        player.starts_simulation();
        player.should_see_grid(EMPTY_GRID);
    }

    @Test
    public void theGridDisplayPageShouldContainANextGenerationButton() {
        player.opens_home_page();
        player.chooses_to_start_a_new_game();
        player.starts_simulation();
        player.should_see_a_page_containing_text("Next Generation");
    }

    @Test
    public void userShouldBeAbleToEnterOneLiveCellInTheGrid() {
        player.opens_home_page();
        player.chooses_to_start_a_new_game();
        player.clicks_on_cell_at(1, 1);
        player.starts_simulation();

        String[][] expectedGrid = new String[][]{{".", ".", "."},
                {".", "*", "."},
                {".", ".", "."}};

        player.should_see_grid(expectedGrid);
    }

    @Test
    public void userShouldBeAbleToEnterLiveCellsInTheGrid() {
        player.opens_home_page();
        player.chooses_to_start_a_new_game();
        player.clicks_on_cell_at(0, 0);
        player.clicks_on_cell_at(0, 1);
        player.clicks_on_cell_at(1, 1);
        player.starts_simulation();

        String[][] expectedGrid = new String[][]{{"*", "*", "."},
                {".", "*", "."},
                {".", ".", "."}};

        player.should_see_grid(expectedGrid);
    }


    @Test
    public void theGridPageShouldHaveALinkBackToTheHomePage() {
        player.opens_home_page();
        player.chooses_to_start_a_new_game();
        player.clicks_on_home();
        player.should_see_a_page_containing_text("Welcome to Conway's Game Of Life");
    }
}
package com.wakaleo.gameoflife.webtests;

import com.wakaleo.gameoflife.webtests.requirements.GameOfLifeApplication.RunSimulations.RunASimulation;
import com.wakaleo.gameoflife.webtests.steps.PlayerSteps;
import net.thucydides.core.annotations.Managed;
import net.thucydides.core.annotations.ManagedPages;
import net.thucydides.core.annotations.Steps;
import net.thucydides.core.annotations.Story;
import net.thucydides.core.annotations.WithTag;
import net.thucydides.core.pages.Pages;
import net.thucydides.junit.runners.ThucydidesRunner;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.openqa.selenium.WebDriver;

@RunWith(ThucydidesRunner.class)
@Story(RunASimulation.class)

@WithTag("Viewing previous games")
public class WhenTheUserGoesToTheHomePage {

    @Managed
    WebDriver driver;

    @ManagedPages(defaultUrl = "http://localhost:9090")
    public Pages pages;

    @Steps
    PlayerSteps player;

    @Test
    public void homePageShouldDisplayWelcomeMessage() {

        player.opens_home_page();
        player.should_see_title_of("The Game Of Life");
    }
}
package com.wakaleo.gameoflife.webtests;

import com.wakaleo.gameoflife.webtests.requirements.GameOfLifeApplication;
import com.wakaleo.gameoflife.webtests.steps.PlayerSteps;
import net.thucydides.core.annotations.Managed;
import net.thucydides.core.annotations.ManagedPages;
import net.thucydides.core.annotations.Steps;
import net.thucydides.core.annotations.Story;
import net.thucydides.core.annotations.WithTag;
import net.thucydides.core.pages.Pages;
import net.thucydides.junit.runners.ThucydidesRunner;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.openqa.selenium.WebDriver;

@RunWith(ThucydidesRunner.class)

@WithTag("Configuring a simulation")
public class WhenTheUserSpawnsTheNextGeneration {

    @Managed(uniqueSession = true)
    WebDriver driver;

    @ManagedPages(defaultUrl = "http://localhost:9090")
    public Pages pages;

    @Steps
    PlayerSteps player;


    final static String[][] EMPTY_GRID
            = new String[][]{{".", ".", "."},
            {".", ".", "."},
            {".", ".", "."}};


    @Test
    public void anEmptyGridShouldProduceAnEmptyGrid() {
        String[][] expectedGrid = new String[][]{{".", ".", "."},
                {".", ".", "."},
                {".", ".", "."}};

        player.opens_home_page();
        player.chooses_to_start_a_new_game();
        player.starts_simulation();
        player.continues_simulation();
        player.should_see_grid(expectedGrid);

    }

    @Test
    public void aGridWithOneCellShouldProduceAnEmptyGrid() {
        String[][] expectedGrid = new String[][]{{".", ".", "."},
                {".", ".", "."},
                {".", ".", "."}};

        player.opens_home_page();
        player.chooses_to_start_a_new_game();
        player.clicks_on_cell_at(1, 1);
        player.starts_simulation();
        player.continues_simulation();
        player.should_see_grid(expectedGrid);
    }

    @Test
    public void aGridWithTwoCellsShouldProduceAnEmptyGrid() {
        String[][] expectedGrid = new String[][]{{".", ".", "."},
                {".", ".", "."},
                {".", ".", "."}};

        player.opens_home_page();
        player.chooses_to_start_a_new_game();
        player.clicks_on_cell_at(1, 1);
        player.clicks_on_cell_at(0, 1);
        player.starts_simulation();
        player.continues_simulation();
        player.should_see_grid(expectedGrid);
    }


    @Test
    public void aStableCellSetShouldProduceTheSameSetOfCells() {
        String[][] expectedGrid = new String[][]{{"*", "*", "."},
                {"*", "*", "."},
                {".", ".", "."}};

        player.opens_home_page();
        player.chooses_to_start_a_new_game();
        player.clicks_on_cell_at(0, 0);
        player.clicks_on_cell_at(0, 1);
        player.clicks_on_cell_at(1, 0);
        player.clicks_on_cell_at(1, 1);
        player.starts_simulation();
        player.continues_simulation();
        player.should_see_grid(expectedGrid);
    }

    @Test
    public void aRotatingCellSetShouldProduceTheExpectedNewSetOfCells() {
        String[][] expectedGrid = new String[][]{{".", ".", "."},
                {".", "*", "."},
                {".", "*", "."}};

        player.opens_home_page();
        player.chooses_to_start_a_new_game();
        player.clicks_on_cell_at(0, 0);
        player.clicks_on_cell_at(0, 1);
        player.clicks_on_cell_at(1, 0);
        player.clicks_on_cell_at(1, 1);
        player.clicks_on_cell_at(1, 2);
        player.starts_simulation();
        player.continues_simulation();
        player.continues_simulation();
        player.continues_simulation();
        player.should_see_grid(expectedGrid);
    }

    @Test
    public void aRotatingCellSetShouldProduceTheOriginalSetOfCellsAfterTwoGenerations() {
        String[][] expectedGrid = new String[][]{{".", ".", "."},
                {"*", "*", "*"},
                {".", ".", "."}};

        player.opens_home_page();
        player.chooses_to_start_a_new_game();
        player.clicks_on_cell_at(1, 0);
        player.clicks_on_cell_at(1, 1);
        player.clicks_on_cell_at(1, 2);
        player.starts_simulation();
        player.continues_simulation();
        player.continues_simulation();
        player.should_see_grid(expectedGrid);
    }

    @Test
    public void aRotatingCellSetShouldProduceTheOriginalSetOfCellsAfterThreeGenerations() {
        String[][] expectedGrid = new String[][]{{".", "*", "."},
                {".", "*", "."},
                {".", "*", "."}};

        player.opens_home_page();
        player.chooses_to_start_a_new_game();
        player.clicks_on_cell_at(1, 0);
        player.clicks_on_cell_at(1, 1);
        player.clicks_on_cell_at(1, 2);
        player.starts_simulation();
        player.continues_simulation();
        player.continues_simulation();
        player.continues_simulation();
        player.should_see_grid(expectedGrid);
    }

}
package com.wakaleo.gameoflife.webtests.steps;

import com.wakaleo.gameoflife.webtests.pages.EnterGridPage;
import com.wakaleo.gameoflife.webtests.pages.GameOfLifePage;
import com.wakaleo.gameoflife.webtests.pages.HomePage;
import com.wakaleo.gameoflife.webtests.pages.ShowGridPage;
import net.thucydides.core.annotations.Step;
import net.thucydides.core.pages.Pages;

import static org.fest.assertions.Assertions.assertThat;

public class PlayerSteps {

    private Pages pages;

    @Step
    public void opens_home_page() {
        onHomePage().open();
    }

    @Step
    public void should_see_title_of(String expectedTitle) {
        assertThat(currentPage().getTitle()).contains(expectedTitle);
    }

    @Step
    public void chooses_to_start_a_new_game() {
        onHomePage().clickOnNewGameLink();
    }

    @Step
    public void should_see_a_page_containing_text(String expectedText) {
        currentPage().shouldContainText(expectedText);
    }

    @Step
    public void should_see_grid(String[][] expectedGrid) {
        assertThat(onShowGridPage().getDisplayedGrid()).isEqualTo(expectedGrid);
    }

    @Step
    public void starts_simulation() {
        onEnterGridPage().clickOnGoButton();
    }

    @Step
    public void clicks_on_cell_at(int row, int column) {
        onEnterGridPage().clickOnCellAt(row, column);
    }

    @Step
    public void clicks_on_home() {
        currentPage().clickOnHome();
    }

    private HomePage onHomePage() {
        return pages.currentPageAt(HomePage.class);
    }

    private EnterGridPage onEnterGridPage() {
        return pages.currentPageAt(EnterGridPage.class);
    }

    private ShowGridPage onShowGridPage() {
        return pages.currentPageAt(ShowGridPage.class);
    }

    private GameOfLifePage currentPage() {
        return pages.get(GameOfLifePage.class);
    }

    public void continues_simulation() {
        onShowGridPage().clickOnNextGenerationButton();
    }
}
/******************************************************************************
 * Copyright (c) 2000-2017 Ericsson Telecom AB
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   
 *   Keremi, Andras
 *   Eros, Levente
 *   Kovacs, Gabor
 *
 ******************************************************************************/

package org.eclipse.titan.codegenerator;

public class Additional_Class_Writer {

	public String writeHCClass() {
		StringBuilder hcString = new StringBuilder("\r\n");

		hcString.append("public class HC {" + "\r\n");

		hcString.append("	private static int SERVERPORTNUM = "
				+ AstWalkerJava.props.getProperty("serverportnum") + ";" + "\r\n");
		hcString.append("	private static String MCIP=\"127.0.0.1\";" + "\r\n");

		hcString.append("	private static HCType hc;" + "\r\n");
		hcString.append("	private static boolean DEBUGMODE=false;" + "\r\n");
		hcString.append("	public static void main(String args[]){" + "\r\n");
		hcString.append("		hc=new HCType();" + "\r\n");
		hcString.append("		hc.starthc(MCIP,SERVERPORTNUM);" + "\r\n");
		hcString.append("		TTCN3Logger.writeLog(\"hc\", \"EXECUTOR\", \"Host Controller stopped.\", false);" + "\r\n");
		hcString.append("		System.exit(0);" + "\r\n"); 
		hcString.append("	}" + "\r\n");

		hcString.append("}" + "\r\n");

		return hcString.toString();
	}

	public String writeHCTypeClass() {

		StringBuilder hcTypeString = new StringBuilder("");

		hcTypeString.append("public class HCType {" + "\r\n");
		hcTypeString.append("	" + "\r\n");
		hcTypeString.append("	boolean waitingforconnect;" + "\r\n");
		hcTypeString.append("	boolean waitingfordisconnect;" + "\r\n");
		hcTypeString.append("	boolean waitingformap;" + "\r\n");
		hcTypeString.append("	Socket sock;" + "\r\n");
		hcTypeString.append("	BufferedWriter writer;" + "\r\n");
		hcTypeString.append("	BufferedReader reader;" + "\r\n");
		hcTypeString.append("	Vector<ComponentDef> componentpool;" + "\r\n"); // components
																				// run
																				// by
																				// HC
		hcTypeString.append("	Vector<Thread> portlistenerpool;" + "\r\n");
		hcTypeString.append("	int NEXTPORTNUM = 6000; " + "\r\n");// port used
																	// for
																	// opening
																	// sockets
		hcTypeString.append("	public boolean debugmode; " + "\r\n");
		hcTypeString.append("	" + "\r\n");
		
		hcTypeString.append("	public HCType(){" + "\r\n");
		hcTypeString.append("		componentpool = new Vector<ComponentDef>();"
				+ "\r\n");
		hcTypeString.append("		portlistenerpool = new Vector<Thread>();"
				+ "\r\n");
		hcTypeString.append("		this.debugmode=debugmode;"+ "\r\n");
		hcTypeString.append("	}" + "\r\n");
		hcTypeString.append("	" + "\r\n");
		
		hcTypeString
				.append("	public void connect(String comp1, String port1, String comp2, String port2){"
						+ "\r\n");
		hcTypeString.append("		this.waitingforconnect=true;" + "\r\n");
		hcTypeString.append("		if(debugmode)TTCN3Logger.writeLog(\"hc\", \"EXECUTOR\", \"Connecting \" + comp1 + \":\" + port1 + \" to \" + comp2 + \":\" + port2, false);" + "\r\n");
		hcTypeString
				.append("		sendtomc(\"connect \"+comp1+\" \"+ port1+\" \"+comp2+\" \"+port2);"
						+ "\r\n");
		hcTypeString.append("		for(;this.waitingforconnect;){" + "\r\n");
		hcTypeString.append("			try{" + "\r\n");
		hcTypeString.append("				Thread.sleep(100);" + "\r\n");
		hcTypeString.append("			}catch(Exception e){}	" + "\r\n");
		hcTypeString.append("		}" + "\r\n");
		hcTypeString.append("	}" + "\r\n");
		hcTypeString.append("	" + "\r\n");
		
		hcTypeString.append("public void disconnect(String comp1, String port1, String comp2, String port2){" + "\r\n");
		hcTypeString.append("	this.waitingfordisconnect=true;" + "\r\n");
		hcTypeString.append("	if(debugmode)TTCN3Logger.writeLog(\"hc\", \"EXECUTOR\", \"Disconnecting \" + comp1 + \":\" + port1 + \" from \" + comp2 + \":\" + port2, false);" + "\r\n");
		hcTypeString.append("	sendtomc(\"disconnect \"+comp1+\" \"+ port1+\" \"+comp2+\" \"+port2);" + "\r\n");
		hcTypeString.append("	for(;this.waitingfordisconnect;){" + "\r\n");
		hcTypeString.append("		try{" + "\r\n");
		hcTypeString.append("			Thread.sleep(100);" + "\r\n");
		hcTypeString.append("		}catch(Exception e){}	" + "\r\n");
		hcTypeString.append("	}" + "\r\n");
		hcTypeString.append("}" + "\r\n");
		
		hcTypeString.append("public void map(String comp1, String port1, String comp2, String port2){" + "\r\n");
		hcTypeString.append("	this.waitingformap=true;" + "\r\n");
		hcTypeString.append("	sendtomc(\"map \"+comp1+\" \"+ port1+\" \"+comp2+\" \"+port2);" + "\r\n");
		hcTypeString.append("	for(;this.waitingformap;){" + "\r\n");
		hcTypeString.append("		try{" + "\r\n");
		hcTypeString.append("			Thread.sleep(100);" + "\r\n");
		hcTypeString.append("		}catch(Exception e){}" + "\r\n");
		hcTypeString.append("	}" + "\r\n");
		hcTypeString.append("}" + "\r\n");
		
		hcTypeString
				.append("	public void start(String component, String function){"
						+ "\r\n");
		hcTypeString.append("		if(debugmode)TTCN3Logger.writeLog(\"hc\", \"EXECUTOR\", \"Starting function \" + function + \" on component \" + component, false);"+ "\r\n");
		hcTypeString
				.append("		sendtomc(\"start \" + component + \" \" + function);"
						+ "\r\n");
		hcTypeString.append("	}" + "\r\n");
		hcTypeString.append("	" + "\r\n");
		hcTypeString
				.append("	public void create(String name, String type, String ip){"
						+ "\r\n");
		hcTypeString
				.append("		sendtomc(\"create \" + name + \" \" + type + \" \" + ip);"
						+ "\r\n");
		hcTypeString.append("	}" + "\r\n");
		hcTypeString.append("	" + "\r\n");
		hcTypeString.append("	public void sendtomc(String message){" + "\r\n"); 
		hcTypeString.append("		try{" + "\r\n");
		hcTypeString.append("			writer.write(message + \"\\r\\n\");" + "\r\n");
		hcTypeString.append("			writer.flush();" + "\r\n");
		hcTypeString.append("			TTCN3Logger.writeLog(\"hc\", \"EXECUTOR\", \"HC->MC: \" + message, false);"
				+ "\r\n");
		hcTypeString.append("		}catch(Exception e){}" + "\r\n");
		hcTypeString.append("	}" + "\r\n");
		hcTypeString.append("	" + "\r\n");
		hcTypeString
				.append("	public void registercomponent(String name, String type, String ID){"
						+ "\r\n");
		hcTypeString
		.append("	TTCN3Logger.writeLog(\"hc\", \"EXECUTOR\", \"Creating PTC \" + name + \" with ID \" + ID, false);"+ "\r\n");

		for (int i = 0; i < AstWalkerJava.componentList.size(); i++) {
			hcTypeString.append("		if(type.equals(\"" + AstWalkerJava.componentList.get(i)
					+ "\")) componentpool.add(new " + AstWalkerJava.componentList.get(i)
					+ "(this,name,ID));" + "\r\n");
		}
		hcTypeString.append("	}" + "\r\n");
		hcTypeString.append("	" + "\r\n");
		hcTypeString.append("	private ComponentDef getcomponent(String name){"
				+ "\r\n");
		hcTypeString.append("		for(int i=0;i<componentpool.size();i++)"
				+ "\r\n");
		hcTypeString.append("			if(componentpool.get(i).name.equals(name))"
				+ "\r\n");
		hcTypeString.append("				return componentpool.get(i);" + "\r\n");
		hcTypeString.append("		return null;" + "\r\n");
		hcTypeString.append("	}" + "\r\n");
		hcTypeString.append("	" + "\r\n");
		hcTypeString.append("	public void done(String message){ " + "\r\n");// can
																			// only
																			// be
																			// called
																			// in
																			// the
																			// HC
																			// of
																			// mtc
		hcTypeString.append("		sendtomc(\"done \" + message);" + "\r\n");
		hcTypeString.append("		try{" + "\r\n");
		hcTypeString.append("			getcomponent(\"mtc\").donequeue.take();"
				+ "\r\n");

		hcTypeString.append("		}catch(Exception e){}" + "\r\n");
		hcTypeString.append("	}" + "\r\n");
		hcTypeString.append("	" + "\r\n");
		hcTypeString
				.append("	public void finished(ComponentDef c, String function){"
						+ "\r\n");
		hcTypeString
				.append("		sendtomc(\"finished \" + c.name + \" \" + Integer.toString(c.getVerdictInt()));"
						+ "\r\n");
		hcTypeString.append("	}" + "\r\n");
		hcTypeString.append("	" + "\r\n");
		hcTypeString
				.append("	public void starthc(String mcIp,int serverportnum){"
						+ "\r\n");
		hcTypeString.append("		TTCN3Logger.writeLog(\"hc\", \"EXECUTOR\", \"Host Controller started\", false);" + "\r\n");
		hcTypeString.append("		try{" + "\r\n");
		hcTypeString.append("			if(debugmode)TTCN3Logger.writeLog(\"hc\", \"EXECUTOR\", \"Connecting to Main Controller on IP \" + mcIp + \" port \" + serverportnum, false);" + "\r\n");
		hcTypeString.append("			sock = new Socket(mcIp,serverportnum);"
				+ "\r\n"); // for outgoing signal messages
		hcTypeString.append("			if(debugmode)TTCN3Logger.writeLog(\"hc\", \"EXECUTOR\", \"Connected to Main Controller\", false);"
				+ "\r\n");
		hcTypeString
				.append("			writer = new BufferedWriter(new OutputStreamWriter(sock.getOutputStream()));"
						+ "\r\n"); 
		hcTypeString
				.append("			reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));"
						+ "\r\n");
		hcTypeString
				.append("			if(debugmode)TTCN3Logger.writeLog(\"hc\", \"EXECUTOR\", \"Waiting for control message from Main Controller\", false);"
						+ "\r\n");
		hcTypeString.append("			for(;;){" + "\r\n");
		hcTypeString.append("				String msg = reader.readLine();" + "\r\n");
		hcTypeString
				.append("				if(debugmode)TTCN3Logger.writeLog(\"hc\", \"EXECUTOR\", \"Received control message \" + msg, false);"
						+ "\r\n");
		hcTypeString.append("				if(msg.equals(\"quit\")) break;" + "\r\n");
		hcTypeString.append("				if(msg.equals(\"connected\")){" + "\r\n");
		hcTypeString.append("					this.waitingforconnect=false;" + "\r\n");
		hcTypeString.append("				}" + "\r\n");
		
		hcTypeString.append("				if(msg.equals(\"disconnected\")){" + "\r\n");
		hcTypeString.append("					this.waitingfordisconnect=false;" + "\r\n");
		hcTypeString.append("					}" + "\r\n");
		
		
		hcTypeString.append("				if(msg.equals(\"mapped\")){" + "\r\n");
		hcTypeString.append("					this.waitingformap=false;" + "\r\n");
		hcTypeString.append("				}" + "\r\n");
		hcTypeString.append("				String command = msg.split(\" \")[0];"
				+ "\r\n");
		hcTypeString.append("				//logged on receiver side instead of default sender side (because a test case might be the entry point of execution)"+ "\r\n");
		hcTypeString.append("				if(command.equals(\"execute\")){" + "\r\n");
		hcTypeString.append("					String tcasename = msg.split(\" \")[1];"
				+ "\r\n");


		
		for (int i = 0; i < AstWalkerJava.testCaseList.size(); i++) {
			hcTypeString.append("					if(tcasename.equals(\""
					+ AstWalkerJava.testCaseList.get(i) + "\")){" + "\r\n"); 
			hcTypeString.append("						if(debugmode)TTCN3Logger.writeLog(\"hc\", \"EXECUTOR\", \"Creating MTC\", false);" + "\r\n");
			hcTypeString.append("						registercomponent(\"mtc\", \""
					+ AstWalkerJava.testCaseRunsOnList.get(i) + "\", \"2\");" + "\r\n"); 
			hcTypeString.append("						if(debugmode)TTCN3Logger.writeLog(\"hc\", \"EXECUTOR\", \"Starting new Thread for MTC\", false);" + "\r\n");
			hcTypeString.append("						Thread testcasethread = new Thread(new "
					+ AstWalkerJava.testCaseList.get(i) + "((" + AstWalkerJava.testCaseRunsOnList.get(i)
					+ ")getcomponent(\"mtc\")));" + "\r\n");
			hcTypeString
					.append("						getcomponent(\"mtc\").thread=testcasethread;"
							+ "\r\n");
			hcTypeString.append("						testcasethread.start();" + "\r\n");
			hcTypeString.append("					}" + "\r\n");
		}

		hcTypeString.append("				}" + "\r\n");
		hcTypeString.append("				//logged on receiver side instead of default sender side (because of centrally generated IDs)" + "\r\n");
		
		hcTypeString.append("				if(command.equals(\"create\")){" + "\r\n");
		hcTypeString.append("					String compname = msg.split(\" \")[1];"
				+ "\r\n");
		hcTypeString.append("					String comptype = msg.split(\" \")[2];"
				+ "\r\n");
		hcTypeString.append("					String compid = msg.split(\" \")[3];"+ "\r\n");
		hcTypeString.append("					registercomponent(compname, comptype, compid);"
				+ "\r\n");
		hcTypeString.append("				}" + "\r\n");
		
		hcTypeString.append("				if(command.equals(\"prepareforconnection\")){"
				+ "\r\n");
		hcTypeString.append("					String thiscomp = msg.split(\" \")[1];"
				+ "\r\n");
		hcTypeString.append("					String thisport = msg.split(\" \")[2];"
				+ "\r\n");
		hcTypeString.append("					String remotecomp = msg.split(\" \")[3];"
				+ "\r\n");
		hcTypeString.append("					String remoteport = msg.split(\" \")[4];"
				+ "\r\n");
		hcTypeString.append("					if(debugmode)TTCN3Logger.writeLog(\"hc\", \"EXECUTOR\", \"Preparing for connection of component \" + thiscomp + \" port \" + thisport + \" and component \" + remotecomp + \" port \" + remoteport, false);"+ "\r\n");
		hcTypeString
				.append("					getcomponent(thiscomp).prepareforconnection(thisport,NEXTPORTNUM);"
						+ "\r\n");
		hcTypeString
				.append("					sendtomc(\"preparedforconnection \" + remotecomp + \" \" + remoteport + \" \" + Integer.toString(NEXTPORTNUM) + \" \" + thiscomp);"
						+ "\r\n");
		hcTypeString.append("					NEXTPORTNUM++;" + "\r\n");
		hcTypeString.append("				}" + "\r\n");
		
		hcTypeString.append("				if(command.equals(\"connect\")){" + "\r\n");
		hcTypeString.append("					String component = msg.split(\" \")[1];"
				+ "\r\n");
		hcTypeString.append("					String port = msg.split(\" \")[2];" + "\r\n");
		hcTypeString.append("					String ip = msg.split(\" \")[3];" + "\r\n");
		hcTypeString.append("					String portnum = msg.split(\" \")[4];"
				+ "\r\n");
		hcTypeString.append("					if(debugmode)TTCN3Logger.writeLog(\"hc\", \"EXECUTOR\", \"Connecting to component \" + component + \" port \" + port + \" on \" + ip + \":\" + portnum, false);"+ "\r\n");
		hcTypeString
				.append("					getcomponent(component).connect(port,ip,portnum);"
						+ "\r\n"); 
		hcTypeString.append("					sendtomc(\"connected\");" + "\r\n");
		hcTypeString.append("				}" + "\r\n");
		
		hcTypeString.append("			if(command.equals(\"disconnect\")){" + "\r\n");
		hcTypeString.append("				String comp1 = msg.split(\" \")[1];" + "\r\n");
		hcTypeString.append("				String port1 = msg.split(\" \")[2];" + "\r\n");
		hcTypeString.append("				String comp2 = msg.split(\" \")[3];" + "\r\n");
		hcTypeString.append("				String port2 = msg.split(\" \")[4];" + "\r\n");
		hcTypeString.append("				if(debugmode)TTCN3Logger.writeLog(\"hc\", \"EXECUTOR\", \"Disonnecting component \" + comp1 + \" port \" + port1 + \" from component \" + comp2 + \" port \" + port2, false);" + "\r\n");
		hcTypeString.append("				getcomponent(comp1).disconnect(port1,comp2,port2);" + "\r\n");
		hcTypeString.append("				sendtomc(\"disconnected\");" + "\r\n");
		hcTypeString.append("			}" + "\r\n");
		
		
		
		hcTypeString.append("if(command.equals(\"map\")){" + "\r\n");
		hcTypeString.append("	String thiscomp = msg.split(\" \")[1];" + "\r\n");
		hcTypeString.append("	String thisport = msg.split(\" \")[2];" + "\r\n");
		hcTypeString.append("	String remotecomp = msg.split(\" \")[3];" + "\r\n");
		hcTypeString.append("	String remoteport = msg.split(\" \")[4];" + "\r\n");
		hcTypeString.append("	getcomponent(thiscomp).domap(thisport, remotecomp, remoteport);" + "\r\n");
		hcTypeString.append("	sendtomc(\"mapped\");" + "\r\n");
		hcTypeString.append("}" + "\r\n");
		
		
		hcTypeString.append("				if(command.equals(\"start\")){" + "\r\n");
		hcTypeString
				.append("					ComponentDef component = getcomponent(msg.split(\" \")[1]);"
						+ "\r\n");
		hcTypeString.append("					String function = msg.split(\" \")[2];"
				+ "\r\n");


		for (int i = 0; i < AstWalkerJava.functionList.size(); i++) {
			hcTypeString.append("					if(function.equals(\""
					+ AstWalkerJava.functionList.get(i) + "\")){ " + "\r\n");
			hcTypeString
					.append("						if(component.thread!=null) component.thread.join();"
							+ "\r\n"); 
			hcTypeString.append("						Thread functionthread = new Thread(new "
					+ AstWalkerJava.functionList.get(i) + "((" + AstWalkerJava.functionRunsOnList.get(i)
					+ ")component));" + "\r\n");
			hcTypeString.append("						component.thread=functionthread;"
					+ "\r\n");
			hcTypeString.append("						functionthread.start();" + "\r\n");
			hcTypeString.append("						if(debugmode)TTCN3Logger.writeLog(\"hc\", \"EXECUTOR\", \"Function f_SENDER started on PTC \" + component, false);" + "\r\n");
			hcTypeString.append("					}" + "\r\n");
		}

		hcTypeString.append("				}" + "\r\n");
		hcTypeString.append("				//logged on receiver side instead of default sender side (because of various done arguments processed here)" + "\r\n"); 
		hcTypeString.append("				if(command.equals(\"done\")){" + "\r\n");
		hcTypeString.append("					if(msg.equals(\"done all component\")){"
				+ "\r\n");
		hcTypeString.append("						for(ComponentDef c:componentpool)" + "\r\n");
		hcTypeString.append("							if(!c.name.equals(\"mtc\")){" + "\r\n");
		
		hcTypeString
				.append("								TTCN3Logger.writeLog(\"hc\", \"EXECUTOR\", \"Waiting for component \" + c.name + \" to be done\", false);"
						+ "\r\n");
		hcTypeString.append("								if(c.thread!=null) c.thread.join();" + "\r\n");
		hcTypeString.append("								//logged by mc too" + "\r\n");
		hcTypeString
				.append("								if(debugmode)TTCN3Logger.writeLog(\"hc\", \"EXECUTOR\", \"Component \" + c.name + \" is done\", false);"
						+ "\r\n");
		hcTypeString
				.append("								sendtomc(\"finished \" + c.name + \" \" + Integer.toString(c.getVerdictInt()));"
						+ "\r\n");
		hcTypeString.append("							}" + "\r\n");
		hcTypeString.append("					}" + "\r\n");
		hcTypeString.append("					else{" + "\r\n");
		hcTypeString
				.append("						ComponentDef c = getcomponent(msg.split(\" \")[1]);"
						+ "\r\n");
		hcTypeString.append("						if(!c.name.equals(\"mtc\"))c.thread.join();"
				+ "\r\n");
		hcTypeString
				.append("						sendtomc(\"finished\" + c.name + \" \" + Integer.toString(c.getVerdictInt()));"
						+ "\r\n");
		hcTypeString.append("					}					" + "\r\n");
		hcTypeString.append("				}" + "\r\n");
		hcTypeString.append("				if(command.equals(\"finished\")){" + "\r\n"); // only
		// mtc
		// receives
		// this
		// if
		// all
		// components
		// that
		// have
		// to
		// be
		// done
		// are
		// done
		hcTypeString.append("					getcomponent(\"mtc\").donequeue.add(true);"
				+ "\r\n");
		hcTypeString.append("				}" + "\r\n");
		hcTypeString.append("			}" + "\r\n");
		hcTypeString.append("			this.sock.close();" + "\r\n");
		hcTypeString.append("		}catch(Exception e){e.printStackTrace();}"
				+ "\r\n");
		hcTypeString.append("		for(Thread t:portlistenerpool) if(t!=null) t.interrupt(); "
				+ "\r\n");
		hcTypeString.append("	}" + "\r\n");
		hcTypeString.append("	" + "\r\n");
		hcTypeString.append("}" + "\r\n");

		return hcTypeString.toString();
	}

	public static void writeExternalPortClass(String nodeName) {
		StringBuilder externalPort=new StringBuilder();
		
		externalPort.append("package org.eclipse.titan.codegenerator.javagen;"+"\r\n");
		externalPort.append("import java.io.ObjectInputStream;"+"\r\n");
		externalPort.append("import java.io.ObjectOutputStream;"+"\r\n");
		externalPort.append("import java.net.ServerSocket;"+"\r\n");
		externalPort.append("import java.net.Socket;"+"\r\n");
		externalPort.append("import java.util.Scanner; "+"\r\n");
		
		externalPort.append("import org.eclipse.titan.codegenerator.TTCN3JavaAPI.*;"+"\r\n");
		
		externalPort.append("public class TP_"+nodeName+" {"+"\r\n");
		externalPort.append("	private "+nodeName+" port;"+"\r\n");
		externalPort.append("	public TP_"+nodeName+"("+nodeName+" p){"+"\r\n");
		externalPort.append("		port=p;"+"\r\n");
		externalPort.append("	}"+"\r\n");
		
		externalPort.append("	//must block until map is done"+"\r\n");
		externalPort.append("	public void user_map(String remotecomp, String remoteport){"+"\r\n");
		externalPort.append("		new TestPortDaemon(this).start();"+"\r\n");
		externalPort.append("	}"+"\r\n");
		
		externalPort.append("	//must block until unmap is done"+"\r\n");
		externalPort.append("	public void user_unmap(String remotecomp, String remoteport){ "+"\r\n");
		externalPort.append("	}"+"\r\n");
		
		externalPort.append("	public void user_send(Object o){"+"\r\n");
		externalPort.append("	}"+"\r\n");
		
		externalPort.append("	class TestPortDaemon extends Thread{"+"\r\n");
		externalPort.append("		private TP_"+nodeName+" testport;"+"\r\n");
		externalPort.append("		public TestPortDaemon(TP_"+nodeName+" p){"+"\r\n");
		externalPort.append("			testport = p;"+"\r\n");
		externalPort.append("		}"+"\r\n");
		externalPort.append("		public void run(){"+"\r\n");
		externalPort.append("			testport.port.mapped=true;"+"\r\n");
		//externalPort.append("			Scanner scanner = new Scanner(System.in);"+"\r\n");
		externalPort.append("			for(;;){//should block until a new message is received"+"\r\n");
		//externalPort.append("				String inmsg = scanner.nextLine();"+"\r\n");
		//externalPort.append("				testport.port.enqueue(new CHARSTRING(inmsg));"+"\r\n");
		externalPort.append("			}"+"\r\n");
		externalPort.append("		}"+"\r\n");
		externalPort.append("	}"+"\r\n");
		externalPort.append("}"+"\r\n");
		
		String backupFilename=myASTVisitor.currentFileName;
		myASTVisitor.currentFileName="TP_"+nodeName;
		myASTVisitor.visualizeNodeToJava(externalPort.toString());
		myASTVisitor.currentFileName=backupFilename;
		
	}

}
/******************************************************************************
 * Copyright (c) 2000-2017 Ericsson Telecom AB
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   
 *   Keremi, Andras
 *   Eros, Levente
 *   Kovacs, Gabor
 *   Meszaros, Mate Robert
 *
 ******************************************************************************/

package org.eclipse.titan.codegenerator;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import java.util.logging.FileHandler;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.debug.core.DebugPlugin;
import org.eclipse.debug.core.ILaunchConfiguration;
import org.eclipse.debug.core.ILaunchConfigurationType;
import org.eclipse.debug.core.ILaunchConfigurationWorkingCopy;
import org.eclipse.debug.core.ILaunchManager;
import org.eclipse.debug.ui.DebugUITools;
import org.eclipse.jface.action.IAction;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.titan.codegenerator.experimental.LoggerVisitor;
import org.eclipse.titan.designer.AST.ASTVisitor;
import org.eclipse.titan.designer.AST.Module;
import org.eclipse.titan.designer.AST.TTCN3.definitions.Definitions;
import org.eclipse.titan.designer.AST.TTCN3.definitions.TTCN3Module;
import org.eclipse.titan.designer.parsers.ttcn3parser.TTCN3Analyzer;
import org.eclipse.ui.IEditorInput;
import org.eclipse.ui.IEditorPart;
import org.eclipse.ui.IEditorReference;
import org.eclipse.ui.IFileEditorInput;
import org.eclipse.ui.IWorkbenchPage;
import org.eclipse.ui.IWorkbenchWindow;
import org.eclipse.ui.IWorkbenchWindowActionDelegate;
import org.eclipse.ui.PartInitException;
import org.eclipse.ui.console.ConsolePlugin;
import org.eclipse.ui.console.IConsole;
import org.eclipse.ui.console.IConsoleManager;
import org.eclipse.ui.console.MessageConsole;
import org.eclipse.ui.console.MessageConsoleStream;

public final class AstRunnerJava implements IWorkbenchWindowActionDelegate {

	private static IWorkbenchWindow window;

	private static Logger logger;

	private static IProject selectedProject;
	public static Properties props;
	private static List<String> fileNames;
	private static List<IFile> files;

	private static TTCN3Module currentTTCN3module;

	public static String moduleElementName = "";

	public static boolean areCommentsAllowed = true;
	public static List<String> componentList = new ArrayList<String>();
	public static List<String> testCaseList = new ArrayList<String>();
	public static List<String> testCaseRunsOnList = new ArrayList<String>();
	public static List<String> functionList = new ArrayList<String>();
	public static List<String> functionRunsOnList = new ArrayList<String>();

	static {
		try {
			boolean append = true;
			props = new Properties();
			props.load(AstRunnerJava.class.getResourceAsStream("walker.properties"));

			FileHandler fh = new FileHandler(props.getProperty("log.path"), append);

			fh.setFormatter(new SimpleFormatter());
			logger = Logger.getLogger(AstRunnerJava.class.getName());
			logger.addHandler(fh);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public static void main(String args[]) {
		new AstRunnerJava().run(null);
	}

	public void run(IAction action) {

		boolean projectfound=false;
		IProject[] projects = ResourcesPlugin.getWorkspace().getRoot().getProjects();
		for(IProject p:projects){
			if(p.getName().equals("org.eclipse.titan.codegenerator.output")) projectfound=true;
		}

		if(projectfound){
			ILaunchManager manager = DebugPlugin.getDefault().getLaunchManager();
			ILaunchConfigurationType type = manager.getLaunchConfigurationType("org.eclipse.jdt.launching.localJavaApplication");
			try{
				ILaunchConfiguration[] lcs = manager.getLaunchConfigurations(type);
				for(ILaunchConfiguration l: lcs){
					if(l.getName().equals("org.eclipse.titan.codegenerator.output.MC")) l.delete();
					if(l.getName().equals("org.eclipse.titan.codegenerator.output.HC")) l.delete();
				}
				
				ILaunchConfigurationWorkingCopy mcrc = type.newInstance(null, "org.eclipse.titan.codegenerator.output.MC");
				List<String> mcrespaths = new ArrayList<String>();
				mcrespaths.add("/org.eclipse.titan.codegenerator.output/src/org/eclipse/titan/codegenerator/TTCN3JavaAPI/MC.java");
				mcrc.setAttribute("org.eclipse.debug.core.MAPPED_RESOURCE_PATHS", mcrespaths);
				List<String> mcrestypes = new ArrayList<String>();
				mcrestypes.add("1");
				mcrc.setAttribute("org.eclipse.debug.core.MAPPED_RESOURCE_TYPES", mcrestypes);
				mcrc.setAttribute("org.eclipse.jdt.launching.MAIN_TYPE", "org.eclipse.titan.codegenerator.TTCN3JavaAPI.MC");
				mcrc.setAttribute("org.eclipse.jdt.launching.PROJECT_ATTR", "org.eclipse.titan.codegenerator.output");
				DebugUITools.launch(mcrc, ILaunchManager.RUN_MODE);
	
				ILaunchConfigurationWorkingCopy hcrc = type.newInstance(null, "org.eclipse.titan.codegenerator.output.HC");
				List<String> hcrespaths = new ArrayList<String>();
				hcrespaths.add("/org.eclipse.titan.codegenerator.output/src/org/eclipse/titan/codegenerator/javagen/HC.java");
				hcrc.setAttribute("org.eclipse.debug.core.MAPPED_RESOURCE_PATHS", hcrespaths);
				List<String> hcrestypes = new ArrayList<String>();
				hcrestypes.add("1");
				hcrc.setAttribute("org.eclipse.debug.core.MAPPED_RESOURCE_TYPES", hcrestypes);
				hcrc.setAttribute("org.eclipse.jdt.launching.MAIN_TYPE", "org.eclipse.titan.codegenerator.javagen.HC");
				hcrc.setAttribute("org.eclipse.jdt.launching.PROJECT_ATTR", "org.eclipse.titan.codegenerator.output");
				DebugUITools.launch(hcrc, ILaunchManager.RUN_MODE);
	
			}catch(Exception e){}
		}
		
	}

	public void selectionChanged(IAction action, ISelection selection) {
		// TODO Auto-generated method stub

	}

	private static void getActiveProject() {
		IWorkbenchPage p = window.getActivePage();
		IFile openFile = null;
		if (p != null) {
			IEditorPart e = p.getActiveEditor();
			if (e != null) {
				IEditorInput i = e.getEditorInput();
				if (i instanceof IFileEditorInput) {
					openFile = ((IFileEditorInput) i).getFile();
					if (openFile.getName().endsWith("ttcn3") || openFile.getName().endsWith("ttcn")) {
						AstRunnerJava.selectedProject = openFile.getProject();
					}
					logger.severe(openFile.getLocation().toOSString() + "\n");
				}
			}
		}

	}

	public static void initOutputFolder() {
		Path outputPath = Paths.get(props.getProperty("javafile.path"));
		if (Files.exists(outputPath)) {
			System.out.println("");
			File folder = new File(outputPath.toUri());
			File[] listOfFiles = folder.listFiles();
			for (int i = 0; i < listOfFiles.length; i++) {
				if (listOfFiles[i].getPath().toString().endsWith("java")) {
				} else {
					listOfFiles[i] = null;
				}
			}
			for (int i = 0; i < listOfFiles.length; i++) {
				if (listOfFiles[i] != null) {
					listOfFiles[i].delete();
				}
			}

		} else {
			(new File(props.getProperty("javafile.path"))).mkdirs();

		}
	}

	public void dispose() {
		// TODO Auto-generated method stub

	}

	public void init(IWorkbenchWindow window) {
		fileNames = new ArrayList<String>();
		files = new ArrayList<IFile>();
		AstRunnerJava.window = window;
		try {
			FileOutputStream fos = new FileOutputStream(props.getProperty("log.path"));
			fos.write("open file".getBytes());
			IWorkbenchPage p = window.getActivePage();
			if (p != null) {
				IEditorPart e = p.getActiveEditor();
				if (e != null) {
					IEditorInput i = e.getEditorInput();
					if (i instanceof IFileEditorInput) {
						fos.write(((IFileEditorInput) i).getFile().getLocation().toOSString().getBytes());
					}
				}
			}
			fos.write("\n".getBytes());
			for (IWorkbenchPage page : window.getPages()) {
				for (IEditorReference editor : page.getEditorReferences()) {
					IEditorInput input = editor.getEditorInput();
					if (input instanceof IFileEditorInput) {
						fos.write(((IFileEditorInput) input).getFile().getLocation().toOSString().getBytes());
					}
				}
			}
			fos.flush();
			fos.close();
		} catch (PartInitException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	private final Module doAnalysis(IFile file, String code) {
		TTCN3Analyzer ttcn3Analyzer = new TTCN3Analyzer();

		if (file != null) {
			logger.severe("Calling TTCN3 parser with " + file.getName() + " and " + null + "\n");
			ttcn3Analyzer.parse(file, null);
		} else if (code != null) {
			logger.severe("Calling TTCN3 parser with null and " + code + "\n");
			ttcn3Analyzer.parse(null, code);
		} else
			return null;

		Module module = ttcn3Analyzer.getModule();

		return module;

	}

	private void walkChildren(ASTVisitor visitor, Object[] children) {
		LoggerVisitor logger = new LoggerVisitor();
		for (Object child : children) {
			if (child instanceof Definitions) {

				Definitions definitions = (Definitions) child;

				moduleElementName = definitions.getFullName();

				logToConsole("Starting processing:  " + moduleElementName);
				myASTVisitor.myFunctionTestCaseVisitHandler.clearEverything();
				// myASTVisitor.templateIdValuePairs.clear();

				if (Boolean.parseBoolean(props.getProperty("ast.log.enabled"))) {
					definitions.accept(logger);
				}
				definitions.accept(visitor);
				logToConsole("Finished processing:  " + moduleElementName);
			}
		}
	}

	private static MessageConsole findConsole(String name) {
		ConsolePlugin plugin = ConsolePlugin.getDefault();
		IConsoleManager conMan = plugin.getConsoleManager();
		IConsole[] existing = conMan.getConsoles();
		for (int i = 0; i < existing.length; i++)
			if (name.equals(existing[i].getName()))
				return (MessageConsole) existing[i];
		// no console found, so create a new one
		MessageConsole myConsole = new MessageConsole(name, null);
		conMan.addConsoles(new IConsole[] { myConsole });
		return myConsole;
	}

	public static void logToConsole(String msg) {
		MessageConsole myConsole = findConsole("myLogger");
		MessageConsoleStream consoleLogger = myConsole.newMessageStream();
		consoleLogger.println(msg);
	}

}
/******************************************************************************
 * Copyright (c) 2000-2017 Ericsson Telecom AB
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   
 *   Keremi, Andras
 *   Eros, Levente
 *   Kovacs, Gabor
 *   Meszaros, Mate Robert
 *
 ******************************************************************************/

package org.eclipse.titan.codegenerator;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import java.util.logging.FileHandler;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IFolder;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.jdt.core.IClasspathEntry;
import org.eclipse.jdt.core.IJavaProject;
import org.eclipse.jdt.core.IPackageFragmentRoot;
import org.eclipse.jdt.core.JavaCore;
import org.eclipse.jdt.launching.IVMInstall;
import org.eclipse.jdt.launching.JavaRuntime;
import org.eclipse.jdt.launching.LibraryLocation;
import org.eclipse.jface.action.IAction;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.titan.codegenerator.experimental.LoggerVisitor;
import org.eclipse.titan.designer.AST.ASTVisitor;
import org.eclipse.titan.designer.AST.Module;
import org.eclipse.titan.designer.AST.TTCN3.definitions.Definitions;
import org.eclipse.titan.designer.AST.TTCN3.definitions.TTCN3Module;
import org.eclipse.titan.designer.parsers.GlobalParser;
import org.eclipse.titan.designer.parsers.ProjectSourceParser;
import org.eclipse.titan.designer.parsers.ttcn3parser.TTCN3Analyzer;
import org.eclipse.ui.IEditorInput;
import org.eclipse.ui.IEditorPart;
import org.eclipse.ui.IEditorReference;
import org.eclipse.ui.IFileEditorInput;
import org.eclipse.ui.IWorkbenchPage;
import org.eclipse.ui.IWorkbenchWindow;
import org.eclipse.ui.IWorkbenchWindowActionDelegate;
import org.eclipse.ui.PartInitException;
import org.eclipse.core.resources.IProjectDescription;
import org.eclipse.ui.console.ConsolePlugin;
import org.eclipse.ui.console.IConsole;
import org.eclipse.ui.console.IConsoleManager;
import org.eclipse.ui.console.MessageConsole;
import org.eclipse.ui.console.MessageConsoleStream;

public final class AstWalkerJava implements IWorkbenchWindowActionDelegate {

	private static IWorkbenchWindow window;

	private static Logger logger;

	private static IProject selectedProject;
	public static Properties props;
	private static List<String> fileNames;
	private static List<IFile> files;

	private static TTCN3Module currentTTCN3module;

	public static String moduleElementName = "";

	public static boolean areCommentsAllowed = true;
	public static List<String> componentList = new ArrayList<String>();
	public static List<String> testCaseList = new ArrayList<String>();
	public static List<String> testCaseRunsOnList = new ArrayList<String>();
	public static List<String> functionList = new ArrayList<String>();
	public static List<String> functionRunsOnList = new ArrayList<String>();

	static {
		try {
			boolean append = true;
			props = new Properties();
			props.load(AstWalkerJava.class.getResourceAsStream("walker.properties"));

			FileHandler fh = new FileHandler(props.getProperty("log.path"), append);

			fh.setFormatter(new SimpleFormatter());
			logger = Logger.getLogger(AstWalkerJava.class.getName());
			logger.addHandler(fh);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public static void main(String args[]) {
		new AstWalkerJava().run(null);
	}

	public void run(IAction action) {

		/**/
		IProject[] projects = ResourcesPlugin.getWorkspace().getRoot().getProjects();
		for(IProject p:projects){
			if(p.getName().equals("org.eclipse.titan.codegenerator.output"))
				try{
					p.delete(true, true, null);
				}catch(Exception e){e.printStackTrace();}
		}
		IProject project = ResourcesPlugin.getWorkspace().getRoot().getProject("org.eclipse.titan.codegenerator.output");
		try{
			project.create(null);
			project.open(null);
			IProjectDescription description = project.getDescription();
			description.setNatureIds(new String[] { JavaCore.NATURE_ID });
			project.setDescription(description, null);
			IJavaProject javaProject = JavaCore.create(project);
			IFolder binFolder = project.getFolder("bin");
			binFolder.create(false, true, null);
			javaProject.setOutputLocation(binFolder.getFullPath(), null);
			List<IClasspathEntry> entries = new ArrayList<IClasspathEntry>();
			IVMInstall vmInstall = JavaRuntime.getDefaultVMInstall();
			LibraryLocation[] locations = JavaRuntime.getLibraryLocations(vmInstall);
			for (LibraryLocation element : locations) {
			 entries.add(JavaCore.newLibraryEntry(element.getSystemLibraryPath(), null, null));
			}
			javaProject.setRawClasspath(entries.toArray(new IClasspathEntry[entries.size()]), null);
			IFolder sourceFolder = project.getFolder("src");
			sourceFolder.create(false, true, null);
			IPackageFragmentRoot root = javaProject.getPackageFragmentRoot(sourceFolder);
			IClasspathEntry[] oldEntries = javaProject.getRawClasspath();
			IClasspathEntry[] newEntries = new IClasspathEntry[oldEntries.length + 1];
			System.arraycopy(oldEntries, 0, newEntries, 0, oldEntries.length);
			newEntries[oldEntries.length] = JavaCore.newSourceEntry(root.getPath());
			javaProject.setRawClasspath(newEntries, null);
			javaProject.getPackageFragmentRoot(sourceFolder).createPackageFragment("org.eclipse.titan.codegenerator.javagen", false, null);
			javaProject.getPackageFragmentRoot(sourceFolder).createPackageFragment("org.eclipse.titan.codegenerator.TTCN3JavaAPI", false, null);
		}catch(Exception e){e.printStackTrace();}
		
		String destpath = new String("");
		String wspath = ResourcesPlugin.getWorkspace().getRoot().getLocation().toString().replaceAll("/", "\\\\");
		destpath += wspath;
		destpath += "\\org.eclipse.titan.codegenerator.output\\src\\org\\eclipse\\titan\\codegenerator\\javagen\\";
		props.setProperty("javafile.path", destpath);
		/**/
		
		AstWalkerJava.files.clear();
		AstWalkerJava.fileNames.clear();
		AstWalkerJava.componentList.clear();
		AstWalkerJava.testCaseList.clear();
		AstWalkerJava.testCaseRunsOnList.clear();
		AstWalkerJava.functionList.clear();
		AstWalkerJava.functionRunsOnList.clear();

		AstWalkerJava.initOutputFolder();
		AstWalkerJava.getActiveProject();

		/*
		 * // init console logger IConsole myConsole = findConsole("myLogger");
		 * IWorkbenchPage page = window.getActivePage(); String id =
		 * IConsoleConstants.ID_CONSOLE_VIEW; IConsoleView view; try { view =
		 * (IConsoleView) page.showView(id); view.display(myConsole); } catch
		 * (PartInitException e) { // TODO Auto-generated catch block
		 * e.printStackTrace(); }
		 */

		// initialize common files

		myASTVisitor.currentFileName = "TTCN_functions";

		myASTVisitor.visualizeNodeToJava(myASTVisitor.importListStrings);
		myASTVisitor.visualizeNodeToJava("class TTCN_functions{\r\n}\r\n");

		Def_Template_Visit_Handler.isTemplate = false;

		final ProjectSourceParser sourceParser = GlobalParser.getProjectSourceParser(selectedProject);
		sourceParser.analyzeAll();

		logToConsole("Version built on 2016.10.24");
		logToConsole("Starting to generate files into: " + props.getProperty("javafile.path"));

		myASTVisitor visitor = new myASTVisitor();
		for (Module module : sourceParser.getModules()) {
			// start AST processing
			walkChildren(visitor, module.getOutlineChildren());
		}
		visitor.finish();

		logToConsole("Files generated into: " + props.getProperty("javafile.path"));

		// write additional classes
		Additional_Class_Writer additional_class = new Additional_Class_Writer();
		myASTVisitor.currentFileName = "HC";

		myASTVisitor.visualizeNodeToJava(myASTVisitor.importListStrings);
		myASTVisitor.visualizeNodeToJava(additional_class.writeHCClass());

		myASTVisitor.currentFileName = "HCType";
		myASTVisitor.visualizeNodeToJava(myASTVisitor.importListStrings);
		myASTVisitor.visualizeNodeToJava(additional_class.writeHCTypeClass());

		// clear lists

		logger.severe("analysis complete");

		/**/
		File fromdir = new File(wspath + "\\org.eclipse.titan.codegenerator\\src\\org\\eclipse\\titan\\codegenerator\\TTCN3JavaAPI\\");
		String toapidir = wspath + "\\org.eclipse.titan.codegenerator.output\\src\\org\\eclipse\\titan\\codegenerator\\TTCN3JavaAPI\\";
		File[] fromfiles = fromdir.listFiles();
		for(File f: fromfiles){
			try {
				Files.copy(Paths.get(f.getAbsolutePath()), Paths.get(toapidir+f.getName()), StandardCopyOption.REPLACE_EXISTING);
			}catch(Exception e){e.printStackTrace();}
		}
		String tppath = wspath + "\\" + selectedProject.getFullPath().toString().split("/")[1] + "\\src\\";
		File tp_cfg_dir = new File(tppath);
		String togendir = wspath + "\\org.eclipse.titan.codegenerator.output\\src\\org\\eclipse\\titan\\codegenerator\\javagen\\";
		File[] from_testports_cfg = tp_cfg_dir.listFiles();
		for(File f: from_testports_cfg){
			if(f.getName().endsWith(".java")){
				try{
					Files.copy(Paths.get(f.getAbsolutePath()), Paths.get(togendir+f.getName()), StandardCopyOption.REPLACE_EXISTING);
				}catch(Exception e){e.printStackTrace();}
			}
			if(f.getName().endsWith(".cfg")){
				try{
					Files.copy(Paths.get(f.getAbsolutePath()), Paths.get(toapidir+"cfg.cfg"), StandardCopyOption.REPLACE_EXISTING);
				}catch(Exception e){e.printStackTrace();}
			}
		}
		try{
			ResourcesPlugin.getWorkspace().getRoot().refreshLocal(IResource.DEPTH_INFINITE, new NullProgressMonitor());
		}catch(Exception e){e.printStackTrace();}
		/**/
		
	}

	public void selectionChanged(IAction action, ISelection selection) {
		// TODO Auto-generated method stub

	}

	private static void getActiveProject() {
		IWorkbenchPage p = window.getActivePage();
		IFile openFile = null;
		if (p != null) {
			IEditorPart e = p.getActiveEditor();
			if (e != null) {
				IEditorInput i = e.getEditorInput();
				if (i instanceof IFileEditorInput) {
					openFile = ((IFileEditorInput) i).getFile();
					if (openFile.getName().endsWith("ttcn3") || openFile.getName().endsWith("ttcn")) {
						AstWalkerJava.selectedProject = openFile.getProject();
					}
					logger.severe(openFile.getLocation().toOSString() + "\n");
				}
			}
		}

	}

	public static void initOutputFolder() {
		Path outputPath = Paths.get(props.getProperty("javafile.path"));
		if (Files.exists(outputPath)) {
			System.out.println("");
			File folder = new File(outputPath.toUri());
			File[] listOfFiles = folder.listFiles();
			for (int i = 0; i < listOfFiles.length; i++) {
				if (listOfFiles[i].getPath().toString().endsWith("java")) {
				} else {
					listOfFiles[i] = null;
				}
			}
			for (int i = 0; i < listOfFiles.length; i++) {
				if (listOfFiles[i] != null) {
					listOfFiles[i].delete();
				}
			}

		} else {
			(new File(props.getProperty("javafile.path"))).mkdirs();

		}
	}

	public void dispose() {
		// TODO Auto-generated method stub

	}

	public void init(IWorkbenchWindow window) {
		fileNames = new ArrayList<String>();
		files = new ArrayList<IFile>();
		AstWalkerJava.window = window;
		try {
			FileOutputStream fos = new FileOutputStream(props.getProperty("log.path"));
			fos.write("open file".getBytes());
			IWorkbenchPage p = window.getActivePage();
			if (p != null) {
				IEditorPart e = p.getActiveEditor();
				if (e != null) {
					IEditorInput i = e.getEditorInput();
					if (i instanceof IFileEditorInput) {
						fos.write(((IFileEditorInput) i).getFile().getLocation().toOSString().getBytes());
					}
				}
			}
			fos.write("\n".getBytes());
			for (IWorkbenchPage page : window.getPages()) {
				for (IEditorReference editor : page.getEditorReferences()) {
					IEditorInput input = editor.getEditorInput();
					if (input instanceof IFileEditorInput) {
						fos.write(((IFileEditorInput) input).getFile().getLocation().toOSString().getBytes());
					}
				}
			}
			fos.flush();
			fos.close();
		} catch (PartInitException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	private final Module doAnalysis(IFile file, String code) {
		TTCN3Analyzer ttcn3Analyzer = new TTCN3Analyzer();

		if (file != null) {
			logger.severe("Calling TTCN3 parser with " + file.getName() + " and " + null + "\n");
			ttcn3Analyzer.parse(file, null);
		} else if (code != null) {
			logger.severe("Calling TTCN3 parser with null and " + code + "\n");
			ttcn3Analyzer.parse(null, code);
		} else
			return null;

		Module module = ttcn3Analyzer.getModule();

		return module;

	}

	private void walkChildren(ASTVisitor visitor, Object[] children) {
		LoggerVisitor logger = new LoggerVisitor();
		for (Object child : children) {
			if (child instanceof Definitions) {

				Definitions definitions = (Definitions) child;

				moduleElementName = definitions.getFullName();

				logToConsole("Starting processing:  " + moduleElementName);
				myASTVisitor.myFunctionTestCaseVisitHandler.clearEverything();
				// myASTVisitor.templateIdValuePairs.clear();

				if (Boolean.parseBoolean(props.getProperty("ast.log.enabled"))) {
					definitions.accept(logger);
				}
				definitions.accept(visitor);
				logToConsole("Finished processing:  " + moduleElementName);
			}
		}
	}

	private static MessageConsole findConsole(String name) {
		ConsolePlugin plugin = ConsolePlugin.getDefault();
		IConsoleManager conMan = plugin.getConsoleManager();
		IConsole[] existing = conMan.getConsoles();
		for (int i = 0; i < existing.length; i++)
			if (name.equals(existing[i].getName()))
				return (MessageConsole) existing[i];
		// no console found, so create a new one
		MessageConsole myConsole = new MessageConsole(name, null);
		conMan.addConsoles(new IConsole[] { myConsole });
		return myConsole;
	}

	public static void logToConsole(String msg) {
		MessageConsole myConsole = findConsole("myLogger");
		MessageConsoleStream consoleLogger = myConsole.newMessageStream();
		consoleLogger.println(msg);
	}

}
package org.eclipse.titan.codegenerator;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import java.util.logging.FileHandler;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IProject;
import org.eclipse.jface.action.IAction;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.titan.codegenerator.experimental.LoggerVisitor;
import org.eclipse.titan.designer.AST.ASTVisitor;
import org.eclipse.titan.designer.AST.Module;
import org.eclipse.titan.designer.AST.TTCN3.definitions.Definitions;
import org.eclipse.titan.designer.AST.TTCN3.definitions.TTCN3Module;
import org.eclipse.titan.designer.parsers.ttcn3parser.TTCN3Analyzer;
import org.eclipse.ui.IEditorInput;
import org.eclipse.ui.IEditorPart;
import org.eclipse.ui.IEditorReference;
import org.eclipse.ui.IFileEditorInput;
import org.eclipse.ui.IWorkbenchPage;
import org.eclipse.ui.IWorkbenchWindow;
import org.eclipse.ui.IWorkbenchWindowActionDelegate;
import org.eclipse.ui.PartInitException;
import org.eclipse.ui.console.ConsolePlugin;
import org.eclipse.ui.console.IConsole;
import org.eclipse.ui.console.IConsoleManager;
import org.eclipse.ui.console.MessageConsole;
import org.eclipse.ui.console.MessageConsoleStream;

public final class AstWalkerRunnerJava implements IWorkbenchWindowActionDelegate {

	private static IWorkbenchWindow window;

	private static Logger logger;

	private static IProject selectedProject;
	public static Properties props;
	private static List<String> fileNames;
	private static List<IFile> files;

	private static TTCN3Module currentTTCN3module;

	public static String moduleElementName = "";

	public static boolean areCommentsAllowed = true;
	public static List<String> componentList = new ArrayList<String>();
	public static List<String> testCaseList = new ArrayList<String>();
	public static List<String> testCaseRunsOnList = new ArrayList<String>();
	public static List<String> functionList = new ArrayList<String>();
	public static List<String> functionRunsOnList = new ArrayList<String>();

	static {
		try {
			boolean append = true;
			props = new Properties();
			props.load(AstWalkerRunnerJava.class.getResourceAsStream("walker.properties"));

			FileHandler fh = new FileHandler(props.getProperty("log.path"), append);

			fh.setFormatter(new SimpleFormatter());
			logger = Logger.getLogger(AstWalkerRunnerJava.class.getName());
			logger.addHandler(fh);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public static void main(String args[]) {
		new AstWalkerRunnerJava().run(null);
	}

	public void run(IAction action) {

		(new AstWalkerJava()).run(action);
		(new AstRunnerJava()).run(action);

	}

	public void selectionChanged(IAction action, ISelection selection) {
		// TODO Auto-generated method stub

	}

	private static void getActiveProject() {
		IWorkbenchPage p = window.getActivePage();
		IFile openFile = null;
		if (p != null) {
			IEditorPart e = p.getActiveEditor();
			if (e != null) {
				IEditorInput i = e.getEditorInput();
				if (i instanceof IFileEditorInput) {
					openFile = ((IFileEditorInput) i).getFile();
					if (openFile.getName().endsWith("ttcn3") || openFile.getName().endsWith("ttcn")) {
						AstWalkerRunnerJava.selectedProject = openFile.getProject();
					}
					logger.severe(openFile.getLocation().toOSString() + "\n");
				}
			}
		}

	}

	public static void initOutputFolder() {
		Path outputPath = Paths.get(props.getProperty("javafile.path"));
		if (Files.exists(outputPath)) {
			System.out.println("");
			File folder = new File(outputPath.toUri());
			File[] listOfFiles = folder.listFiles();
			for (int i = 0; i < listOfFiles.length; i++) {
				if (listOfFiles[i].getPath().toString().endsWith("java")) {
				} else {
					listOfFiles[i] = null;
				}
			}
			for (int i = 0; i < listOfFiles.length; i++) {
				if (listOfFiles[i] != null) {
					listOfFiles[i].delete();
				}
			}

		} else {
			(new File(props.getProperty("javafile.path"))).mkdirs();

		}
	}

	public void dispose() {
		// TODO Auto-generated method stub

	}

	public void init(IWorkbenchWindow window) {
		fileNames = new ArrayList<String>();
		files = new ArrayList<IFile>();
		AstWalkerRunnerJava.window = window;
		try {
			FileOutputStream fos = new FileOutputStream(props.getProperty("log.path"));
			fos.write("open file".getBytes());
			IWorkbenchPage p = window.getActivePage();
			if (p != null) {
				IEditorPart e = p.getActiveEditor();
				if (e != null) {
					IEditorInput i = e.getEditorInput();
					if (i instanceof IFileEditorInput) {
						fos.write(((IFileEditorInput) i).getFile().getLocation().toOSString().getBytes());
					}
				}
			}
			fos.write("\n".getBytes());
			for (IWorkbenchPage page : window.getPages()) {
				for (IEditorReference editor : page.getEditorReferences()) {
					IEditorInput input = editor.getEditorInput();
					if (input instanceof IFileEditorInput) {
						fos.write(((IFileEditorInput) input).getFile().getLocation().toOSString().getBytes());
					}
				}
			}
			fos.flush();
			fos.close();
		} catch (PartInitException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	private final Module doAnalysis(IFile file, String code) {
		TTCN3Analyzer ttcn3Analyzer = new TTCN3Analyzer();

		if (file != null) {
			logger.severe("Calling TTCN3 parser with " + file.getName() + " and " + null + "\n");
			ttcn3Analyzer.parse(file, null);
		} else if (code != null) {
			logger.severe("Calling TTCN3 parser with null and " + code + "\n");
			ttcn3Analyzer.parse(null, code);
		} else
			return null;

		Module module = ttcn3Analyzer.getModule();

		return module;

	}

	private void walkChildren(ASTVisitor visitor, Object[] children) {
		LoggerVisitor logger = new LoggerVisitor();
		for (Object child : children) {
			if (child instanceof Definitions) {

				Definitions definitions = (Definitions) child;

				moduleElementName = definitions.getFullName();

				logToConsole("Starting processing:  " + moduleElementName);
				myASTVisitor.myFunctionTestCaseVisitHandler.clearEverything();
				// myASTVisitor.templateIdValuePairs.clear();

				if (Boolean.parseBoolean(props.getProperty("ast.log.enabled"))) {
					definitions.accept(logger);
				}
				definitions.accept(visitor);
				logToConsole("Finished processing:  " + moduleElementName);
			}
		}
	}

	private static MessageConsole findConsole(String name) {
		ConsolePlugin plugin = ConsolePlugin.getDefault();
		IConsoleManager conMan = plugin.getConsoleManager();
		IConsole[] existing = conMan.getConsoles();
		for (int i = 0; i < existing.length; i++)
			if (name.equals(existing[i].getName()))
				return (MessageConsole) existing[i];
		// no console found, so create a new one
		MessageConsole myConsole = new MessageConsole(name, null);
		conMan.addConsoles(new IConsole[] { myConsole });
		return myConsole;
	}

	public static void logToConsole(String msg) {
		MessageConsole myConsole = findConsole("myLogger");
		MessageConsoleStream consoleLogger = myConsole.newMessageStream();
		consoleLogger.println(msg);
	}

}
/******************************************************************************
 * Copyright (c) 2000-2017 Ericsson Telecom AB
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   
 *   Keremi, Andras
 *   Eros, Levente
 *   Kovacs, Gabor
 *
 ******************************************************************************/

package org.eclipse.titan.codegenerator;

import java.util.ArrayList;
import java.util.List;

import org.eclipse.titan.designer.AST.TTCN3.statements.AltGuard;
import org.eclipse.titan.designer.AST.TTCN3.statements.AltGuards;
import org.eclipse.titan.designer.AST.TTCN3.statements.Alt_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.Assignment_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.Operation_Altguard;
import org.eclipse.titan.designer.AST.TTCN3.statements.Receive_Port_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.Repeat_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.Send_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.Setverdict_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.StatementBlock;
import org.eclipse.titan.designer.AST.TTCN3.statements.Timeout_Statement;
import org.eclipse.titan.designer.AST.TTCN3.values.Verdict_Value;

public class Def_AltStatement_Writer {
	private Alt_Statement altStatement;
	private StringBuilder altString = new StringBuilder("");

	private String currentTimerName = null;
	private String nodeName = null;

	private int altReceiveCounter = -1;
	private int timeOutCounter = -1;

	private boolean isFunction = false;
	private boolean isTestCase = false;

	public List<String> altGuardConditions = new ArrayList<String>();
	public List<String> altGuardPortReference = new ArrayList<String>();
	public List<String> altGuardReceiveValue = new ArrayList<String>();
	public List<String> altGuardReceiveType = new ArrayList<String>();
	public List<String> altGuardTimeout = new ArrayList<String>();

	private boolean isThereAStartedTimer = false;
	public List<String> altGuardReceiveAnyValValue = new ArrayList<String>();

	Def_Testcase_Writer testcaseParent;
	Def_Function_Writer functionParent;

	public Def_AltStatement_Writer(Alt_Statement altStatement,
			String parentNodeName) {
		this.altStatement = altStatement;
		this.nodeName = parentNodeName;
	}

	public void writeTestCaseAltStatement(Alt_Statement altStatement) {

		AltGuards currentAltGuards = altStatement.getAltGuards();

		String[] negativeConditions = new String[currentAltGuards
				.getNofAltguards()];
		String[] positiveConditions = new String[currentAltGuards
				.getNofAltguards()];

		// initialize values
		for (int i = 0; i < currentAltGuards.getNofAltguards(); i++) {

			AltGuard currentAltGuard = currentAltGuards.getAltguardByIndex(i);
			if (currentAltGuard instanceof Operation_Altguard) {

				Statement currentStatement = ((Operation_Altguard) currentAltGuard)
						.getGuardStatement();

				if (currentStatement instanceof Receive_Port_Statement) {

					altReceiveCounter++;
					if (altGuardConditions.get(i) != null) {// alt guard present

						// alt guard present && any port receive
						if (altGuardPortReference.get(altReceiveCounter)
								.equals("any port")) {
							positiveConditions[i] = altGuardConditions.get(altReceiveCounter)
									+ ".getValue()" + "&&("
									+ "anyPortReceive(true))";

							negativeConditions[i] = altGuardConditions.get(altReceiveCounter)
									+ ".getValue()" + "&&("
									+ "anyPortReceive(false))";

						} else {// alt guard present && normal port receive
							positiveConditions[i] = altGuardConditions.get(altReceiveCounter)
									+ ".getValue()"
									+ "&&("
									+ altGuardPortReference
											.get(altReceiveCounter)
									+ ".receive("
									+ altGuardReceiveValue
											.get(altReceiveCounter)
									+ ",true)!=null)";

							negativeConditions[i] = altGuardConditions.get(altReceiveCounter)
									+ ".getValue()"
									+ "&&("
									+ altGuardPortReference
											.get(altReceiveCounter)
									+ ".receive("
									+ altGuardReceiveValue
											.get(altReceiveCounter)
									+ ",false)!=null)";

							if (altGuardReceiveValue.get(altReceiveCounter)
									.startsWith("Templates")) {
								altGuardReceiveType.set(altReceiveCounter, "Templates");
							}
						}

					} else {// no alt guard

						// no alt guard && any port recieve
						if (altGuardPortReference.get(altReceiveCounter)
								.equals("any port")) {
							positiveConditions[i] = "anyPortReceive(true)";
							negativeConditions[i] = "anyPortReceive(false)";
						} else {
							// no alt guard && no receive parameter
							if (altGuardReceiveType.get(altReceiveCounter).equals("noparam")){
								positiveConditions[i] =altGuardPortReference.get(altReceiveCounter) +".receive(true)!=null";
								negativeConditions[i] =altGuardPortReference.get(altReceiveCounter) +".receive(false)!=null";
							}else if (altGuardReceiveType.get(altReceiveCounter).equals(// no alt guard && typed port recieve
									"_TYPED_PARAM_")) {
								negativeConditions[i] = altGuardPortReference
										.get(altReceiveCounter)
										+ ".receive_"
										+ altGuardReceiveValue
												.get(altReceiveCounter)
										+ "(false)!=null";

								if (altGuardReceiveAnyValValue.get(altReceiveCounter) != null) {
									positiveConditions[i] = "("
											+ altGuardReceiveAnyValValue.get(altReceiveCounter)
											+ "="
											+ altGuardPortReference
													.get(altReceiveCounter)
											+ ".receive_"
											+ altGuardReceiveValue
													.get(altReceiveCounter)
											+ "(true))!=null";

								} else {

								}

							} else { // no alt guard && normal port recieve
								positiveConditions[i] = altGuardPortReference
										.get(altReceiveCounter)
										+ ".receive("
										+ altGuardReceiveValue
												.get(altReceiveCounter)
										+ ",true)!=null";

								negativeConditions[i] = altGuardPortReference
										.get(altReceiveCounter)
										+ ".receive("
										+ altGuardReceiveValue
												.get(altReceiveCounter)
										+ ",false)!=null";
							}
							
							if (altGuardReceiveValue.get(altReceiveCounter)!=null && altGuardReceiveValue.get(altReceiveCounter)
									.startsWith("Templates")) {
								altGuardReceiveType.set(altReceiveCounter, "Templates");
							}
						}
					}
				}

				if (currentStatement instanceof Timeout_Statement) {
					timeOutCounter++;
					if (altGuardConditions.get(i) != null) {
						positiveConditions[i] = altGuardConditions.get(i)
								+ "&&(" + altGuardTimeout.get(timeOutCounter)
								+ ".timeout()";
						negativeConditions[i] = altGuardConditions.get(i)
								+ "&&(!" + altGuardTimeout.get(i)
								+ ".timeout()";

					} else {
						positiveConditions[i] = altGuardTimeout
								.get(timeOutCounter) + ".timeout()";
						negativeConditions[i] = "!"
								+ altGuardTimeout.get(timeOutCounter)
								+ ".timeout()";
					}

				}

			}
		}

		// write
		altString.append("rownum=" + altStatement.getLocation().getLine()
				+ ";\r\n");
		altString.append("for(;;){" + "\r\n");

		altString.append("if(!(");
		for (int j = 0; j < negativeConditions.length; j++) {
			altString.append(negativeConditions[j]);
			if (j + 1 < negativeConditions.length) {
				altString.append("||");
			}
		}

		altString.append(")){" + "\r\n");

		// timer
		if (isThereAStartedTimer) {
			altString.append("long timeout = -1;" + "\r\n");
			altString.append("long newtimeout;" + "\r\n");

			altString
					.append("if("
							+ currentTimerName
							+ ".running)if((newtimeout=(long)("
							+ currentTimerName
							+ ".read().value*1000.0))<timeout || timeout == -1) timeout=newtimeout;"
							+ "\r\n");
			altString
					.append("if(timeout>0) try{queue.poll(timeout,TimeUnit.MILLISECONDS);}catch(InterruptedException e){} "
							+ "\r\n");

		} else {

			altString
					.append("try{queue.take();}catch(InterruptedException e){}"
							+ "\r\n");

		}
		// endoftimer

		altString.append("}" + "\r\n");
		altString.append("this.lock();" + "\r\n");
		// ifwriter

		altReceiveCounter = -1;
		boolean isFirstIf = true;
		for (int i = 0; i < currentAltGuards.getNofAltguards(); i++) {

			AltGuard currentAltGuard = currentAltGuards.getAltguardByIndex(i);
			if (currentAltGuard instanceof Operation_Altguard) {

				Statement currentStatement = ((Operation_Altguard) currentAltGuard)
						.getGuardStatement();
				StatementBlock currentStatementBlock = ((Operation_Altguard) currentAltGuard)
						.getStatementBlock();

				if (isFirstIf) {
					altString.append("if(" + positiveConditions[i] + "){\r\n");
					isFirstIf = false;
				} else {
					altString.append("else if(" + positiveConditions[i]
							+ "){\r\n");
				}

				if (currentStatement instanceof Receive_Port_Statement) {
					altReceiveCounter++;

					altString.append("rownum="
							+ currentStatement.getLocation().getLine()
							+ ";\r\n");
					
					if (altGuardReceiveType.get(altReceiveCounter).equals("noparam")){
						altString
						.append("	TTCN3Logger.writeLog(compid, \"PORTEVENT\", sourcefilename, rownum, \"function\", \""
								+ nodeName
								+ "\", \"RECEIVE event on port "
								+ altGuardPortReference
										.get(altReceiveCounter)
								+ "\", true);" + "\r\n");
					}else if (altGuardReceiveType.get(altReceiveCounter).equals(
							"Templates")) {
						String methodName = altGuardReceiveValue
								.get(altReceiveCounter);
						if (methodName.endsWith("()")
								&& methodName.startsWith("Templates.")) {

							methodName = (String) methodName.subSequence(10,
									methodName.length() - 2);
						}

						altString
								.append("	TTCN3Logger.writeLog(compid, \"PORTEVENT\", sourcefilename, rownum, \"function\", \""
										+ nodeName
										+ "\", \"RECEIVE event on port "
										+ altGuardPortReference
												.get(altReceiveCounter)
										+ ":\\n "
										+ methodName
										+ ":=\" + "
										+ altGuardReceiveValue
												.get(altReceiveCounter)
										+ ".toString(), true);" + "\r\n");
					} else if (altGuardReceiveType.get(altReceiveCounter)
							.equals("any port")) {
						altString
								.append("	TTCN3Logger.writeLog(compid, \"PORTEVENT\", sourcefilename, rownum, \"function\", \""
										+ nodeName
										+ "\", \"RECEIVE event on port any port\", true);"
										+ "\r\n");
					} else if (altGuardReceiveType.get(altReceiveCounter)
							.equals("_TYPED_PARAM_")) {
						altString
								.append("	TTCN3Logger.writeLog(compid, \"PORTEVENT\", sourcefilename, rownum, \"function\", \""
										+ nodeName
										+ "\", \"RECEIVE event on port "
										+ altGuardPortReference
												.get(altReceiveCounter)
										+ ": type "
										+ altGuardReceiveValue
												.get(altReceiveCounter)
										+ "\", true);" + "\r\n");

					} else {
						if(altGuardReceiveValue
								.get(altReceiveCounter)!=null){
						altString
								.append("	TTCN3Logger.writeLog(compid, \"PORTEVENT\", sourcefilename, rownum, \"function\", \""
										+ nodeName
										+ "\", \"RECEIVE event on port "
										+ altGuardPortReference
												.get(altReceiveCounter)
										+ ":\" + "
										+ altGuardReceiveValue
												.get(altReceiveCounter)
										+ ".toString(), true);" + "\r\n");
						}
					}
				} else if (currentStatement instanceof Timeout_Statement) {
					altString
							.append("rownum="
									+ currentStatement.getLocation().getLine()
									+ ";\r\n"
									+ "TTCN3Logger.writeLog(compid, \"TIMEROP\", sourcefilename, rownum, \"function\", \""
									+ nodeName + "\", \"Timeout on timer "
									+ currentTimerName + ".\", false);"
									+ "\r\n");

				}

				boolean isThereARepeatStatement = false;
				for (int j = 0; j < currentStatementBlock.getSize(); j++) {
					Statement currentStatementBlockStatement = currentStatementBlock
							.getStatementByIndex(j);

					if (currentStatementBlockStatement instanceof Setverdict_Statement) {
						Setverdict_Statement setVerdictStatement = (Setverdict_Statement) currentStatementBlockStatement;
						String verdict = "";

						if (setVerdictStatement.getVerdictValue() instanceof Verdict_Value) {
							Verdict_Value verdictValue = (Verdict_Value) setVerdictStatement
									.getVerdictValue();
							if (verdictValue.getValue().toString()
									.equals("PASS")) {
								verdict = "pass";
							} else if (verdictValue.getValue().toString()
									.equals("INCONC")) {
								verdict = "inconc";
							} else {
								verdict = "fail";
							}
						}
						altString.append("rownum="
								+ setVerdictStatement.getLocation().getLine()
								+ ";\r\n");
						altString
								.append("TTCN3Logger.writeLog(compid, \"VERDICTOP\", sourcefilename, rownum, \"function\", \""
										+ nodeName
										+ "\", \"setverdict("
										+ verdict
										+ "): \" + getVerdict() + \" -> "
										+ verdict + "\", true);" + "\r\n");
						altString.append("setVerdict(\"" + verdict + "\");"
								+ "\r\n");

					}

					if (currentStatementBlockStatement instanceof Assignment_Statement) {

						if (isFunction) {
							functionParent.assignCounter++;

							altString
									.append(functionParent
											.writeAssignmentStatement((Assignment_Statement) currentStatementBlockStatement));

							String test = "";
							test.toString();

						} else if (isTestCase) {
							testcaseParent.assignCounter++;
							altString
									.append(testcaseParent
											.writeAssignmentStatement((Assignment_Statement) currentStatementBlockStatement));

						}

					}

					if (currentStatementBlockStatement instanceof Send_Statement) {

						if (isFunction) {
							functionParent.sendCounter++;

							altString
									.append(functionParent
											.writeSendStatement((Send_Statement) currentStatementBlockStatement));

						} else if (isTestCase) {
							testcaseParent.sendCounter++;
							altString
									.append(testcaseParent
											.writeSendStatement((Send_Statement) currentStatementBlockStatement));

						}
					}

					if (currentStatementBlockStatement instanceof Repeat_Statement) {
						isThereARepeatStatement = true;
					}

				}
				if (isThereARepeatStatement) {
					isThereARepeatStatement = false;
				} else {
					altString.append("break;\r\n");
				}

				altString.append("}\r\n");

			}
		}

		altString.append("this.unlock();" + "\r\n");
		altString.append("}" + "\r\n");

	}

	public void clearLists() {
		altGuardConditions.clear();
		altGuardPortReference.clear();
		altGuardReceiveValue.clear();
		altGuardReceiveType.clear();
		altGuardTimeout.clear();

		altReceiveCounter = -1;
		timeOutCounter = -1;

	}

	public String getJavaSource() {

		this.writeTestCaseAltStatement(altStatement);

		String returnString = altString.toString();
		altString.setLength(0);
		clearLists();

		return returnString;
	}


	public void setTimerInfo(boolean isThereAStartedTimer2,
			String currentTimerName2) {
		isThereAStartedTimer = isThereAStartedTimer2;
		currentTimerName = currentTimerName2;

	}


	public void setType(String string) {
		if (string.equals("Function")) {
			isFunction = true;
		} else if (string.equals("TestCase")) {
			isTestCase = true;
		}
	}

	public void setParent(Object parent) {
		if (parent instanceof Def_Function_Writer) {
			functionParent = (Def_Function_Writer) parent;
		} else if (parent instanceof Def_Testcase_Writer) {
			testcaseParent = (Def_Testcase_Writer) parent;
		}
	}

}
/******************************************************************************
 * Copyright (c) 2000-2017 Ericsson Telecom AB
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   
 *   Keremi, Andras
 *   Eros, Levente
 *   Kovacs, Gabor
 *
 ******************************************************************************/

package org.eclipse.titan.codegenerator;

import java.util.ArrayList;
import java.util.List;

import org.eclipse.titan.designer.AST.IVisitableNode;
import org.eclipse.titan.designer.AST.Identifier;
import org.eclipse.titan.designer.AST.Reference;
import org.eclipse.titan.designer.AST.TTCN3.definitions.Def_Const;
import org.eclipse.titan.designer.AST.TTCN3.types.BitString_Type;
import org.eclipse.titan.designer.AST.TTCN3.types.Boolean_Type;
import org.eclipse.titan.designer.AST.TTCN3.types.CharString_Type;
import org.eclipse.titan.designer.AST.TTCN3.types.Float_Type;
import org.eclipse.titan.designer.AST.TTCN3.types.Integer_Type;
import org.eclipse.titan.designer.AST.TTCN3.types.OctetString_Type;
import org.eclipse.titan.designer.AST.TTCN3.types.subtypes.Range_ParsedSubType;
import org.eclipse.titan.designer.AST.TTCN3.values.Bitstring_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Boolean_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Charstring_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Integer_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Octetstring_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Omit_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Real_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Undefined_LowerIdentifier_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.AddExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.DivideExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.EqualsExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.GreaterThanExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.GreaterThanOrEqualExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.LessThanExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.LessThanOrEqualExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.Log2StrExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.ModuloExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.MultiplyExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.NotExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.NotequalesExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.RemainderExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.Str2IntExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.SubstractExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.ValueofExpression;

public class Def_Const_Visit_Handler {

	public static String constNodeType = null;
	private static String lastConstName = null;

	private static boolean waitForConstValues = false;
	private static boolean constValueIsAReference = false;
	private static boolean blockTypeListing = false;
	// counts the members for each setof
	// has to be -3 because the node's name and type increases it by 2
	// should be increased to 0 only at the first constant value
	private static int constParamCounter = -3;

	private static List<String> constValues = new ArrayList<String>();
	private static List<Integer> constParamCount = new ArrayList<Integer>();
	private static List<String> expressionValue = new ArrayList<String>();

	public void visit(IVisitableNode node) {

		if (!myASTVisitor.myFunctionTestCaseVisitHandler.waitForDefStatement && (node instanceof Def_Const)) {
			myASTVisitor.currentFileName = "Constants";

			Def_Const_Writer.getInstance(((Def_Const) node));
			myASTVisitor.nodeNameNodeTypeHashMap.put(((Def_Const) node).getIdentifier().toString(), "constant");
			waitForConstValues = true;
			constParamCount.add(0);
		}

		// constants
		visitConstantNodes(node);
	}

	public void visitConstantNodes(IVisitableNode node) {

		if (waitForConstValues && (node instanceof Identifier)) {
			constParamCounter++;
			if (constParamCounter > 0) {
				constParamCount.add(0);
			}
			lastConstName = ((Identifier) node).toString();
		}

		if (waitForConstValues && (node instanceof Charstring_Value)) {
			String value = ((Charstring_Value) node).getValue();

			expressionValue.add(value);

			constValueIsAReference = false;

			if (constParamCounter == -1) {
				constParamCounter = 0;
			}
			if (constParamCounter == -2) {
				constParamCounter = 0;
			}

			constParamCount.set(constParamCounter, constParamCount.get(constParamCounter) + 1);
		}

		if (waitForConstValues && (node instanceof Integer_Value)) {

			String value = ((Integer_Value) node).toString();

			if (myASTVisitor.isNextIntegerNegative) {
				value = "-" + value;
			}

			expressionValue.add(value);

			constValueIsAReference = false;

			if (constParamCounter == -1) {
				constParamCounter = 0;
			}
			if (constParamCounter == -2) {
				constParamCounter = 0;
			}

			constParamCount.set(constParamCounter, constParamCount.get(constParamCounter) + 1);
			myASTVisitor.isNextIntegerNegative = false;

		}

		if (waitForConstValues && (node instanceof Real_Value)) {

			double value = ((Real_Value) node).getValue();
			String valueString = Double.toString(value);
			
			if (myASTVisitor.isNextIntegerNegative) {
				valueString="-" + valueString;
			}

			 expressionValue.add(valueString);

			constValueIsAReference = false;

			if (constParamCounter == -1) {
				constParamCounter = 0;
			}
			if (constParamCounter == -2) {
				constParamCounter = 0;
			}

			constParamCount.set(constParamCounter, constParamCount.get(constParamCounter) + 1);
			myASTVisitor.isNextIntegerNegative = false;

		}

		if (waitForConstValues && (node instanceof Bitstring_Value)) {

			String value = ((Bitstring_Value) node).getValue();

			expressionValue.add(value);

			constValueIsAReference = false;

			if (constParamCounter == -1) {
				constParamCounter = 0;
			}
			if (constParamCounter == -2) {
				constParamCounter = 0;
			}

			constParamCount.set(constParamCounter, constParamCount.get(constParamCounter) + 1);

		}

		if (waitForConstValues && (node instanceof Octetstring_Value)) {

			String value = ((Octetstring_Value) node).getValue();

			expressionValue.add(value);

			constValueIsAReference = false;

			if (constParamCounter == -1) {
				constParamCounter = 0;
			}
			if (constParamCounter == -2) {
				constParamCounter = 0;
			}

			constParamCount.set(constParamCounter, constParamCount.get(constParamCounter) + 1);

		}

		if (waitForConstValues && (node instanceof Boolean_Value)) {

			String value = Boolean.toString(((Boolean_Value) node).getValue());

			expressionValue.add(value);

			constValueIsAReference = false;

			if (constParamCounter == -1) {
				constParamCounter = 0;
			}
			if (constParamCounter == -2) {
				constParamCounter = 0;
			}

			constParamCount.set(constParamCounter, constParamCount.get(constParamCounter) + 1);

		}

		if (waitForConstValues && (node instanceof Omit_Value)) {

			expressionValue.add("omit");

			constValueIsAReference = false;

			if (constParamCounter == -1) {
				constParamCounter = 0;
			}

			constParamCount.set(constParamCounter, constParamCount.get(constParamCounter) + 1);

			myASTVisitor.constOmitHashes.add(lastConstName);

		}

		if (waitForConstValues && (node instanceof Undefined_LowerIdentifier_Value)) {

			String value = ((Undefined_LowerIdentifier_Value) node).getIdentifier().toString();

			expressionValue.add(value);

			constValueIsAReference = true;

			if (constParamCounter == -1) {
				constParamCounter = 0;
			}
			if (constParamCounter == -2) {
				constParamCounter = 0;
			}

			constParamCount.set(constParamCounter, constParamCount.get(constParamCounter) + 1);

		}

		if (waitForConstValues) {
			setType(node);
			visitExpressionTypeSelectors(node);
		}
		/*
		 * // AddExpression if (waitForConstValues && (node instanceof
		 * AddExpression)) { waitForConstAddFirstValue = true; }
		 * 
		 * if (waitForConstAddSecondValue && (node instanceof
		 * Undefined_LowerIdentifier_Value)) {
		 * 
		 * String valueIdentifier = ((Undefined_LowerIdentifier_Value) node)
		 * .getIdentifier().toString(); if (myASTVisitor.nodeNameNodeTypeHashMap
		 * .containsKey(valueIdentifier)) { if
		 * (myASTVisitor.nodeNameNodeTypeHashMap.get(valueIdentifier)
		 * .equals("constant")) { valueIdentifier = valueIdentifier + "()"; } }
		 * 
		 * constValueIsAReference = true;
		 * 
		 * constValues.set(constAddValueIndex,
		 * constValues.get(constAddValueIndex) + ".plus(" + valueIdentifier +
		 * ")");
		 * 
		 * waitForConstAddSecondValue = false; waitForConstValues = false; }
		 * 
		 * if (waitForConstAddFirstValue && (node instanceof
		 * Undefined_LowerIdentifier_Value)) { waitForConstAddFirstValue =
		 * false; waitForConstAddSecondValue = true;
		 * 
		 * String valueIdentifier = ((Undefined_LowerIdentifier_Value) node)
		 * .getIdentifier().toString(); if (myASTVisitor.nodeNameNodeTypeHashMap
		 * .containsKey(valueIdentifier)) { if
		 * (myASTVisitor.nodeNameNodeTypeHashMap.get(valueIdentifier)
		 * .equals("constant")) { valueIdentifier = valueIdentifier + "()"; }
		 * 
		 * }
		 * 
		 * constAddValueIndex = constValues.size();
		 * constValues.add(valueIdentifier);
		 * 
		 * if (constParamCounter == -1) { constParamCounter = 0; } if
		 * (constParamCounter == -2) { constParamCounter = 0; }
		 * 
		 * constParamCount.set(constParamCounter,
		 * constParamCount.get(constParamCounter) + 1);
		 * 
		 * }
		 */

	}

	public void setType(IVisitableNode node) {

		if ((node instanceof Reference) && !blockTypeListing) {
			constNodeType = ((Reference) node).getId().toString();
			blockTypeListing = true;
		}

		if (node instanceof Integer_Type) {
			constNodeType = "INTEGER";
		}
		
		if (node instanceof Float_Type) {
			constNodeType = "FLOAT";
		}

		if (node instanceof CharString_Type) {
			constNodeType = "CHARSTRING";
		}

		if (node instanceof BitString_Type) {
			constNodeType = "BITSTRING";
		}

		if (node instanceof OctetString_Type) {
			constNodeType = "OCTETSTRING";
		}

		if (node instanceof Boolean_Type) {
			constNodeType = "BOOLEAN";
		}
	}

	public void evaluateExpression() {
		int size = expressionValue.size() - 1;
		boolean operatorFound = false;
		boolean unaryOperatorFound = false;
		String rightHand = "";
		String leftHand = "";

		for (int i = size; i >= 0; i--) {

			if (myASTVisitor.nodeNameNodeTypeHashMap.containsKey(expressionValue.get(i))) {

				if (myASTVisitor.nodeNameNodeTypeHashMap.get(expressionValue.get(i)).equals("constant")) {
					expressionValue.set(i, "Constants." + expressionValue.get(i) + "().value");

				} else if (myASTVisitor.nodeNameNodeTypeHashMap.get(expressionValue.get(i)).equals("template")) {
					expressionValue.set(i, "Templates." + expressionValue.get(i) + "()");

				}
			}

			if (i <= size - 2) {
				leftHand = expressionValue.get(i + 1);
				rightHand = expressionValue.get(i + 2);
			}

			//
			if (expressionValue.get(i).equals("Str2IntExpression")) {
				expressionValue.set(i, "(" + expressionValue.get(i + 1) + "str2int())");
				unaryOperatorFound = true;
			} else if (expressionValue.get(i).equals("Log2StrExpression")) {
				expressionValue.set(i, "(" + expressionValue.get(i + 1) + "log2str())");
				unaryOperatorFound = true;
			} else if (expressionValue.get(i).equals("ValueofExpression")) {
				expressionValue.set(i, "(" + expressionValue.get(i + 1) + ").value");
				unaryOperatorFound = true;
			} else if (expressionValue.get(i).equals("NotExpression")) {
				expressionValue.set(i, "(" + expressionValue.get(i + 1) + ").not()");
				unaryOperatorFound = true;
			} else if (expressionValue.get(i).equals("AddExpression")) {
				expressionValue.set(i, "(" + leftHand + ").plus(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("SubstractExpression")) {
				expressionValue.set(i, "(" + leftHand + ").minus(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("MultiplyExpression")) {
				expressionValue.set(i, "(" + leftHand + ").multipleBy(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("DivideExpression")) {
				expressionValue.set(i, "(" + leftHand + ").divideBy(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("ModuloExpression")) {
				expressionValue.set(i, "(" + leftHand + ").mod(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("RemainderExpression")) {
				expressionValue.set(i, "(" + leftHand + ").rem(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("NotequalesExpression")) {
				expressionValue.set(i, "(" + leftHand + ").equalsWith(" + rightHand + ").not()");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("LessThanExpression")) {
				expressionValue.set(i, "(" + leftHand + ").isLessThan(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("LessThanOrEqualExpression")) {
				expressionValue.set(i, "(" + leftHand + ").isLessOrEqualThan(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("GreaterThanExpression")) {
				expressionValue.set(i, "(" + leftHand + ").isGreaterThan(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("GreaterThanOrEqualExpression")) {
				expressionValue.set(i, "(" + leftHand + ").isGreaterOrEqualThan(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("EqualsExpression")) {
				expressionValue.set(i, "(" + leftHand + ").equalsWith(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("Range_ParsedSubType")) {
				expressionValue.set(i, "new SubTypeInterval<INTEGER>(" + expressionValue.get(i + 1) + ","
						+ expressionValue.get(i + 2) + ")");
				operatorFound = true;
			}

			if (unaryOperatorFound) {
				unaryOperatorFound = false;
				expressionValue.remove(i + 1);
				size = expressionValue.size() - 1;
				i = size;
			} else if (operatorFound) {
				operatorFound = false;
				expressionValue.remove(i + 2);
				expressionValue.remove(i + 1);
				size = expressionValue.size() - 1;
				i = size;
			}

		}

		constValues.addAll(expressionValue);

		expressionValue.clear();
	}

	public void visitExpressionTypeSelectors(IVisitableNode node) {

		if (node instanceof AddExpression) {
			expressionValue.add("AddExpression");
		}

		if (node instanceof SubstractExpression) {
			expressionValue.add("SubstractExpression");
		}

		if (node instanceof MultiplyExpression) {
			expressionValue.add("MultiplyExpression");
		}

		if (node instanceof DivideExpression) {
			expressionValue.add("DivideExpression");
		}

		if (node instanceof ModuloExpression) {
			expressionValue.add("ModuloExpression");
		}

		if (node instanceof RemainderExpression) {
			expressionValue.add("RemainderExpression");
		}

		if (node instanceof NotequalesExpression) {
			expressionValue.add("NotequalesExpression");
		}

		if (node instanceof LessThanExpression) {
			expressionValue.add("LessThanExpression");
		}

		if (node instanceof LessThanOrEqualExpression) {
			expressionValue.add("LessThanOrEqualExpression");
		}

		if (node instanceof GreaterThanExpression) {
			expressionValue.add("GreaterThanExpression");
		}

		if (node instanceof GreaterThanOrEqualExpression) {
			expressionValue.add("GreaterThanOrEqualExpression");
		}

		if (node instanceof EqualsExpression) {
			expressionValue.add("EqualsExpression");
		}

		if (node instanceof NotExpression) {
			expressionValue.add("NotExpression");
		}

		if (node instanceof Range_ParsedSubType) {
			expressionValue.add("Range_ParsedSubType");
		}

		if (node instanceof Str2IntExpression) {
			expressionValue.add("Str2IntExpression");
		}

		if (node instanceof Log2StrExpression) {
			expressionValue.add("Log2StrExpression");
		}

		if (node instanceof ValueofExpression) {
			expressionValue.add("ValueofExpression");
		}

	}

	public void leave(IVisitableNode node) {
		if (!myASTVisitor.myFunctionTestCaseVisitHandler.waitForDefStatement && (node instanceof Def_Const)) {
			evaluateExpression();
			handleConst(node);

		}
	}

	public void handleConst(IVisitableNode node) {
		Def_Const_Writer constNode = Def_Const_Writer.getInstance(((Def_Const) node));
		constNode.clearLists();

		constNode.setConstNodeType(constNodeType);
		constNode.constValues.addAll(constValues);
		constNode.constParamCount.addAll(constParamCount);
		constNode.constValueIsAReference = constValueIsAReference;

		constValues.clear();
		constValueIsAReference = false;
		waitForConstValues = false;
		constParamCounter = -3;
		constParamCount.clear();
		blockTypeListing = false;

		myASTVisitor.deleteLastBracket(myASTVisitor.currentFileName);
		myASTVisitor.visualizeNodeToJava(constNode.getJavaSource() + "\r\n}");
		myASTVisitor.constOmitHashes.clear();
	}

}
/******************************************************************************
 * Copyright (c) 2000-2017 Ericsson Telecom AB
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   
 *   Keremi, Andras
 *   Eros, Levente
 *   Kovacs, Gabor
 *   Meszaros, Mate Robert
 *
 ******************************************************************************/

package org.eclipse.titan.codegenerator;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.titan.designer.AST.TTCN3.definitions.Def_Const;

public class Def_Const_Writer {
	private Def_Const constNode;

	private StringBuilder constString = new StringBuilder("");
	
	private String nodeName = null;

	public List<String> constValues = new ArrayList<String>();
	private String constNodeType = null;
	private int valueCounter = 0;
	public List<Integer> constParamCount = new ArrayList<Integer>();

	public boolean constValueIsAReference = false;
	private boolean isSetOf = false;
	private static Map<String, Object> constHashes = new LinkedHashMap<String, Object>();

	
	private Def_Const_Writer(Def_Const node) {
		super();
		this.constNode = node;
		nodeName = constNode.getIdentifier().toString();
	}

	public static Def_Const_Writer getInstance(Def_Const node) {
		if (!constHashes.containsKey(node.getIdentifier().toString())) {
			constHashes.put(node.getIdentifier().toString(),
					new Def_Const_Writer(node));
		}
		return (Def_Const_Writer) constHashes.get(node.getIdentifier()
				.toString());
	}



	public void setConstNodeType(String value) {
		constNodeType = value;
	}

	public void writeConstConstructor(String rootNodeType,
			String prefix) {
		//type with children, child values need to be assigned
		if (myASTVisitor.nodeNameChildrenNamesHashMap.containsKey(rootNodeType)) {

			if (!isSetOf) {
				constString.append(prefix + "=new " + rootNodeType + "();\r\n");
			}
			
			String[] childrenNodeNames = myASTVisitor.nodeNameChildrenNamesHashMap
					.get(rootNodeType);
			String[] childrenNodeTypes = myASTVisitor.nodeNameChildrenTypesHashMap
					.get(rootNodeType);

			for (int i = 0; i < childrenNodeNames.length; i++) {

				if (childrenNodeTypes[i].equals("CHARSTRING")) {

					// printvalue
					if (constValues.get(valueCounter).equals("omit")) {
						constString.append(prefix + "." + childrenNodeNames[i]
								+ "= new " + childrenNodeTypes[i] + "();\r\n");
						constString.append(prefix + "." + childrenNodeNames[i]
								+ ".omitField=true;\r\n");

					} else {
						constString.append(prefix + "." + childrenNodeNames[i]
								+ "= new " + childrenNodeTypes[i] + "(\""
								+ constValues.get(valueCounter) + "\");\r\n");
					}

					valueCounter++;
				} else if (childrenNodeTypes[i].equals("INTEGER")) {

					// printvalue
					if (constValues.get(valueCounter).equals("omit")) {
						constString.append(prefix + "." + childrenNodeNames[i]
								+ "= new " + childrenNodeTypes[i] + "();\r\n");
						constString
								.append(prefix + "." + "omitField=true;\r\n");

					} else {

						constString.append(prefix + "." + childrenNodeNames[i]
								+ "= new " + childrenNodeTypes[i] + "(\""
								+ constValues.get(valueCounter) + "\");\r\n");
						
					}

					valueCounter++;

				} else if (childrenNodeTypes[i].equals("FLOAT")) {

					// printvalue
					if (constValues.get(valueCounter).equals("omit")) {
						constString.append(prefix + "." + childrenNodeNames[i]
								+ "= new " + childrenNodeTypes[i] + "();\r\n");
						constString
								.append(prefix + "." + "omitField=true;\r\n");

					} else {

						constString.append(prefix + "." + childrenNodeNames[i]
								+ "= new " + childrenNodeTypes[i] + "("
								+ constValues.get(valueCounter) + ");\r\n");
						
					}

					valueCounter++;

				}else if (myASTVisitor.nodeNameChildrenNamesHashMap
						.containsKey(childrenNodeTypes[i])) {

					// child, novalue

					String prefixBackup = prefix;
					prefix = prefix.concat("." + childrenNodeNames[i]);
					writeConstConstructor(childrenNodeTypes[i],
							 prefix);
					prefix = prefixBackup;

				} else if (myASTVisitor.nodeNameSetOfTypesHashMap
						.containsKey(childrenNodeTypes[i])) {

					// setof

					constString.append(prefix + "." + childrenNodeNames[i]
							+ "=new " + childrenNodeTypes[i] + "();" + "\r\n");

					String nameOfSet = myASTVisitor.nodeNameSetOfTypesHashMap
							.get(childrenNodeTypes[i]);

					String prefixBackup = prefix;
					prefix = "TV_" + nameOfSet;

					if (!myASTVisitor.constOmitHashes
							.contains(childrenNodeNames[i])) {
						constString.append(nameOfSet + " TV_" + nameOfSet
								+ "= new " + nameOfSet + "();\r\n");
						isSetOf=true;
						writeConstConstructor(nameOfSet, 
								prefix);
						isSetOf=false;
						constString.append(prefixBackup+"."+childrenNodeNames[i] + ".value.add(TV_"
								+ nameOfSet + ");\r\n");
					} else {
						isSetOf=true;
						constString.append(prefixBackup + "." + childrenNodeNames[i]+".omitField=true;\r\n");
						isSetOf=false;
					}

					prefix = prefixBackup;

				} else {// nochild, notsimple, notset

					if(myASTVisitor.nodeNameNodeTypeHashMap
							.get(childrenNodeTypes[i]).equals("enum")){
						constString.append(prefix
								+ "."
								+ childrenNodeNames[i]
								+ "= new "
								+ childrenNodeTypes[i]
								+ " (\""
								+  constValues.get(valueCounter) + "\");\r\n");
					} else{
					// printvalue
					constString.append(prefix
							+ "."
							+ childrenNodeNames[i]
							+ "=new "
							+ childrenNodeTypes[i]
							+ "(new "
							+ myASTVisitor.nodeNameNodeTypeHashMap
									.get(childrenNodeTypes[i]) + "(\""
							+ childrenNodeNames[i] + "\"));" + "\r\n");
					}
					valueCounter++;
				}

			}
		} else { //simple type, no child value assignments
			if (myASTVisitor.nodeNameNodeTypeHashMap.containsKey(rootNodeType)) {

				String type = myASTVisitor.nodeNameNodeTypeHashMap
						.get(rootNodeType);
				
				
				if (type.equals("CHARSTRING") || type.equals("INTEGER")) {

					if(constValueIsAReference){
						if(myASTVisitor.nodeNameNodeTypeHashMap.containsKey(constValues.get(valueCounter))){
							if(myASTVisitor.nodeNameNodeTypeHashMap.get(constValues.get(valueCounter)).equals("constant")){
								constString.append("value = new "+constNodeType+"("+constValues.get(valueCounter)+".value)"
								+ ";\r\n");
							}
						}

						
						constString.append("value="+constValues.get(valueCounter)
								+ ";\r\n");
					}else{

					constString.append("value=new " + constNodeType + "(new "
							+ type + "(\"" + constValues.get(valueCounter)
							+ "\"));\r\n");
					}
					valueCounter++;
				}
			} else if(constNodeType.equals("INTEGER")){

				if(constValueIsAReference){
					constString.append("value="+constValues.get(valueCounter)
							+ ";\r\n");
				}else{
				constString.append("value=new " + constNodeType + "(\"" + constValues.get(valueCounter)
						+ "\");\r\n");
				}

				valueCounter++;
			} else if(constNodeType.equals("BITSTRING")){
				constString.append("value=new "
						+ "BITSTRING" + "(\"" + constValues.get(valueCounter)
						+ "\");\r\n");

				valueCounter++;
			} else if(constNodeType.equals("CHARSTRING")){
				constString.append("value=new "
						+ "CHARSTRING" + "(\"" + constValues.get(valueCounter)
						+ "\");\r\n");

				valueCounter++;
			} else if(constNodeType.equals("OCTETSTRING")){
				constString.append("value=new "
						+ "OCTETSTRING" + "(\"" + constValues.get(valueCounter)
						+ "\");\r\n");

				valueCounter++;
			} else if(constNodeType.equals("BOOLEAN")){
				constString.append("value=new "
						+ "BOOLEAN" + "(" + constValues.get(valueCounter)
						+ ");\r\n");

				valueCounter++;
			} else if(constNodeType.equals("FLOAT")){
				constString.append("value=new "
						+ "FLOAT" + "(" + constValues.get(valueCounter)
						+ ");\r\n");

				valueCounter++;
			}
		}
	}
	
	public void clearLists(){
		valueCounter = 0;
		
		constValueIsAReference = false;
		isSetOf = false;
		
		constParamCount.clear();
		constValues.clear();
	}

	public String getJavaSource() {

		AstWalkerJava.logToConsole("	Starting processing:  Constant " + nodeName );
		
		constString.append("public static " + constNodeType + " " + nodeName
				+ "(){\r\n");
		constString.append(constNodeType + " value;\r\n");

		writeConstConstructor(constNodeType, "value");
		constString.append("return value;\r\n");
		constString.append("}\r\n");
		String returnString = constString.toString();
		valueCounter = 0;
		constString.setLength(0);
		
		AstWalkerJava.logToConsole("	Finished processing:  Constant " + nodeName );
		return returnString;
	}
}
/******************************************************************************
 * Copyright (c) 2000-2017 Ericsson Telecom AB
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   
 *   Keremi, Andras
 *   Eros, Levente
 *   Kovacs, Gabor
 *   Meszaros, Mate Robert
 *
 ******************************************************************************/

package org.eclipse.titan.codegenerator;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.titan.designer.AST.TTCN3.definitions.Def_Function;
import org.eclipse.titan.designer.AST.TTCN3.definitions.Def_Timer;
import org.eclipse.titan.designer.AST.TTCN3.statements.Alt_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.Assignment_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.Definition_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.DoWhile_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.Receive_Port_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.Send_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.Setverdict_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.StatementBlock;
import org.eclipse.titan.designer.AST.TTCN3.statements.Unknown_Start_Statement;
import org.eclipse.titan.designer.AST.TTCN3.templates.SpecificValue_Template;
import org.eclipse.titan.designer.AST.TTCN3.values.Bitstring_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Boolean_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Charstring_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Integer_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Octetstring_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Referenced_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Undefined_LowerIdentifier_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Verdict_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.AddExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.And4bExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.DivideExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.ModuloExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.MultiplyExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.Not4bExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.Or4bExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.RemainderExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.RotateLeftExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.RotateRightExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.ShiftLeftExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.ShiftRightExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.StringConcatenationExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.SubstractExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.UnaryMinusExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.Xor4bExpression;

public class Def_Function_Writer {
	private Def_Function functionNode;
	private StringBuilder functionString = new StringBuilder("");

	public String nodeName = null;

	private static Map<String, Object> functionHashes = new LinkedHashMap<String, Object>();

	private StatementBlock statementBlock;
	private boolean isThereAStartedTimer = false;
	private String currentTimerName = null;

	public String returnStatementValue = null;
	public String runsOnValue = null;
	public String returnType = null;


	public static List<String> unknownStartReference = new ArrayList<String>();
	public static List<String> unknownStopReference = new ArrayList<String>();

	public static List<String> sendPortReference = new ArrayList<String>();
	public static List<String> sendParameter = new ArrayList<String>();
	public static List<String> sendParameterType = new ArrayList<String>();
	public int sendCounter = -1;

	public List<Def_AltStatement_Writer> altStatements = new ArrayList<Def_AltStatement_Writer>();
	private int altStatementCounter = -1;

	public List<String> functionVars = new ArrayList<String>();
	public List<String> functionVarTypes = new ArrayList<String>();
	public List<String> functionVarValues = new ArrayList<String>();
	public List<String> functionAssignIdentifiers = new ArrayList<String>();
	public List<String> functionAssignValues = new ArrayList<String>();

	public List<String> doWhileExpressions = new ArrayList<String>();
	
	public int receiveCounter = -1;
	public int doWhileCounter = -1;
	public int startCounter = -1;

	public List<String> receivePortReference = new ArrayList<String>();
	public List<String> receiveValue = new ArrayList<String>();
	public List<String> receiveAnyValValue = new ArrayList<String>();
	public List<String> receiveType = new ArrayList<String>();
	public List<StatementBlock> receiveStatements = new ArrayList<StatementBlock>();

	public List<Boolean> functionValueIsAValueReference = new ArrayList<Boolean>();
	public List<Boolean> functionVarIsConstant = new ArrayList<Boolean>();
	private int defCounter = -1;
	public int assignCounter = -1;

	private Def_Function_Writer(Def_Function typeNode) {
		super();
		this.functionNode = typeNode;
		nodeName = functionNode.getIdentifier().toString();
	}

	public static Def_Function_Writer getInstance(Def_Function typeNode) {
		if (!functionHashes.containsKey(typeNode.getIdentifier().toString())) {
			functionHashes.put(typeNode.getIdentifier().toString(), new Def_Function_Writer(typeNode));
		}
		return (Def_Function_Writer) functionHashes.get(typeNode.getIdentifier().toString());
	}

	public void setStatementBlock(StatementBlock statementBlock) {
		this.statementBlock = statementBlock;
	}

	public void writeFunctionHeader(StatementBlock statementBlock) {
		if (returnType != null) {
			if (returnType.equals("Integer_Type")) {
				functionString.append("public static INTEGER " + nodeName + "(){\r\n");
			} else if (returnType.equals("Boolean_Type")) {
				functionString.append("public static BOOLEAN " + nodeName + "(){\r\n");
			}
		} else {
			functionString.append("public void " + nodeName + "(){\r\n");

			functionString.append("String sourcefilename = \""
					+ statementBlock.getLocation().getFile().getFullPath().lastSegment() + "\";" + "\r\n");
			functionString.append("int rownum=" + statementBlock.getLocation().getLine() + ";\r\n");
			functionString.append("if(!created) return;" + "\r\n");

			functionString.append("TTCN3Logger.writeLog(compid, \"PARALLEL\", sourcefilename, rownum, \"function\", \""
					+ nodeName + "\", \"Function started on \" + compid + \".\", false);" + "\r\n");

		}
	}
	
	public void writeFunction(StatementBlock statementBlock) {

		

		for (int i = 0; i < statementBlock.getSize(); i++) {

			if (statementBlock.getStatementByIndex(i) instanceof Definition_Statement) {
				writeDefinitionStatement((Definition_Statement) statementBlock.getStatementByIndex(i));
			} else if (statementBlock.getStatementByIndex(i) instanceof Assignment_Statement) {
				assignCounter++;

				functionString
						.append(writeAssignmentStatement((Assignment_Statement) statementBlock.getStatementByIndex(i)));

			}else if (statementBlock.getStatementByIndex(i) instanceof Assignment_Statement) {
				Assignment_Statement tc_assignStatement = (Assignment_Statement) statementBlock
						.getStatementByIndex(i);

				assignCounter++;

				functionString
						.append(writeAssignmentStatement(tc_assignStatement));

			} else if (statementBlock.getStatementByIndex(i) instanceof Send_Statement) {
				sendCounter++;
				functionString.append(writeSendStatement((Send_Statement) statementBlock.getStatementByIndex(i)));
			} else if (statementBlock.getStatementByIndex(i) instanceof Unknown_Start_Statement) {
				startCounter++;
				writeUnknownStartStatement((Unknown_Start_Statement) statementBlock.getStatementByIndex(i));
			} else if (statementBlock.getStatementByIndex(i) instanceof Alt_Statement) {

				altStatementCounter++;

				altStatements.get(altStatementCounter).setTimerInfo(isThereAStartedTimer, currentTimerName);
				functionString.append(altStatements.get(altStatementCounter).getJavaSource());

			} else if (statementBlock.getStatementByIndex(i) instanceof Setverdict_Statement) {
				writeSetVerdictStatement((Setverdict_Statement) statementBlock.getStatementByIndex(i));
			}else if (statementBlock.getStatementByIndex(i) instanceof DoWhile_Statement) {
				doWhileCounter++;
				DoWhile_Statement doWhileStatement=(DoWhile_Statement)statementBlock.getStatementByIndex(i);
				String test=doWhileStatement.getExpression().toString();
				
				functionString.append("do{"+"\r\n");
				
				this.writeFunction(doWhileStatement.getStatementBlock());
				
				functionString.append("}while("+doWhileExpressions.get(doWhileCounter)+".getValue());\r\n");
				
			}
			
		
		}

		if (returnStatementValue != null) {
			functionString.append("return " + returnStatementValue + ";\r\n");
		}

	}

	// updated
	public void writeDefinitionStatement(Definition_Statement tc_defStatement) {

		defCounter++;
		if (tc_defStatement.getDefinition() instanceof Def_Timer) {
			Def_Timer def_Timer = (Def_Timer) tc_defStatement.getDefinition();

			functionString.append("rownum=" + def_Timer.getLocation().getLine() + ";\r\n");
			functionString.append("Timer " + def_Timer.getIdentifier().toString() + " = new Timer("
					+ functionVarValues.get(defCounter) + ");\r\n");

			functionString.append("TTCN3Logger.writeLog(compid, \"TIMEROP\", sourcefilename, rownum, \"function\", \""
					+ nodeName + "\", \"Timer " + def_Timer.getIdentifier().toString() + " set to "
					+ functionVarValues.get(defCounter) + ".\", false);" + "\r\n");

		} else if (functionVarTypes.get(defCounter).equals("BITSTRING")) {

			functionString.append("rownum=" + tc_defStatement.getLocation().getLine() + ";\r\n");

			if (functionVarIsConstant.get(defCounter)) {
				functionString.append("final ");
			}

			if (functionVarValues.get(defCounter)== null) {
				functionString.append(functionVarTypes.get(defCounter) + " " + functionVars.get(defCounter)
						+ "=new BITSTRING();\r\n");

			} else if (functionValueIsAValueReference.get(defCounter)) {
				functionString.append(functionVarTypes.get(defCounter) + " " + functionVars.get(defCounter) + "="
						+ functionVarValues.get(defCounter) + ";\r\n");

			} else {
				functionString.append(functionVarTypes.get(defCounter) + " " + functionVars.get(defCounter)
						+ "=new BITSTRING(\"" + functionVarValues.get(defCounter) + "\");\r\n");

			}
			// TODO: add logging here

		} else if (functionVarTypes.get(defCounter).equals("INTEGER")) {

			functionString.append("rownum=" + tc_defStatement.getLocation().getLine() + ";\r\n");
			if (functionVarIsConstant.get(defCounter)) {
				functionString.append("final ");
			}

			if (functionVarValues.get(defCounter)== null) {
				functionString.append(
						functionVarTypes.get(defCounter) + " " + functionVars.get(defCounter) + "=new INTEGER();\r\n");

			} else if (functionValueIsAValueReference.get(defCounter)) {
				functionString.append(functionVarTypes.get(defCounter) + " " + functionVars.get(defCounter) + "="
						+ functionVarValues.get(defCounter) + ";\r\n");

			} else {
				functionString.append(functionVarTypes.get(defCounter) + " " + functionVars.get(defCounter)
						+ "=new INTEGER(\"" + functionVarValues.get(defCounter) + "\");\r\n");

			}
			// TODO: add logging here

		} else if (functionVarTypes.get(defCounter).equals("CHARSTRING")) {

			functionString.append("rownum=" + tc_defStatement.getLocation().getLine() + ";\r\n");

			if (functionVarIsConstant.get(defCounter)) {
				functionString.append("final ");
			}

			if (functionVarValues.get(defCounter)== null) {
				functionString.append(functionVarTypes.get(defCounter) + " " + functionVars.get(defCounter)
						+ "=new CHARSTRING();\r\n");

			} else if (functionValueIsAValueReference.get(defCounter)) {
				functionString.append(functionVarTypes.get(defCounter) + " " + functionVars.get(defCounter) + "="
						+ functionVarValues.get(defCounter) + ";\r\n");

			} else {
				functionString.append(functionVarTypes.get(defCounter) + " " + functionVars.get(defCounter)
						+ "=new CHARSTRING(\"" + functionVarValues.get(defCounter) + "\");\r\n");

			}
			// TODO: add logging here

		} else if (functionVarTypes.get(defCounter).equals("BOOLEAN")) {

			functionString.append("rownum=" + tc_defStatement.getLocation().getLine() + ";\r\n");

			if (functionVarIsConstant.get(defCounter)) {
				functionString.append("final ");
			}

			if (functionVarValues.get(defCounter)== null) {
				functionString.append(
						functionVarTypes.get(defCounter) + " " + functionVars.get(defCounter) + "=new BOOLEAN();\r\n");

			} else if (functionValueIsAValueReference.get(defCounter)) {
				functionString.append(functionVarTypes.get(defCounter) + " " + functionVars.get(defCounter) + "="
						+ functionVarValues.get(defCounter) + ";\r\n");

			} else {
				functionString.append(functionVarTypes.get(defCounter) + " " + functionVars.get(defCounter)
						+ " = BOOLEAN.valueOf(" + functionVarValues.get(defCounter) + ");\r\n");

			}
			// TODO: add logging here
		} else if (myASTVisitor.nodeNameNodeTypeHashMap.containsKey(functionVarTypes.get(defCounter))) {
			functionString.append("rownum=" + tc_defStatement.getLocation().getLine() + ";\r\n");

			if (functionVarValues.get(defCounter) != null) {
				functionString.append(functionVarTypes.get(defCounter) + " " + functionVars.get(defCounter) + "= new "
						+ functionVarTypes.get(defCounter) + "(" + functionVarValues.get(defCounter) + ")" + ";\r\n");
			} else {
				functionString.append(functionVarTypes.get(defCounter) + " " + functionVars.get(defCounter) + ";\r\n");
			}
		}
	}

	// updated
	public String writeAssignmentStatement(Assignment_Statement tc_assignStatement) {


		StringBuilder functionString = new StringBuilder("");

		if (tc_assignStatement.getTemplate() instanceof SpecificValue_Template) {
			SpecificValue_Template specValTemplate = (SpecificValue_Template) tc_assignStatement
					.getTemplate();
			
			 if ((specValTemplate.getSpecificValue() instanceof Bitstring_Value)
					|| (specValTemplate.getSpecificValue() instanceof Integer_Value)
					|| (specValTemplate.getSpecificValue() instanceof Charstring_Value)
					|| (specValTemplate.getSpecificValue() instanceof Boolean_Value)
					||(specValTemplate.getSpecificValue() instanceof Octetstring_Value)
					|| (specValTemplate.getSpecificValue() instanceof Undefined_LowerIdentifier_Value)
					|| (specValTemplate.getSpecificValue() instanceof Referenced_Value)
					|| (specValTemplate.getSpecificValue() instanceof And4bExpression)
					|| (specValTemplate.getSpecificValue() instanceof Xor4bExpression)
					|| (specValTemplate.getSpecificValue() instanceof Not4bExpression)
					|| (specValTemplate.getSpecificValue() instanceof Or4bExpression)
					|| (specValTemplate.getSpecificValue() instanceof ShiftLeftExpression)
					|| (specValTemplate.getSpecificValue() instanceof ShiftRightExpression)
					|| (specValTemplate.getSpecificValue() instanceof RotateRightExpression)
					|| (specValTemplate.getSpecificValue() instanceof RotateLeftExpression)
					|| (specValTemplate.getSpecificValue() instanceof StringConcatenationExpression)
					|| (specValTemplate.getSpecificValue() instanceof AddExpression)
					|| (specValTemplate.getSpecificValue() instanceof SubstractExpression)
					|| (specValTemplate.getSpecificValue() instanceof MultiplyExpression)
					|| (specValTemplate.getSpecificValue() instanceof DivideExpression)
					|| (specValTemplate.getSpecificValue() instanceof ModuloExpression)
					|| (specValTemplate.getSpecificValue() instanceof RemainderExpression)
					||(specValTemplate.getSpecificValue() instanceof UnaryMinusExpression)) {
				// TODO assignments for indexed bitstrings
				 functionString.append("rownum="
						+ specValTemplate.getLocation().getLine() + ";\r\n");


				 functionString.append(functionAssignIdentifiers.get(assignCounter)
						 + functionAssignValues.get(assignCounter) + ";\r\n");

				

				// TODO: add logging here
			}
		
		}
		
		/*StringBuilder functionString = new StringBuilder("");

		if (tc_assignStatement.getTemplate() instanceof SpecificValue_Template) {
			SpecificValue_Template specValTemplate = (SpecificValue_Template) tc_assignStatement.getTemplate();

			if (specValTemplate.getSpecificValue() instanceof Bitstring_Value) {

				functionString.append("rownum=" + specValTemplate.getLocation().getLine() + ";\r\n");

				functionString.append(functionAssignIdentifiers.get(assignCounter) + "=new BITSTRING(\""
						+ functionAssignValues.get(assignCounter) + "\");\r\n");

				// TODO: add logging here

			}

			if (specValTemplate.getSpecificValue() instanceof Integer_Value) {

				functionString.append("rownum=" + specValTemplate.getLocation().getLine() + ";\r\n");

				functionString.append(functionAssignIdentifiers.get(assignCounter) + "=new INTEGER(\""
						+ functionAssignValues.get(assignCounter) + "\");\r\n");

				// TODO: add logging here

			}

			if (specValTemplate.getSpecificValue() instanceof Charstring_Value) {

				functionString.append("rownum=" + specValTemplate.getLocation().getLine() + ";\r\n");

				functionString.append(functionAssignIdentifiers.get(assignCounter) + "=new CHARSTRING(\""
						+ functionAssignValues.get(assignCounter) + "\");\r\n");

				// TODO: add logging here

			}

			if (specValTemplate.getSpecificValue() instanceof Boolean_Value) {

				functionString.append("rownum=" + specValTemplate.getLocation().getLine() + ";\r\n");

				functionString.append(functionAssignIdentifiers.get(assignCounter) + "=new BOOLEAN("
						+ functionAssignValues.get(assignCounter) + ");\r\n");

				// TODO: add logging here

			}

			if (specValTemplate.getSpecificValue() instanceof Undefined_LowerIdentifier_Value) {

				functionString.append("rownum=" + specValTemplate.getLocation().getLine() + ";\r\n");

				functionString.append(functionAssignIdentifiers.get(assignCounter) + "="
						+ functionAssignValues.get(assignCounter) + ";\r\n");

				// TODO: add logging here
			}

			if (specValTemplate.getSpecificValue() instanceof Referenced_Value) {

				functionString.append("rownum=" + specValTemplate.getLocation().getLine() + ";\r\n");

				functionString.append(functionAssignIdentifiers.get(assignCounter) + "="
						+ functionAssignValues.get(assignCounter) + ";\r\n");

				// TODO: add logging here
			}

			if ((specValTemplate.getSpecificValue() instanceof AddExpression)
					|| (specValTemplate.getSpecificValue() instanceof SubstractExpression)
					|| (specValTemplate.getSpecificValue() instanceof MultiplyExpression)
					|| (specValTemplate.getSpecificValue() instanceof DivideExpression)
					|| (specValTemplate.getSpecificValue() instanceof ModuloExpression)
					|| (specValTemplate.getSpecificValue() instanceof RemainderExpression)) {

				functionString.append("rownum=" + specValTemplate.getLocation().getLine() + ";\r\n");

				functionString.append(functionAssignIdentifiers.get(assignCounter)
						+ functionAssignValues.get(assignCounter) + ";\r\n");

				// TODO: add logging here

			}

			if (specValTemplate.getSpecificValue() instanceof UnaryMinusExpression) {

				functionString.append("rownum=" + specValTemplate.getLocation().getLine() + ";\r\n");

				functionString.append(functionAssignIdentifiers.get(assignCounter) + "=new INTEGER(\""
						+ functionAssignValues.get(assignCounter) + "\");\r\n");

				// TODO: add logging here

			}

		}
*/
		return functionString.toString();
	}

	
	
	public String writeSendStatement(Send_Statement sendStatement) {

		StringBuilder functionString = new StringBuilder("");

		String portReferenceName = sendPortReference.get(sendCounter);
		String parameterName = null;
		String parameterType = null;
		String valueType = sendParameterType.get(sendCounter);
		String valueName = sendParameter.get(sendCounter);

		if (valueType.equals("IDENTIFIER")) {

			if (myASTVisitor.nodeNameNodeTypeHashMap.containsKey(valueName)) {
				parameterType = myASTVisitor.nodeNameNodeTypeHashMap.get(valueName);

				if (parameterType.equals("template")) {
					parameterType = "Templates";
				}
				parameterName = parameterType + "." + valueName + "()";
			} else {
				parameterName = valueName;
			}

			functionString.append("rownum=" + sendStatement.getLocation().getLine() + ";\r\n");
			functionString.append(portReferenceName + ".send(" + parameterName + ");" + "\r\n");
			functionString.append("TTCN3Logger.writeLog(compid, \"PORTEVENT\", sourcefilename, rownum, \"function\", \""
					+ nodeName + "\", \"SEND event on port " + portReferenceName + ": " + valueName + ":=\" + "
					+ parameterName + ".toString(), true);" + "\r\n");

		}

		if (valueType.equals("CHARSTRING")) {
			parameterName = valueName;
			functionString.append("rownum=" + sendStatement.getLocation().getLine() + ";\r\n");
			functionString.append(portReferenceName + ".send(" + parameterName + ");" + "\r\n");
			functionString.append("TTCN3Logger.writeLog(compid, \"PORTEVENT\", sourcefilename, rownum, \"function\", \""
					+ nodeName + "\", \"SEND event on port " + portReferenceName + ":\"+" + parameterName
					+ ".toString(), false);" + "\r\n");

		}

		return functionString.toString();

	}

	public String writeReceiveStatement(Receive_Port_Statement currentStatement) {
		StringBuilder testCaseString = new StringBuilder("");
		String receiveStatement = "";

		// no alt guard && any port recieve
		if (receivePortReference.get(receiveCounter).equals("any port")) {
			receiveStatement = "anyPortReceive(true)";

		} else {
			// no alt guard && typed port recieve
			if (receiveType.get(receiveCounter).equals("_TYPED_PARAM_")) {

				if (receiveAnyValValue.get(receiveCounter) != null) {
					receiveStatement = "(" + receiveAnyValValue.get(receiveCounter) + "="
							+ receivePortReference.get(receiveCounter) + ".receive_" + receiveValue.get(receiveCounter)
							+ "(true))!=null";

				} else {

				}

			} else { // no alt guard && normal port recieve
				receiveStatement = receivePortReference.get(receiveCounter) + ".receive("
						+ receiveValue.get(receiveCounter) + ",true)!=null";
			}
			if (receiveValue.get(receiveCounter).startsWith("Templates")) {
				receiveType.set(receiveCounter, "Templates");
			}
		}

		testCaseString.append("if(" + receiveStatement + "){\r\n");
		testCaseString.append("rownum=" + currentStatement.getLocation().getLine() + ";\r\n");

		if (receiveType.get(receiveCounter).equals("Templates")) {
			String methodName = receiveValue.get(receiveCounter);
			if (methodName.endsWith("()") && methodName.startsWith("Templates.")) {

				methodName = (String) methodName.subSequence(10, methodName.length() - 2);
			}

			testCaseString
					.append("	TTCN3Logger.writeLog(\"mtc\", \"PORTEVENT\", sourcefilename, rownum, \"function\", \""
							+ nodeName + "\", \"RECEIVE event on port " + receivePortReference.get(receiveCounter)
							+ ":\\n " + methodName + ":=\" + " + receiveValue.get(receiveCounter)
							+ ".toString(), true);" + "\r\n");
		} else if (receiveType.get(receiveCounter).equals("any port")) {
			testCaseString
					.append("	TTCN3Logger.writeLog(\"mtc\", \"PORTEVENT\", sourcefilename, rownum, \"function\", \""
							+ nodeName + "\", \"RECEIVE event on port any port\", true);" + "\r\n");
		} else if (receiveType.get(receiveCounter).equals("_TYPED_PARAM_")) {
			testCaseString
					.append("	TTCN3Logger.writeLog(\"mtc\", \"PORTEVENT\", sourcefilename, rownum, \"function\", \""
							+ nodeName + "\", \"RECEIVE event on port " + receivePortReference.get(receiveCounter)
							+ ": type " + receiveValue.get(receiveCounter) + "\", true);" + "\r\n");

		} else {
			testCaseString
					.append("	TTCN3Logger.writeLog(\"mtc\", \"PORTEVENT\", sourcefilename, rownum, \"function\", \""
							+ nodeName + "\", \"RECEIVE event on port " + receivePortReference.get(receiveCounter)
							+ ":\" + " + receiveValue.get(receiveCounter) + ".toString(), true);" + "\r\n");
		}

		for (int i = 0; i < receiveStatements.get(receiveCounter).getSize(); i++) {
			if (receiveStatements.get(receiveCounter).getStatementByIndex(i) instanceof Setverdict_Statement) {

				Setverdict_Statement setVerdictStatement = (Setverdict_Statement) receiveStatements.get(receiveCounter)
						.getStatementByIndex(i);
				String verdict = "";

				if (setVerdictStatement.getVerdictValue() instanceof Verdict_Value) {
					Verdict_Value verdictValue = (Verdict_Value) setVerdictStatement.getVerdictValue();
					if (verdictValue.getValue().toString().equals("PASS")) {
						verdict = "pass";
					} else if (verdictValue.getValue().toString().equals("INCONC")) {
						verdict = "inconc";
					} else {
						verdict = "fail";
					}
				}
				testCaseString.append("rownum=" + setVerdictStatement.getLocation().getLine() + ";\r\n");
				testCaseString
						.append("TTCN3Logger.writeLog(\"mtc\", \"VERDICTOP\", sourcefilename, rownum, \"function\", \""
								+ nodeName + "\", \"setverdict(" + verdict + "): \" + getVerdict() + \" -> " + verdict
								+ "\", true);" + "\r\n");
				testCaseString.append("setVerdict(\"" + verdict + "\");" + "\r\n");

			}
		}

		testCaseString.append("}\r\n");

		return testCaseString.toString();
	}

	// updated
	public void writeUnknownStartStatement(Unknown_Start_Statement unknownStartStatement) {
		functionString.append("rownum=" + unknownStartStatement.getLocation().getLine() + ";\r\n");
		functionString.append(unknownStartReference.get(startCounter) + ".start();" + "\r\n");
		isThereAStartedTimer = true;
		currentTimerName = unknownStartReference.get(startCounter);
		functionString.append("TTCN3Logger.writeLog(compid, \"TIMEROP\", sourcefilename, rownum, \"function\", \""
				+ nodeName + "\", \"Timer " + unknownStartReference + " started.\", false);" + "\r\n");

	}

	public void writeSetVerdictStatement(Setverdict_Statement setVerdictStatement) {

		String verdict = "";

		if (setVerdictStatement.getVerdictValue() instanceof Verdict_Value) {
			Verdict_Value verdictValue = (Verdict_Value) setVerdictStatement.getVerdictValue();
			if (verdictValue.getValue().toString().equals("PASS")) {
				verdict = "pass";
			} else if (verdictValue.getValue().toString().equals("INCONC")) {
				verdict = "inconc";
			} else {
				verdict = "fail";
			}
		}
		functionString.append("rownum=" + setVerdictStatement.getLocation().getLine() + ";\r\n");
		functionString.append("TTCN3Logger.writeLog(compid, \"VERDICTOP\", sourcefilename, rownum, \"function\", \""
				+ nodeName + "\", \"setverdict(" + verdict + "): \" + getVerdict() + \" -> " + verdict + "\", true);"
				+ "\r\n");
		functionString.append("setVerdict(\"" + verdict + "\");" + "\r\n");
	}

	public String writeFunctionFile() {

		StringBuilder functionFileString = new StringBuilder();

		functionFileString.append("class " + nodeName + " implements Runnable{" + "\r\n");
		functionFileString.append("private " + runsOnValue + " component;" + "\r\n");
		functionFileString.append("public " + nodeName + "(" + runsOnValue + " c){" + "\r\n");
		functionFileString.append("component = c;" + "\r\n");
		functionFileString.append("}" + "\r\n");
		functionFileString.append("public void run(){" + "\r\n");
		functionFileString.append("component." + nodeName + "();" + "\r\n");
		functionFileString.append("}" + "\r\n");
		functionFileString.append("}" + "\r\n");

		return functionFileString.toString();
	}

	public String getJavaSource() {
		AstWalkerJava.logToConsole("	Starting processing:  Function " + nodeName);

		sendCounter = -1;

		this.writeFunctionHeader(statementBlock);
		this.writeFunction(statementBlock);
		functionString.append("\r\n}");
		String returnString = functionString.toString();
		functionString.setLength(0);

		sendPortReference.clear();
		sendParameter.clear();
		sendParameterType.clear();

		AstWalkerJava.logToConsole("	Finished processing:  Function " + nodeName);
		clearLists();
		return returnString;
	}

	public void clearAltLists() {
		altStatements.clear();
		altStatementCounter = -1;

	}

	public void clearLists() {
		functionString.setLength(0);
		returnType = null;
		returnStatementValue = null;

		isThereAStartedTimer = false;

		sendCounter = -1;

		sendPortReference.clear();
		sendParameter.clear();
		sendParameterType.clear();

		receivePortReference.clear();
		receiveValue.clear();
		receiveAnyValValue.clear();
		receiveType.clear();

		functionVars.clear();
		functionVarTypes.clear();
		functionVarValues.clear();
		functionAssignIdentifiers.clear();
		functionAssignValues.clear();
		
		doWhileExpressions.clear();

		functionValueIsAValueReference.clear();
		functionVarIsConstant.clear();
		defCounter = -1;
		assignCounter = -1;
		doWhileCounter = -1;
		startCounter = -1;
		
		receiveStatements.clear();
	}

}
/******************************************************************************
 * Copyright (c) 2000-2017 Ericsson Telecom AB
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   
 *   Keremi, Andras
 *   Eros, Levente
 *   Kovacs, Gabor
 *
 ******************************************************************************/

package org.eclipse.titan.codegenerator;

import java.util.ArrayList;
import java.util.List;

import org.eclipse.titan.designer.AST.FieldSubReference;
import org.eclipse.titan.designer.AST.IVisitableNode;
import org.eclipse.titan.designer.AST.Identifier;
import org.eclipse.titan.designer.AST.Reference;
import org.eclipse.titan.designer.AST.TTCN3.definitions.Def_Template;
import org.eclipse.titan.designer.AST.TTCN3.templates.AnyOrOmit_Template;
import org.eclipse.titan.designer.AST.TTCN3.templates.Any_Value_Template;
import org.eclipse.titan.designer.AST.TTCN3.templates.ListOfTemplates;
import org.eclipse.titan.designer.AST.TTCN3.templates.NamedTemplates;
import org.eclipse.titan.designer.AST.TTCN3.templates.Named_Template_List;
import org.eclipse.titan.designer.AST.TTCN3.templates.SpecificValue_Template;
import org.eclipse.titan.designer.AST.TTCN3.types.subtypes.Range_ParsedSubType;
import org.eclipse.titan.designer.AST.TTCN3.values.Charstring_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Integer_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Omit_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Referenced_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Undefined_LowerIdentifier_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.AddExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.DivideExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.EqualsExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.GreaterThanExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.GreaterThanOrEqualExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.LessThanExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.LessThanOrEqualExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.Log2StrExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.ModuloExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.MultiplyExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.NotExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.NotequalesExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.RemainderExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.Str2IntExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.SubstractExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.ValueofExpression;

public class Def_Template_Visit_Handler {

	private static String modifierValue = null;
	private static String lastTemplateName = null;
	private static String currentTemplateNodeName = null;

	private static int templateRefdValCounter = -1;

	private static boolean waitForModifierValue = false;
	private static boolean isTemplateNameSet = false;
	private static boolean waitForTemplateRefdVals = false;
	private static boolean waitForTemplateValues = false;
	private static boolean waitForSepcValTemplate = false;

	private static List<String> templateListValues = new ArrayList<String>();
	private static List<String> templateAllIdentifiers = new ArrayList<String>();
	private static List<String> templateRefdVals = new ArrayList<String>();
	private boolean waitForTemplateList = false;
	private boolean blockTemplateListing = false;
	private boolean waitForNamedTemplates = false;
	public static boolean isTemplate=false;
	
	private static List<String> expressionValue = new ArrayList<String>();
	private boolean isInteger = false;
	private String exressionResult="";
	
	public void evaluateExpression() {
		int size = expressionValue.size() - 1;
		boolean operatorFound = false;
		boolean unaryOperatorFound = false;
		String rightHand = "";
		String leftHand = "";

		for (int i = size; i >= 0; i--) {

			if (myASTVisitor.nodeNameNodeTypeHashMap.containsKey(expressionValue.get(i))) {

				if (myASTVisitor.nodeNameNodeTypeHashMap.get(expressionValue.get(i)).equals("constant")) {
					expressionValue.set(i, "Constants." + expressionValue.get(i) + "().value");

				} else if (myASTVisitor.nodeNameNodeTypeHashMap.get(expressionValue.get(i)).equals("template")) {
					expressionValue.set(i, "Templates." + expressionValue.get(i) + "()");

				} else if (myASTVisitor.nodeNameNodeTypeHashMap.get(expressionValue.get(i)).equals("INTEGER")
						||myASTVisitor.nodeNameNodeTypeHashMap.get(expressionValue.get(i)).equals("CHARSTRING")
						||myASTVisitor.nodeNameNodeTypeHashMap.get(expressionValue.get(i)).equals("BITSTRING")
						||myASTVisitor.nodeNameNodeTypeHashMap.get(expressionValue.get(i)).equals("BOOLEAN")
						||myASTVisitor.nodeNameNodeTypeHashMap.get(expressionValue.get(i)).equals("OCTETSTRING")
						||myASTVisitor.nodeNameNodeTypeHashMap.get(expressionValue.get(i)).equals("HEXSTRING")
						) {
					if (myASTVisitor.nodeNameAllowedValuesHashmap.containsKey(expressionValue.get(i))) {

						expressionValue.set(i, myASTVisitor.nodeNameAllowedValuesHashmap.get(expressionValue.get(i)));

					}
				}

			}

			if (i <= size - 2) {
				leftHand = expressionValue.get(i + 1);
				rightHand = expressionValue.get(i + 2);
			}

			//
			if (expressionValue.get(i).equals("Str2IntExpression")) {
				expressionValue.set(i, "(" + expressionValue.get(i + 1) + ".str2int())");
				unaryOperatorFound = true;
			} else if (expressionValue.get(i).equals("Log2StrExpression")) {
				expressionValue.set(i, "(" + expressionValue.get(i + 1) + ".log2str())");
				unaryOperatorFound = true;
			} else if (expressionValue.get(i).equals("ValueofExpression")) {
				expressionValue.set(i, "(" + expressionValue.get(i + 1) + ").value");
				unaryOperatorFound = true;
			} else if (expressionValue.get(i).equals("NotExpression")) {
				expressionValue.set(i, "(" + expressionValue.get(i + 1) + ").not()");
				unaryOperatorFound = true;
			} else if (expressionValue.get(i).equals("AddExpression")) {
				expressionValue.set(i, "(" + leftHand + ").plus(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("SubstractExpression")) {
				expressionValue.set(i, "(" + leftHand + ").minus(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("MultiplyExpression")) {
				expressionValue.set(i, "(" + leftHand + ").multipleBy(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("DivideExpression")) {
				expressionValue.set(i, "(" + leftHand + ").divideBy(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("ModuloExpression")) {
				expressionValue.set(i, "(" + leftHand + ").mod(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("RemainderExpression")) {
				expressionValue.set(i, "(" + leftHand + ").rem(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("NotequalesExpression")) {
				expressionValue.set(i, "(" + leftHand + ").equalsWith(" + rightHand + ").not()");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("LessThanExpression")) {
				expressionValue.set(i, "(" + leftHand + ").isLessThan(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("LessThanOrEqualExpression")) {
				expressionValue.set(i, "(" + leftHand + ").isLessOrEqualThan(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("GreaterThanExpression")) {
				expressionValue.set(i, "(" + leftHand + ").isGreaterThan(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("GreaterThanOrEqualExpression")) {
				expressionValue.set(i, "(" + leftHand + ").isGreaterOrEqualThan(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("EqualsExpression")) {
				expressionValue.set(i, "(" + leftHand + ").equalsWith(" + rightHand + ")");
				operatorFound = true;
			}/* else if (expressionValue.get(i).equals("Range_ParsedSubType")) {
				expressionValue.set(i, "new SubTypeInterval<INTEGER>(" + expressionValue.get(i + 1) + ","
						+ expressionValue.get(i + 2) + ")");
				operatorFound = true;

			}*/

			if (unaryOperatorFound) {
				unaryOperatorFound = false;
				expressionValue.remove(i + 1);
				size = expressionValue.size() - 1;
				i = size;
			} else if (operatorFound) {
				operatorFound = false;
				expressionValue.remove(i + 2);
				expressionValue.remove(i + 1);
				size = expressionValue.size() - 1;
				i = size;
			}

		}
if(expressionValue.size()>0){
		exressionResult=expressionValue.get(0);
}
		expressionValue.clear();
	}

	public void visitExpressionTypeSelectors(IVisitableNode node) {

		if (waitForSepcValTemplate && (node instanceof AddExpression)) {
			expressionValue.add("AddExpression");
			isTemplate=false;
		}

		if (waitForSepcValTemplate && (node instanceof SubstractExpression)) {
			expressionValue.add("SubstractExpression");
		}

		if (waitForSepcValTemplate && (node instanceof MultiplyExpression)) {
			expressionValue.add("MultiplyExpression");
		}

		if (waitForSepcValTemplate && (node instanceof DivideExpression)) {
			expressionValue.add("DivideExpression");
		}

		if (waitForSepcValTemplate && (node instanceof ModuloExpression)) {
			expressionValue.add("ModuloExpression");
		}

		if (waitForSepcValTemplate && (node instanceof RemainderExpression)) {
			expressionValue.add("RemainderExpression");
		}

		if (waitForSepcValTemplate && (node instanceof NotequalesExpression)) {
			expressionValue.add("NotequalesExpression");
		}

		if (waitForSepcValTemplate && (node instanceof LessThanExpression)) {
			expressionValue.add("LessThanExpression");
		}

		if (waitForSepcValTemplate && (node instanceof LessThanOrEqualExpression)) {
			expressionValue.add("LessThanOrEqualExpression");
		}

		if (waitForSepcValTemplate && (node instanceof GreaterThanExpression)) {
			expressionValue.add("GreaterThanExpression");
		}

		if (waitForSepcValTemplate && (node instanceof GreaterThanOrEqualExpression)) {
			expressionValue.add("GreaterThanOrEqualExpression");
		}

		if (waitForSepcValTemplate && (node instanceof EqualsExpression)) {
			expressionValue.add("EqualsExpression");
		}

		if (waitForSepcValTemplate && (node instanceof NotExpression)) {
			expressionValue.add("NotExpression");
		}

		if (node instanceof Range_ParsedSubType) {
			expressionValue.add("Range_ParsedSubType");
		}

		if (node instanceof Str2IntExpression) {
			expressionValue.add("Str2IntExpression");
		}

		if (node instanceof Log2StrExpression) {
			expressionValue.add("Log2StrExpression");
		}

		if (node instanceof ValueofExpression) {
			expressionValue.add("ValueofExpression");
		}



	}
	
	
	
	

	public void visit(IVisitableNode node) {

		if (node instanceof Def_Template) {
			myASTVisitor.currentFileName = "Templates";

			Def_Template_Writer.getInstance(((Def_Template) node));

			myASTVisitor.nodeNameNodeTypeHashMap.put(((Def_Template) node)
					.getIdentifier().toString(), "template");

			isTemplate=true;
			waitForTemplateRefdVals=false;
			
			templateRefdValCounter=-1;
			waitForModifierValue = true;
			waitForTemplateValues = true;

		}
 
		visitTemplateNodes(node);//SpecificValueTemplate AddExpression Undefined_LowerIdentifier_Value Referenced_Value Reference 
	}

	public void visitTemplateNodes(IVisitableNode node) {
		
		visitExpressionTypeSelectors(node);
		

		
		if (waitForTemplateValues && (node instanceof Reference)) {
			Def_Const_Visit_Handler.constNodeType = ((Reference) node).getId()
					.toString();
		}
		
		if(node instanceof Named_Template_List){
			waitForNamedTemplates=true;
		}

		//ListOfTemplates is returned twice, should be recorded only once
		if (waitForTemplateValues && !blockTemplateListing&&(node instanceof ListOfTemplates)) {
			waitForTemplateList = true;
		}
		
		/*if (waitForTemplateValues && !blockTemplateListing&&(node instanceof NamedTemplates)) {
			waitForTemplateList = true;
		}*/


		if (waitForTemplateValues && (node instanceof SpecificValue_Template)) {
			waitForSepcValTemplate = true;

		}
		
		if (waitForTemplateValues
				&& (node instanceof Undefined_LowerIdentifier_Value)) {
			String value = ((Undefined_LowerIdentifier_Value) node)
					.getIdentifier().toString();

			if (waitForTemplateList) {
				templateListValues.add(value);
			} else {
				myASTVisitor.templateIdValuePairs.put(lastTemplateName, value);
			}
			myASTVisitor.blockIdListing = true;
		}

		if (waitForTemplateValues && (node instanceof Charstring_Value)) {

			String value = ((Charstring_Value) node).getValue();

			if (waitForTemplateList) {
				templateListValues.add(value);
			} else {
				myASTVisitor.templateIdValuePairs.put(lastTemplateName, value);
			}

			myASTVisitor.blockIdListing = true;
		}
		
		if (waitForTemplateValues && (node instanceof Integer_Value)) {

			String value = ((Integer_Value) node).toString();

			if (myASTVisitor.isNextIntegerNegative) {
				value = "-" + value;
			}

			if (waitForTemplateList) {
				templateListValues.add(value);
			} else {
				myASTVisitor.templateIdValuePairs.put(lastTemplateName, value);
			}

			myASTVisitor.isNextIntegerNegative = false;
			myASTVisitor.blockIdListing = true;
		}

		if (waitForTemplateValues && (node instanceof Omit_Value)) {

			if (waitForTemplateList) {
				templateListValues.add("omit");
			} else {
				myASTVisitor.templateIdValuePairs.put(lastTemplateName, "omit");
			}
			myASTVisitor.blockIdListing = true;
		}

		if (waitForTemplateValues && (node instanceof Any_Value_Template)) {

			if (waitForTemplateList) {
				templateListValues.add("?");
			} else {
				myASTVisitor.templateIdValuePairs.put(lastTemplateName, "?");
			}
			myASTVisitor.blockIdListing = true;
		}

		if (waitForTemplateValues && (node instanceof AnyOrOmit_Template)) {

			if (waitForTemplateList) {
				templateListValues.add("*");
			} else {
				myASTVisitor.templateIdValuePairs.put(lastTemplateName, "*");
			}
			myASTVisitor.blockIdListing = true;
		}

		if (waitForTemplateValues && (node instanceof Reference)) {

			String value = ((Reference) node).toString().toString();

			if (waitForTemplateList) {
				templateListValues.add(value);
			} else if (!waitForSepcValTemplate) {
				myASTVisitor.templateIdValuePairs.put(lastTemplateName, value);
			}

			myASTVisitor.blockIdListing = true;
		}

		if (waitForTemplateValues && (node instanceof Identifier)
				&& (!myASTVisitor.blockIdListing|| waitForNamedTemplates)) {
			templateAllIdentifiers.add(((Identifier) node).toString());
			lastTemplateName = ((Identifier) node).toString();
			myASTVisitor.templateIDs.add(lastTemplateName);

			if (!isTemplateNameSet) {
				currentTemplateNodeName = ((Identifier) node).toString();
				isTemplateNameSet = true;
			}

		}

		
		if (waitForSepcValTemplate&& isTemplate && (node instanceof Referenced_Value)) {
			templateRefdValCounter++;
			waitForTemplateRefdVals = true;

		}
		
		if (waitForSepcValTemplate && (node instanceof Reference)) {
			expressionValue.add(((Reference)node).getId().toString());
		}


		if (waitForTemplateRefdVals&& isTemplate  && (node instanceof FieldSubReference)) {
			if (templateRefdVals.size() == templateRefdValCounter) {
				templateRefdVals.add(((FieldSubReference) node).getId()
						.toString());
			} else {
				templateRefdVals
						.set(templateRefdValCounter,
								templateRefdVals.get(templateRefdValCounter)
										+ "."
										+ ((FieldSubReference) node).getId()
												.toString());
				waitForTemplateRefdVals=false; //TODO
			}
		}

		if (waitForModifierValue && (node instanceof Named_Template_List)) {
			waitForModifierValue = false;
			
		}

		if (waitForModifierValue && (node instanceof Reference)) {
			modifierValue = ((Reference) node).getId().toString();
		}
	}

	public void leave(IVisitableNode node) {
		if (node instanceof Def_Template) {
			handleTemplate(node);
		}

		if(node instanceof Named_Template_List){
			waitForNamedTemplates=false;;
		}

		
		if (waitForTemplateValues && (node instanceof SpecificValue_Template)) {
			evaluateExpression();
			if(waitForTemplateRefdVals){
			myASTVisitor.templateIdValuePairs.put(currentTemplateNodeName,
					templateRefdVals.get(templateRefdValCounter));
			} else {
				myASTVisitor.templateIdValuePairs.put(currentTemplateNodeName,
						exressionResult);
			}
			
			waitForSepcValTemplate = false;

		}
		
		if (waitForTemplateValues
				&& ((node instanceof Undefined_LowerIdentifier_Value)
						|| (node instanceof Charstring_Value)
						|| (node instanceof Omit_Value)
						|| (node instanceof Any_Value_Template)
						|| (node instanceof AnyOrOmit_Template) || (node instanceof Reference))) {
			myASTVisitor.blockIdListing = false;
		}

		if (waitForTemplateValues && (node instanceof ListOfTemplates)) {
			waitForTemplateList = false;
			//ListOfTemplates is returned twice, should be recorded only once
			blockTemplateListing= true;

		}
		
		if (waitForTemplateValues && (node instanceof NamedTemplates)) {
			waitForTemplateList = false;

			
		}

		/*if (waitForSepcValTemplate && isTemplate && (node instanceof Referenced_Value)) {
			myASTVisitor.templateIdValuePairs.put(currentTemplateNodeName,
					templateRefdVals.get(templateRefdValCounter));

			waitForSepcValTemplate = false;
			// waitForTemplateRefdVals = false;

		}*/
	}

	public void handleTemplate(IVisitableNode node) {
		Def_Template_Writer tempNode = Def_Template_Writer
				.getInstance(((Def_Template) node));

		tempNode.clearLists();
		tempNode.init();
		myASTVisitor.blockIdListing = false;

		tempNode.templateIdentifiers.addAll(templateAllIdentifiers);
		tempNode.templateRefdVals.addAll(templateRefdVals);
		tempNode.templateListValues.addAll(templateListValues);

		if (modifierValue != null) {
			tempNode.setModifierValue(modifierValue);
		}
		isTemplate=false;
		templateAllIdentifiers.clear();
		templateListValues.clear();
		templateRefdVals.clear();
		isTemplateNameSet = false;
		waitForTemplateValues = false;
		waitForModifierValue = false;
		templateRefdValCounter = -1;
		waitForTemplateRefdVals = false;
		blockTemplateListing= false;

		myASTVisitor.deleteLastBracket(myASTVisitor.currentFileName);
		myASTVisitor.visualizeNodeToJava(tempNode.getJavaSource() + "\r\n}");
		myASTVisitor.templateIDs.clear();
		myASTVisitor.templateIdValuePairs.clear();
	}

}
/******************************************************************************
 * Copyright (c) 2000-2017 Ericsson Telecom AB
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   
 *   Keremi, Andras
 *   Eros, Levente
 *   Kovacs, Gabor
 *   Meszaros, Mate Robert
 *
 ******************************************************************************/

package org.eclipse.titan.codegenerator;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.titan.designer.AST.TTCN3.definitions.Def_Template;
import org.eclipse.titan.designer.AST.TTCN3.types.Integer_Type;
import org.eclipse.titan.designer.AST.TTCN3.types.Referenced_Type;
import org.eclipse.titan.designer.parsers.CompilationTimeStamp;

public class Def_Template_Writer {
	private Def_Template templateNode;

	private StringBuilder templateString = new StringBuilder("");
	private CompilationTimeStamp compilationCounter = CompilationTimeStamp.getNewCompilationCounter();
	private String nodeName = null;

	public List<String> templateListValues = new ArrayList<String>();
	public List<String> templateIdentifiers = new ArrayList<String>();
	public List<String> templateRefdVals = new ArrayList<String>();
	private String templateNodeType = null;
	private String modifierValue = null;

	private int firstIdentifier = 0;

	private int paramCount = 0;
	private List<String> paramNames = new ArrayList<String>();
	private List<String> paramTypes = new ArrayList<String>();

	private static Map<String, Object> templateHashes = new LinkedHashMap<String, Object>();

	private Def_Template_Writer(Def_Template node) {
		super();
		this.templateNode = node;

		if (this.templateNode.getType(compilationCounter) instanceof Referenced_Type) {
			templateNodeType = ((Referenced_Type) this.templateNode.getType(compilationCounter)).getReference().getId()
					.toString();
		} else if (this.templateNode.getType(compilationCounter) instanceof Integer_Type) {
			templateNodeType = "INTEGER";

		}

		nodeName = node.getIdentifier().toString();
	}

	public static Def_Template_Writer getInstance(Def_Template node) {
		if (!templateHashes.containsKey(node.getIdentifier().toString())) {
			templateHashes.put(node.getIdentifier().toString(), new Def_Template_Writer(node));
		}
		return (Def_Template_Writer) templateHashes.get(node.getIdentifier().toString());
	}

	public void writeTemplateConstructor(String rootNodeType, String prefix) {
		if (myASTVisitor.nodeNameChildrenNamesHashMap.containsKey(rootNodeType)) {

			if (myASTVisitor.nodeNameNodeTypeHashMap.get(rootNodeType).equals("union")) {

				int unionElementId = 0;
				for (int i = 0; i < myASTVisitor.nodeNameChildrenNamesHashMap.get(rootNodeType).length; i++) {

					if (myASTVisitor.nodeNameChildrenNamesHashMap.get(rootNodeType)[i]
							.equals(templateIdentifiers.get(firstIdentifier))) {
						unionElementId = i + 1;
					}
				}

				templateString.append(prefix + "=new SC_" + unionElementId + "_" + rootNodeType + "();\r\n");

				prefix = "((SC_" + unionElementId + "_" + rootNodeType + ")value)";
			} else if (myASTVisitor.nodeNameNodeTypeHashMap.get(rootNodeType).equals("record")) {
				templateString.append(prefix + "= new " + rootNodeType + "();\r\n");

			}

			String[] childrenNodeNames = myASTVisitor.nodeNameChildrenNamesHashMap.get(rootNodeType);
			String[] childrenNodeTypes = myASTVisitor.nodeNameChildrenTypesHashMap.get(rootNodeType);

			for (int i = 0; i < childrenNodeNames.length; i++) {

				if (myASTVisitor.templateIDs.contains(childrenNodeNames[i])) {
					// idCounter++;
					if (myASTVisitor.nodeNameChildrenNamesHashMap.containsKey(childrenNodeTypes[i])
							&& !myASTVisitor.templateIdValuePairs.containsKey(childrenNodeNames[i])) {
						

						if (myASTVisitor.nodeNameNodeTypeHashMap.get(childrenNodeTypes[i]).equals("record")) {
							// do nothing, will be handled in next iteration
						} else {
							// walk childern
							
							templateString.append(
									prefix + "." + childrenNodeNames[i] + "=new " + childrenNodeTypes[i] + "();\r\n");

						}
						String prefixBackup = prefix;
						prefix = prefix.concat("." + childrenNodeNames[i]);
						writeTemplateConstructor(childrenNodeTypes[i], prefix);
						prefix = prefixBackup;

					} else {// print child element values

						// constant
						if (myASTVisitor.templateIdValuePairs.containsKey(childrenNodeNames[i])) {
							String currentvalue = myASTVisitor.templateIdValuePairs.get(childrenNodeNames[i]);

							if (myASTVisitor.nodeNameNodeTypeHashMap.containsKey(currentvalue)) {
								if (myASTVisitor.nodeNameNodeTypeHashMap.get(currentvalue).equals("constant")) {
									templateString.append(prefix + "." + childrenNodeNames[i] + "=Constants."
											+ currentvalue + "();\r\n");
								}
							} else if (paramCount > 0) {// p_Uri
								if (myASTVisitor.nodeNameNodeTypeHashMap.containsKey(childrenNodeTypes[i])) {
									for (int pCounter = 0; pCounter < paramTypes.size(); pCounter++) {
										if (childrenNodeTypes[i].equals(paramTypes.get(pCounter))) {
											templateString.append(
													prefix + "." + childrenNodeNames[i] + "=" + currentvalue + ";\r\n");
										}
									}
								}
							} else if (childrenNodeTypes[i].equals("INTEGER")) {
								templateString.append(prefix + "." + childrenNodeNames[i] + "= new INTEGER(\""
										+ currentvalue + "\");\r\n");
							}

						}

						// everything else
						if (myASTVisitor.nodeNameNodeTypeHashMap.containsKey(childrenNodeTypes[i])) {
							if (myASTVisitor.nodeNameNodeTypeHashMap.get(childrenNodeTypes[i]).equals("enum")) {
								templateString
										.append(prefix + "." + childrenNodeNames[i] + "=new " + childrenNodeTypes[i]
												+ "(\"" + myASTVisitor.templateIdValuePairs.get(childrenNodeNames[i])
												+ "\");" + "\r\n");

							} else if (myASTVisitor.nodeNameNodeTypeHashMap.get(childrenNodeTypes[i])
									.equals("CHARSTRING")) {
								templateString.append(
										prefix + "." + childrenNodeNames[i] + "=new " + childrenNodeTypes[i] + "(new "
												+ myASTVisitor.nodeNameNodeTypeHashMap.get(childrenNodeTypes[i]) + "(\""
												+ myASTVisitor.templateIdValuePairs.get(childrenNodeNames[i]) + "\"));"
												+ "\r\n");

							}

						} else if (childrenNodeTypes[i].equals("CHARSTRING")) {

							if (myASTVisitor.templateIdValuePairs.get(childrenNodeNames[i]).equals("omit")) {
								templateString.append(prefix + "." + childrenNodeNames[i] + "=new "
										+ childrenNodeTypes[i] + "();" + "\r\n");

								templateString
										.append(prefix + "." + childrenNodeNames[i] + ".omitField=true;" + "\r\n");

							} else if (myASTVisitor.templateIdValuePairs.get(childrenNodeNames[i]).equals("?")) {
								templateString.append(prefix + "." + childrenNodeNames[i] + "=new "
										+ childrenNodeTypes[i] + "();" + "\r\n");

								templateString.append(prefix + "." + childrenNodeNames[i] + ".anyField=true;" + "\r\n");
							} else if (myASTVisitor.templateIdValuePairs.get(childrenNodeNames[i]).equals("*")) {
								templateString.append(prefix + "." + childrenNodeNames[i] + "=new "
										+ childrenNodeTypes[i] + "();" + "\r\n");

								templateString.append(prefix + "." + childrenNodeNames[i] + ".anyField=true;" + "\r\n");
							} else {

								templateString
										.append(prefix + "." + childrenNodeNames[i] + "=new " + childrenNodeTypes[i]
												+ "(\"" + myASTVisitor.templateIdValuePairs.get(childrenNodeNames[i])
												+ "\");" + "\r\n");
							}
						}
						if (myASTVisitor.nodeNameChildrenNamesHashMap.containsKey(childrenNodeTypes[i])) {
							if (myASTVisitor.templateIdValuePairs.containsKey(childrenNodeNames[i])
									|| myASTVisitor.templateIdValuePairs.containsKey(childrenNodeNames[i])) {
								if (myASTVisitor.templateIdValuePairs.get(childrenNodeNames[i]).equals("?")) {
									templateString.append(prefix + "." + childrenNodeNames[i] + "=new "
											+ childrenNodeTypes[i] + "();" + "\r\n");

									templateString
											.append(prefix + "." + childrenNodeNames[i] + ".anyField=true;" + "\r\n");
								} else if (myASTVisitor.templateIdValuePairs.get(childrenNodeNames[i]).equals("*")) {
									templateString.append(prefix + "." + childrenNodeNames[i] + "=new "
											+ childrenNodeTypes[i] + "();" + "\r\n");

									templateString.append(
											prefix + "." + childrenNodeNames[i] + ".anyOrOmitField=true;" + "\r\n");
								}
							}
						}
					}
				}
				if (templateListValues.size() > 0) {
					if (childrenNodeTypes[i].equals("INTEGER")) {
						templateString.append(prefix + "." + childrenNodeNames[i] + "= new INTEGER(\""
								+ templateListValues.get(i) + "\");\r\n");
					}
				}

			}
		} else if (rootNodeType.equals("INTEGER")) {
			String integerValue = myASTVisitor.templateIdValuePairs.get(nodeName);
			templateString.append("value=new INTEGER(\"" + integerValue + "\");\r\n");
		}

	}

	public void writeModifierTemplateConstructor(String rootNodeType, String prefix) {
		if (myASTVisitor.nodeNameChildrenNamesHashMap.containsKey(rootNodeType)) {

			if (myASTVisitor.nodeNameNodeTypeHashMap.get(rootNodeType).equals("union")) {

				int unionElementId = 0;
				for (int i = 0; i < myASTVisitor.nodeNameChildrenNamesHashMap.get(rootNodeType).length; i++) {

					if (myASTVisitor.nodeNameChildrenNamesHashMap.get(rootNodeType)[i]
							.equals(templateIdentifiers.get(firstIdentifier))) {
						unionElementId = i + 1;
					}
				}

				templateString.append(prefix + "= " + modifierValue + "();\r\n");

				prefix = "((SC_" + unionElementId + "_" + rootNodeType + ")value)";

				templateString.append(
						"if(value==null) value= new " + "SC_" + unionElementId + "_" + rootNodeType + "();\r\n");

				templateString.append("if(value.anyField) value.anyField=false;\r\n");

				templateString.append("if(value.omitField) value.omitField=false;\r\n");

				templateString.append("if(value.anyOrOmitField) value.anyOrOmitField=false;\r\n\r\n");

			}

			String[] childrenNodeNames = myASTVisitor.nodeNameChildrenNamesHashMap.get(rootNodeType);
			String[] childrenNodeTypes = myASTVisitor.nodeNameChildrenTypesHashMap.get(rootNodeType);

			for (int i = 0; i < childrenNodeNames.length; i++) {
				if (myASTVisitor.templateIDs.contains(childrenNodeNames[i])) {
					if (myASTVisitor.nodeNameChildrenNamesHashMap.containsKey(childrenNodeTypes[i])
							&& !myASTVisitor.templateIdValuePairs.containsKey(childrenNodeNames[i])) {

						// walk childern

						modifierTemplateIfWriter(prefix, "=new " + childrenNodeTypes[i] + "();\r\n",
								childrenNodeNames[i], false, false, false, false);

						String prefixBackup = prefix;
						prefix = prefix.concat("." + childrenNodeNames[i]);

						writeModifierTemplateConstructor(childrenNodeTypes[i], prefix);

						prefix = prefixBackup;

					} // print child element values

					// constant
					if (myASTVisitor.templateIdValuePairs.containsKey(childrenNodeNames[i])) {
						String currentvalue = myASTVisitor.templateIdValuePairs.get(childrenNodeNames[i]);
						if (myASTVisitor.nodeNameNodeTypeHashMap.containsKey(currentvalue)) {
							if (myASTVisitor.nodeNameNodeTypeHashMap.get(currentvalue).equals("constant")) {
								/*
								 * templateString.append(prefix + "." +
								 * childrenNodeNames[i] + "=Constants." +
								 * currentvalue + "();\r\n");
								 */
							}
						} else if (paramCount > 0) {// p_Uri
							if (myASTVisitor.nodeNameNodeTypeHashMap.containsKey(childrenNodeTypes[i])) {
								for (int pCounter = 0; pCounter < paramTypes.size(); pCounter++) {
									if (childrenNodeTypes[i].equals(paramTypes.get(pCounter))) {
										modifierTemplateIfWriter(prefix, "=" + currentvalue + ";\r\n",
												childrenNodeNames[i], true, false, false, false);

									}
								}
							}
						}
					}

					// everything else
					if (myASTVisitor.nodeNameNodeTypeHashMap.containsKey(childrenNodeTypes[i])) {
						if (myASTVisitor.nodeNameNodeTypeHashMap.get(childrenNodeTypes[i]).equals("enum")) {
							modifierTemplateIfWriter(prefix,
									"=new " + childrenNodeTypes[i] + "(\""
											+ myASTVisitor.templateIdValuePairs.get(childrenNodeNames[i]) + "\");\r\n",
									childrenNodeNames[i], true, false, false, false);

						} else if (myASTVisitor.nodeNameNodeTypeHashMap.get(childrenNodeTypes[i])
								.equals("CHARSTRING")) {
							// TODO CHARSTRING

						}

					} else if (childrenNodeTypes[i].equals("CHARSTRING")) {

						if (myASTVisitor.templateIdValuePairs.get(childrenNodeNames[i]).equals("omit")) {
							modifierTemplateIfWriter(prefix, "=null;\r\n", childrenNodeNames[i], true, false, true,
									false);

						} else if (myASTVisitor.templateIdValuePairs.get(childrenNodeNames[i]).equals("?")) {
							modifierTemplateIfWriter(prefix, "=null;\r\n", childrenNodeNames[i], true, true, false,
									false);
						} else if (myASTVisitor.templateIdValuePairs.get(childrenNodeNames[i]).equals("*")) {
							modifierTemplateIfWriter(prefix, "=null;\r\n", childrenNodeNames[i], true, false, false,
									true);
						} else {
							// TODO rest
						}
					}
					if (myASTVisitor.nodeNameChildrenNamesHashMap.containsKey(childrenNodeTypes[i])) {
						if (myASTVisitor.templateIdValuePairs.containsKey(childrenNodeNames[i])
								|| myASTVisitor.templateIdValuePairs.containsKey(childrenNodeNames[i])) {
							if (myASTVisitor.templateIdValuePairs.get(childrenNodeNames[i]).equals("?")) {
								modifierTemplateIfWriter(prefix, "=null;\r\n", childrenNodeNames[i], true, true, false,
										false);
							} else if (myASTVisitor.templateIdValuePairs.get(childrenNodeNames[i]).equals("*")) {
								modifierTemplateIfWriter(prefix, "=null;\r\n", childrenNodeNames[i], true, false, false,
										true);
							}
						}
					}
				}
			}
		} else if (rootNodeType.equals("INTEGER")) {
			String integerValue = myASTVisitor.templateIdValuePairs.get(nodeName);

			 if (integerValue.contains(".")) {
				 templateString.append("value="+integerValue + ";\r\n");
			}else{
				templateString.append("value=new INTEGER(\"" + integerValue + "\");\r\n");
			}

		}
	}

	public void modifierTemplateIfWriter(String preText, String newConstructor, String elementName, boolean isVvalue,
			boolean isAnyField, boolean isOmitFields, boolean isAnyOrOmitField) {

		if (!isVvalue) {
			templateString.append(
					"if(" + preText + "." + elementName + "==null) " + preText + "." + elementName + newConstructor);
		} else {
			templateString.append(preText + "." + elementName + newConstructor);
		}

		if (!isAnyField) {
			templateString.append("if(" + preText + "." + elementName + ".anyField) " + preText + "." + elementName
					+ ".anyField=false;" + "\r\n");
		} else {
			templateString.append("if(" + preText + "." + elementName + ".anyField) " + preText + "." + elementName
					+ ".anyField=true;" + "\r\n");
		}

		if (!isOmitFields) {
			templateString.append("if(" + preText + "." + elementName + ".omitField) " + preText + "." + elementName
					+ ".omitField=false;" + "\r\n");
		} else {
			templateString.append("if(" + preText + "." + elementName + ".omitField) " + preText + "." + elementName
					+ ".omitField=true;" + "\r\n");
		}

		if (!isAnyOrOmitField) {
			templateString.append("if(" + preText + "." + elementName + ".anyOrOmitField) " + preText + "."
					+ elementName + ".anyOrOmitField=false;" + "\r\n\r\n");
		} else {
			templateString.append("if(" + preText + "." + elementName + ".anyOrOmitField) " + preText + "."
					+ elementName + ".anyOrOmitField=true;" + "\r\n\r\n");
		}
	}

	public void clearLists() {
		templateListValues.clear();
		templateIdentifiers.clear();
		templateRefdVals.clear();
		paramNames.clear();
		paramTypes.clear();

	}

	public void init() {

		firstIdentifier = 1;
		if (templateNode.getFormalParameterList() != null) {
			paramCount = templateNode.getFormalParameterList().getNofParameters();
			for (int i = 0; i < paramCount; i++) {
				paramNames.add(templateNode.getFormalParameterList().getParameterByIndex(i).getIdentifier().toString());
				if (templateNode.getFormalParameterList().getParameterByIndex(i)
						.getType(compilationCounter) instanceof Referenced_Type) {

					paramTypes.add(((Referenced_Type) templateNode.getFormalParameterList().getParameterByIndex(i)
							.getType(compilationCounter)).getReference().getId().toString());
				} else if(templateNode.getFormalParameterList().getParameterByIndex(i)
						.getType(compilationCounter) instanceof Integer_Type){
					paramTypes.add("INTEGER");
				}
				
				
				firstIdentifier++;
			}
		}
	}

	public String getJavaSource() {

		AstWalkerJava.logToConsole("	Starting processing:  Template " + nodeName);

		templateString.append("public static " + templateNodeType + " " + nodeName + "(");

		for (int i = 0; i < paramCount; i++) {
			templateString.append(paramTypes.get(i) + " " + paramNames.get(i));
			if(i<paramCount-1){
				templateString.append(" , ");
			}

		}

		templateString.append("){\r\n");
		templateString.append(templateNodeType + " value;\r\n");

		if ((modifierValue == null)) {
			writeTemplateConstructor(templateNodeType, "value");
		} else {
			writeModifierTemplateConstructor(templateNodeType, "value");

		}

		templateString.append("return value;\r\n");
		templateString.append("}\r\n");
		String returnString = templateString.toString();
		modifierValue = null;

		templateString.setLength(0);

		AstWalkerJava.logToConsole("	Finished processing:  Template " + nodeName);

		return returnString;

	}

	public void setModifierValue(String modifierValue) {
		if ((!nodeName.equals(modifierValue)) && (!templateNodeType.equals(modifierValue))) {
			if (paramTypes.size() > 0) {
				for (int i = 0; i < paramTypes.size(); i++) {
					if (!paramTypes.get(i).equals(modifierValue)) {
						this.modifierValue = modifierValue;
					}
				}
			} else {
				this.modifierValue = modifierValue;
			}

		}

	}
}
/******************************************************************************
 * Copyright (c) 2000-2017 Ericsson Telecom AB
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   
 *   Keremi, Andras
 *   Eros, Levente
 *   Kovacs, Gabor
 *   Meszaros, Mate Robert
 *
 ******************************************************************************/

package org.eclipse.titan.codegenerator;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.titan.designer.AST.TTCN3.definitions.Def_Testcase;
import org.eclipse.titan.designer.AST.TTCN3.definitions.Def_Timer;
import org.eclipse.titan.designer.AST.TTCN3.statements.Alt_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.Assignment_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.Connect_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.Definition_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.Disconnect_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.DoWhile_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.Done_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.If_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.Map_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.Receive_Port_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.Send_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.Setverdict_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.StatementBlock;
import org.eclipse.titan.designer.AST.TTCN3.statements.StatementBlock_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.Unknown_Start_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.Unknown_Stop_Statement;
import org.eclipse.titan.designer.AST.TTCN3.templates.SpecificValue_Template;
import org.eclipse.titan.designer.AST.TTCN3.values.Bitstring_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Boolean_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Charstring_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Integer_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Octetstring_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Referenced_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Undefined_LowerIdentifier_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Verdict_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.AddExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.And4bExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.ComponentCreateExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.DivideExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.ModuloExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.MultiplyExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.Not4bExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.Or4bExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.RemainderExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.RotateLeftExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.RotateRightExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.ShiftLeftExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.ShiftRightExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.StringConcatenationExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.SubstractExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.UnaryMinusExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.Xor4bExpression;

public class Def_Testcase_Writer {
	private Def_Testcase testCaseNode;
	private StringBuilder testCaseString = new StringBuilder("");
	/*
	 * private CompilationTimeStamp compilationCounter = CompilationTimeStamp
	 * .getNewCompilationCounter();
	 */

	public String nodeName = null;

	private static Map<String, Object> testcaseHashes = new LinkedHashMap<String, Object>();
	public String testCaseRunsOn = null;
	private String currentTimerName = null;

	public StatementBlock tcMainStatementBlock;
	public int doWhileCounter = -1;
	public int sendCounter = -1;
	public int assignCounter = -1;
	private int createCounter = -1;
	private int startStatementCounter = -1;
	private int stopStatementCounter = -1;
	private int connectCounter = -1;
	private int currentCounterValue = 0;
	private int logCreateCounter = 0;
	private int currentMapValueIndex = 0;
	private int defCounter = -1;
	private int defValueCounter = -1;
	private int mapCounter = 0;
	private int tcIfConditionCounter = -1;

	private int disconnectCounter = -1;
	private int altStatementCounter = -1;

	private boolean blockWriter = false;
	private boolean isThereAStartedTimer = false;

	public static List<String> sendPortReference = new ArrayList<String>();
	public static List<String> sendParameter = new ArrayList<String>();
	public static List<String> sendParameterType = new ArrayList<String>();
	
	public List<String> doWhileExpressions = new ArrayList<String>();
	
	public List<String> tcVars = new ArrayList<String>();
	public List<String> tcVarTypes = new ArrayList<String>();
	public List<String> tcVarValues = new ArrayList<String>();
	public List<String> tcAssignIdentifiers = new ArrayList<String>();
	public List<String> tcAssignValues = new ArrayList<String>();
	public List<String> tcCreateValues = new ArrayList<String>();
	public List<String> tcCreateCounter = new ArrayList<String>();
	public List<String> tcConnectValues = new ArrayList<String>();
	public List<String> tcStartIdentifiers = new ArrayList<String>();
	public List<String> tcStartCounter = new ArrayList<String>();
	public List<String> tcMapValues = new ArrayList<String>();
	public List<String> tcMapCounter = new ArrayList<String>();
	public List<String> tcIfConditions = new ArrayList<String>();
	public List<String> testCaseStartValueParameters = new ArrayList<String>();
	public List<String> tcDisconnectValues = new ArrayList<String>();
	public List<Boolean> tcVarIsConstant = new ArrayList<Boolean>();
	public List<Boolean> tcVarIsTemplate = new ArrayList<Boolean>();
	public List<Boolean> tcValueIsAValueReference = new ArrayList<Boolean>();
	public List<Boolean> tcValueTypeIsAReference = new ArrayList<Boolean>();

	public List<String> tcStopIdentifiers = new ArrayList<String>();
	public List<String> tcStopCounter = new ArrayList<String>();
	public List<String> testCaseStopValueParameters = new ArrayList<String>();

	public List<Def_AltStatement_Writer> altStatements = new ArrayList<Def_AltStatement_Writer>();

	public int receiveCounter = -1;

	public List<String> receivePortReference = new ArrayList<String>();
	public List<String> receiveValue = new ArrayList<String>();
	public List<String> receiveAnyValValue = new ArrayList<String>();
	public List<String> receiveType = new ArrayList<String>();
	public List<StatementBlock> receiveStatements = new ArrayList<StatementBlock>();

	public List<Boolean> nodeVarIsRecord = new ArrayList<Boolean>();

	public int structSize = 0;
	public int currentRecordCounter = 0;
	private boolean blockStatementBlockStatementWriter = false;

	private Def_Testcase_Writer(Def_Testcase typeNode) {
		super();
		this.testCaseNode = typeNode;
		nodeName = typeNode.getIdentifier().toString();

	}

	public static Def_Testcase_Writer getInstance(Def_Testcase typeNode) {
		if (!testcaseHashes.containsKey(typeNode.getIdentifier().toString())) {
			testcaseHashes.put(typeNode.getIdentifier().toString(),
					new Def_Testcase_Writer(typeNode));
		}
		return (Def_Testcase_Writer) testcaseHashes.get(typeNode
				.getIdentifier().toString());
	}

	public String writeTestcaseFile(Def_Testcase testNode) {
		StringBuilder testCaseString = new StringBuilder("\r\n");

		testCaseString.append("public class " + nodeName
				+ " implements Runnable{ " + "\r\n");
		testCaseString.append("	" + "\r\n");
		testCaseString.append("	private " + testCaseRunsOn + " component;"
				+ "\r\n");
		testCaseString.append("		public " + nodeName + "(" + testCaseRunsOn
				+ " c){" + "\r\n");
		testCaseString.append("	component = c;" + "\r\n");
		testCaseString.append("	}" + "\r\n");
		testCaseString.append("		public void run(){" + "\r\n");
		testCaseString.append("			component." + nodeName + "();" + "\r\n");
		testCaseString.append("			component.hc.finished(component, \""
				+ nodeName + "\");" + "\r\n");
		testCaseString.append("		}" + "\r\n");
		testCaseString.append("	}" + "\r\n");

		return testCaseString.toString();
	}

	public void writeTestCaseFunctionHeader(StatementBlock tcStatementBlock) {
		testCaseString.append("\r\n");
		testCaseString.append("public void " + nodeName + "(){" + "\r\n");

		testCaseString.append("String sourcefilename = \""
				+ testCaseNode.getLocation().getFile().getFullPath()
						.lastSegment() + "\";" + "\r\n");
		testCaseString.append("int rownum="
				+ tcStatementBlock.getLocation().getLine() + ";\r\n");
		testCaseString.append("while(!created);" + "\r\n");

		testCaseString
				.append("TTCN3Logger.writeLog(\"mtc\", \"PARALLEL\", sourcefilename, rownum, \"testcase\", \""
						+ nodeName
						+ "\", \"Testcase started on mtc\", false);"
						+ "\r\n");
	}

	public String getJavaSource() {
		testCaseString.setLength(0);
		AstWalkerJava.logToConsole("	Starting processing:  Testcase "
				+ nodeName);

		this.writeTestCaseFunctionHeader(tcMainStatementBlock);

		this.writeTestCaseFunction(tcMainStatementBlock);

		String returnString = testCaseString.toString();
		testCaseString.setLength(0);

		AstWalkerJava.logToConsole("	Finished processing:  Testcase "
				+ nodeName);

		return returnString;
	}

	public String writeTestCaseFunction(StatementBlock tcStatementBlock) {

		int testcaseSize = tcStatementBlock.getSize();

		for (int j = 0; j < testcaseSize; j++) {

			if (tcStatementBlock.getStatementByIndex(j) instanceof Definition_Statement) {

				Definition_Statement tc_defStatement = (Definition_Statement) tcStatementBlock
						.getStatementByIndex(j);
				defCounter++;
				defValueCounter++;
				writeDefinitionStatement(tc_defStatement);

			} else if (tcStatementBlock.getStatementByIndex(j) instanceof Assignment_Statement) {
				Assignment_Statement tc_assignStatement = (Assignment_Statement) tcStatementBlock
						.getStatementByIndex(j);

				assignCounter++;

				testCaseString
						.append(writeAssignmentStatement(tc_assignStatement));

			} else if (tcStatementBlock.getStatementByIndex(j) instanceof Connect_Statement) {
				Connect_Statement tc_connectStatement = (Connect_Statement) tcStatementBlock
						.getStatementByIndex(j);
				connectCounter++;

				writeConnectStatement(tc_connectStatement);

			} else if (tcStatementBlock.getStatementByIndex(j) instanceof Unknown_Start_Statement) {
				Unknown_Start_Statement tc_startStatement = (Unknown_Start_Statement) tcStatementBlock
						.getStatementByIndex(j);

				writeUnknownStartStatement(tc_startStatement);

			} else if (tcStatementBlock.getStatementByIndex(j) instanceof Done_Statement) {

				testCaseString.append("hc.done(\"all component\");" + "\r\n");
				// TODO: where is all coming from?

			} else if (tcStatementBlock.getStatementByIndex(j) instanceof Map_Statement) {
				Map_Statement tc_mapStatement = (Map_Statement) tcStatementBlock
						.getStatementByIndex(j);
				mapCounter++;

				writeMapStatement(tc_mapStatement);

			} else if (tcStatementBlock.getStatementByIndex(j) instanceof If_Statement) {
				If_Statement tc_ifStatement = (If_Statement) tcStatementBlock
						.getStatementByIndex(j);

				tcIfConditionCounter++;

				writeIfStatement(tc_ifStatement);

			} else if (tcStatementBlock.getStatementByIndex(j) instanceof Setverdict_Statement) {

				Setverdict_Statement tc_setVerdictStatement = (Setverdict_Statement) tcStatementBlock
						.getStatementByIndex(j);

				writeSetVerdictStatement(tc_setVerdictStatement);

			} else if (tcStatementBlock.getStatementByIndex(j) instanceof DoWhile_Statement) {
				doWhileCounter++;
				DoWhile_Statement doWhileStatement=(DoWhile_Statement)tcStatementBlock.getStatementByIndex(j);
				String test=doWhileStatement.getExpression().toString();
				
				testCaseString.append("do{"+"\r\n");
				
				this.writeTestCaseFunction(doWhileStatement.getStatementBlock());
				
				testCaseString.append("while("+doWhileExpressions.get(doWhileCounter)+".getValue());\r\n");
				
			}else if (tcStatementBlock.getStatementByIndex(j) instanceof Send_Statement) {
				Send_Statement tc_SendStatement = (Send_Statement) tcStatementBlock
						.getStatementByIndex(j);

				sendCounter++;

				testCaseString.append(writeSendStatement(tc_SendStatement));

			} else if (tcStatementBlock.getStatementByIndex(j) instanceof Receive_Port_Statement) {
				Receive_Port_Statement tc_ReceiveStatement = (Receive_Port_Statement) tcStatementBlock
						.getStatementByIndex(j);

				receiveCounter++;

				blockStatementBlockStatementWriter = true;

				testCaseString
						.append(writeReceiveStatement(tc_ReceiveStatement));

			} else if (tcStatementBlock.getStatementByIndex(j) instanceof Unknown_Stop_Statement) {
				Unknown_Stop_Statement tc_StopStatement = (Unknown_Stop_Statement) tcStatementBlock
						.getStatementByIndex(j);

				writeUnknownStopStatement(tc_StopStatement);

			} else if (tcStatementBlock.getStatementByIndex(j) instanceof Alt_Statement) {

				altStatementCounter++;
				altStatements.get(altStatementCounter).setTimerInfo(
						isThereAStartedTimer, currentTimerName);

				testCaseString.append(altStatements.get(altStatementCounter)
						.getJavaSource());

			} else if (tcStatementBlock.getStatementByIndex(j) instanceof Disconnect_Statement) {
				Disconnect_Statement tc_disconnectStatement = (Disconnect_Statement) tcStatementBlock
						.getStatementByIndex(j);
				disconnectCounter++;

				writeDisconnectStatement(tc_disconnectStatement);

			} else if ((tcStatementBlock.getStatementByIndex(j) instanceof StatementBlock_Statement)
					&& !blockStatementBlockStatementWriter) {
				StatementBlock_Statement tc_statementBlockStatement = (StatementBlock_Statement) tcStatementBlock
						.getStatementByIndex(j);
				blockStatementBlockStatementWriter = false;
				testCaseString.append("{\r\n");
				blockWriter = true;
				writeTestCaseFunction(tc_statementBlockStatement
						.getStatementBlock());
				blockWriter = false;
				testCaseString.append("}\r\n");

			}
		}

		if (!blockWriter) {
			testCaseString.append("}" + "\r\n");
		}

		return testCaseString.toString();
	}

	public void writeDefinitionStatement(Definition_Statement tc_defStatement) {
		if (tc_defStatement.getDefinition() instanceof Def_Timer) {
			Def_Timer def_Timer = (Def_Timer) tc_defStatement.getDefinition();

			testCaseString.append("rownum=" + def_Timer.getLocation().getLine()
					+ ";\r\n");
			testCaseString.append("Timer "
					+ def_Timer.getIdentifier().toString()
					+ " = new Timer(" + tcVarValues.get(defCounter)
					+ ");\r\n");

			testCaseString
					.append("TTCN3Logger.writeLog(\"mtc\", \"TIMEROP\", sourcefilename, rownum, \"function\", \""
							+ nodeName
							+ "\", \"Timer "
							+ def_Timer.getIdentifier().toString()
							+ " set to "
							+ tcVarValues.get(defCounter) + ".\", false);" + "\r\n");

		} else if (tcVarTypes.get(defCounter).equals("BITSTRING")) {

			testCaseString.append("rownum="
					+ tc_defStatement.getLocation().getLine() + ";\r\n");

			if (tcVarIsConstant.get(defCounter)) {
				testCaseString.append("final ");
			}

			if (tcVarIsTemplate.get(defCounter)) {
				testCaseString.append("template ");
			}

			if (tcVarValues.get(defValueCounter) == null) {
				testCaseString.append(tcVarTypes.get(defCounter) + " "
						+ tcVars.get(defCounter) + "=new BITSTRING();\r\n");
				// TODO: add logging here
			} else if (tcValueIsAValueReference.get(defCounter)) {
				testCaseString.append(tcVarTypes.get(defCounter) + " "
						+ tcVars.get(defCounter) + "="
						+ tcVarValues.get(defValueCounter) + ";\r\n");
				// TODO: add logging here
			} else {
				testCaseString.append(tcVarTypes.get(defCounter) + " "
						+ tcVars.get(defCounter) + "=new BITSTRING(\""
						+ tcVarValues.get(defValueCounter) + "\");\r\n");
				// TODO: add logging here
			}

		} else if (tcVarTypes.get(defCounter).equals("INTEGER")) {

			testCaseString.append("rownum="
					+ tc_defStatement.getLocation().getLine() + ";\r\n");
			if (tcVarIsConstant.get(defCounter)) {
				testCaseString.append("final ");
			}

			if (tcVarIsTemplate.get(defCounter)) {
				testCaseString.append("template ");
			}

			if (tcVarValues.get(defValueCounter) == null) {
				testCaseString.append(tcVarTypes.get(defCounter) + " "
						+ tcVars.get(defCounter) + "=new INTEGER();\r\n");
				// TODO: add logging here
			} else if (tcValueIsAValueReference.get(defCounter)) {
				testCaseString.append(tcVarTypes.get(defCounter) + " "
						+ tcVars.get(defCounter) + "="
						+ tcVarValues.get(defValueCounter) + ";\r\n");
				// TODO: add logging here
			} else {
				testCaseString.append(tcVarTypes.get(defCounter) + " "
						+ tcVars.get(defCounter)
						+ "=new INTEGER(\""
						+ tcVarValues.get(defValueCounter) + "\");\r\n");
				// TODO: add logging here
			}

		} else if (tcVarTypes.get(defCounter).equals("CHARSTRING")) {

			testCaseString.append("rownum="
					+ tc_defStatement.getLocation().getLine() + ";\r\n");

			if (tcVarIsConstant.get(defCounter)) {
				testCaseString.append("final ");
			}

			if (tcVarIsTemplate.get(defCounter)) {
				testCaseString.append("template ");
			}

			if (tcVarValues.get(defValueCounter) == null) {
				testCaseString.append(tcVarTypes.get(defCounter) + " "
						+ tcVars.get(defCounter) + "=new CHARSTRING();\r\n");
				// TODO: add logging here
			} else if (tcValueIsAValueReference.get(defCounter)) {
				testCaseString.append(tcVarTypes.get(defCounter) + " "
						+ tcVars.get(defCounter) + "="
						+ tcVarValues.get(defValueCounter) + ";\r\n");
				// TODO: add logging here
			} else {
				testCaseString.append(tcVarTypes.get(defCounter) + " "
						+ tcVars.get(defCounter) + "=new CHARSTRING(\""
						+ tcVarValues.get(defValueCounter) + "\");\r\n");
				// TODO: add logging here
			}

		} else if (tcVarTypes.get(defCounter).equals("OCTETSTRING")) {
			testCaseString
					.append("rownum = ")
					.append(tc_defStatement.getLocation().getLine())
					.append(";")
					.append("\r\n");
			// TODO : replace each "\r\n" with System.lineSeparator() to make it cross-platform

			if (tcVarIsConstant.get(defCounter)) {
				testCaseString.append("final ");
			}

			if (tcVarIsTemplate.get(defCounter)) {
				testCaseString.append("template ");
			}

			if (tcVarValues.get(defValueCounter) == null) {
				testCaseString.append(tcVarTypes.get(defCounter) + " "
						+ tcVars.get(defCounter) + "=new OCTETSTRING();\r\n");
				// TODO: add logging here
			} else if (tcValueIsAValueReference.get(defCounter)) {
				testCaseString.append(tcVarTypes.get(defCounter) + " "
						+ tcVars.get(defCounter) + "="
						+ tcVarValues.get(defValueCounter) + ";\r\n");
				// TODO: add logging here
			} else {
				testCaseString.append(tcVarTypes.get(defCounter) + " "
						+ tcVars.get(defCounter) + "=new OCTETSTRING(\""
						+ tcVarValues.get(defValueCounter) + "\");\r\n");
				// TODO: add logging here
			}

		} else if (tcVarTypes.get(defCounter).equals("BOOLEAN")) {

			testCaseString.append("rownum="
					+ tc_defStatement.getLocation().getLine() + ";\r\n");

			if (tcVarIsConstant.get(defCounter)) {
				testCaseString.append("final ");
			}

			if (tcVarIsTemplate.get(defCounter)) {
				testCaseString.append("template ");
			}

			if (tcVarValues.get(defValueCounter) == null) {
				testCaseString.append(tcVarTypes.get(defCounter) + " "
						+ tcVars.get(defCounter) + "=new BOOLEAN();\r\n");
				// TODO: add logging here
			} else if (tcValueIsAValueReference.get(defCounter)) {
				testCaseString.append(tcVarTypes.get(defCounter) + " "
						+ tcVars.get(defCounter) + "="
						+ tcVarValues.get(defValueCounter) + ";\r\n");
				// TODO: add logging here
			} else {
				testCaseString.append(tcVarTypes.get(defCounter) + " "
						+ tcVars.get(defCounter) + "=new BOOLEAN("
						+ tcVarValues.get(defValueCounter) + ");\r\n");
				// TODO: add logging here
			}

		}else if (tcVarTypes.get(defCounter).equals("FLOAT")) {

			testCaseString.append("rownum="
					+ tc_defStatement.getLocation().getLine() + ";\r\n");

			if (tcVarIsConstant.get(defCounter)) {
				testCaseString.append("final ");
			}

			if (tcVarIsTemplate.get(defCounter)) {
				testCaseString.append("template ");
			}

			if (tcVarValues.get(defValueCounter) == null) {
				testCaseString.append(tcVarTypes.get(defCounter) + " "
						+ tcVars.get(defCounter) + "=new FLOAT();\r\n");
				// TODO: add logging here
			} else if (tcValueIsAValueReference.get(defCounter)) {
				testCaseString.append(tcVarTypes.get(defCounter) + " "
						+ tcVars.get(defCounter) + "="
						+ tcVarValues.get(defValueCounter) + ";\r\n");
				// TODO: add logging here
			} else {
				testCaseString.append(tcVarTypes.get(defCounter) + " "
						+ tcVars.get(defCounter) + "=new FLOAT("
						+ tcVarValues.get(defValueCounter) + ");\r\n");
				// TODO: add logging here
			}

		} else if (nodeVarIsRecord.get(defCounter)) {

			testCaseString.append("rownum="
					+ tc_defStatement.getLocation().getLine() + ";\r\n");

			testCaseString.append(tcVarTypes.get(defCounter) + " "
					+ tcVars.get(defCounter) + "= new "
					+ tcVarTypes.get(defCounter) + "();\r\n");

			int childSize = myASTVisitor.nodeNameChildrenNamesHashMap
					.get(tcVarTypes.get(defCounter)).length;

			for (int i = 0; i < childSize; i++) {

				String childType = myASTVisitor.nodeNameChildrenTypesHashMap
						.get(tcVarTypes.get(defCounter))[i];
				String childName = myASTVisitor.nodeNameChildrenNamesHashMap
						.get(tcVarTypes.get(defCounter))[i];

				testCaseString.append("rownum="
						+ tc_defStatement.getLocation().getLine() + ";\r\n");

				writeRecordChildren(childType, childName);

				if (i + 1 < childSize) {
					defValueCounter++;
				}
			}

		} else if (tcValueTypeIsAReference.get(defCounter)) {
			testCaseString.append("rownum="
					+ tc_defStatement.getLocation().getLine() + ";\r\n");

			if (tcVarIsConstant.get(defCounter)) {
				testCaseString.append("final ");
			}

			if (tcVarIsTemplate.get(defCounter)) {
				testCaseString.append("template ");
			}

			if (tcVarValues.get(defValueCounter) == null) {
				testCaseString.append(tcVarTypes.get(defCounter) + " "
						+ tcVars.get(defCounter) + ";\r\n");
				// TODO: add logging here
			} else if (tcValueIsAValueReference.get(defCounter)) {

				if (myASTVisitor.nodeNameNodeTypeHashMap.containsKey(tcVarTypes
						.get(defCounter))) {
					if (myASTVisitor.nodeNameNodeTypeHashMap.get(
							tcVarTypes.get(defCounter)).equals("enum")) {
						testCaseString
								.append(tcVarTypes.get(defCounter) + " "
										+ tcVars.get(defCounter) + "= new "
										+ tcVarTypes.get(defCounter) + "(\""
										+ tcVarValues.get(defValueCounter)
										+ "\");\r\n");
					}
				} else {

					testCaseString.append(tcVarTypes.get(defCounter) + " "
							+ tcVars.get(defCounter) + "="
							+ tcVarValues.get(defValueCounter) + ";\r\n");
				}
				// TODO: add logging here
			} else {
				testCaseString.append(tcVarTypes.get(defCounter) + " "
						+ tcVars.get(defCounter) + "="
						+ tcVarValues.get(defValueCounter) + ";\r\n");
				// TODO: add logging here
			}
		}

	}

	public void writeRecordChildren(String childType, String childName) {

		if (childType.equals("INTEGER")) {
			testCaseString.append(tcVars.get(defCounter) + "." + childName
					+ "="
					+ tcVarValues.get(defValueCounter) + ";\r\n");
		} else if (childType.equals("CHARSTRING")) {

		} else if (childType.equals("BITSTRING")) {

		} else if (childType.equals("BOOLEAN")) {

		}
	}

	public String writeAssignmentStatement(
			Assignment_Statement tc_assignStatement) {

		StringBuilder testCaseString = new StringBuilder("");

		if (tc_assignStatement.getTemplate() instanceof SpecificValue_Template) {
			SpecificValue_Template specValTemplate = (SpecificValue_Template) tc_assignStatement
					.getTemplate();
			if (specValTemplate.getSpecificValue() instanceof ComponentCreateExpression) {
				ComponentCreateExpression componenetCreateExp = (ComponentCreateExpression) specValTemplate
						.getSpecificValue();

				createCounter++;
				logCreateCounter++;
				int logSizeValue = 1;
				while (tcCreateCounter.get(logCreateCounter).equals(
						String.valueOf(createCounter))) {
					logCreateCounter++;
					logSizeValue++;
					if (tcCreateCounter.size() == (logCreateCounter)) {
						break;
					}

				}
				String[] logValues = new String[logSizeValue];
				int logWriteCounter = 0;
				testCaseString
						.append("rownum="
								+ componenetCreateExp.getLocation().getLine()
								+ ";\r\n");
				
				if(tcAssignIdentifiers.get(assignCounter).endsWith("=")){
					tcAssignIdentifiers.set(assignCounter,tcAssignIdentifiers.get(assignCounter).substring(0, tcAssignIdentifiers.get(assignCounter).length()-1) );
				}
				
				testCaseString.append("hc.create(" + "\""
						+ tcAssignIdentifiers.get(assignCounter) + "\"");
				logValues[logWriteCounter] = tcAssignIdentifiers
						.get(assignCounter);
				
				
				currentCounterValue++;
				//assignCounter++;
				logWriteCounter++;
				while (tcCreateCounter.get(currentCounterValue).equals(
						String.valueOf(createCounter))) {
					testCaseString.append(",\""
							+ tcCreateValues.get(currentCounterValue) + "\"");

					logValues[logWriteCounter] = tcCreateValues
							.get(currentCounterValue);
					logWriteCounter++;
					currentCounterValue++;

					if (tcCreateCounter.size() == (currentCounterValue)) {
						break;
					}

				}
				testCaseString.append("); " + "\r\n");

				testCaseString
						.append("TTCN3Logger.writeLog(\"mtc\", \"PARALLEL\", sourcefilename, rownum, \"testcase\", \""
								+ nodeName
								+ "\", \"Starting PTC "
								+ logValues[0]
								+ " type "
								+ logValues[1]
								+ " on "
								+ logValues[2]
								+ "\", false);"
								+ "\r\n");

			} else if ((specValTemplate.getSpecificValue() instanceof Bitstring_Value)
					|| (specValTemplate.getSpecificValue() instanceof Integer_Value)
					|| (specValTemplate.getSpecificValue() instanceof Charstring_Value)
					|| (specValTemplate.getSpecificValue() instanceof Boolean_Value)
					||(specValTemplate.getSpecificValue() instanceof Octetstring_Value)
					|| (specValTemplate.getSpecificValue() instanceof Undefined_LowerIdentifier_Value)
					|| (specValTemplate.getSpecificValue() instanceof Referenced_Value)
					|| (specValTemplate.getSpecificValue() instanceof And4bExpression)
					|| (specValTemplate.getSpecificValue() instanceof Xor4bExpression)
					|| (specValTemplate.getSpecificValue() instanceof Not4bExpression)
					|| (specValTemplate.getSpecificValue() instanceof Or4bExpression)
					|| (specValTemplate.getSpecificValue() instanceof ShiftLeftExpression)
					|| (specValTemplate.getSpecificValue() instanceof ShiftRightExpression)
					|| (specValTemplate.getSpecificValue() instanceof RotateRightExpression)
					|| (specValTemplate.getSpecificValue() instanceof RotateLeftExpression)
					|| (specValTemplate.getSpecificValue() instanceof StringConcatenationExpression)
					|| (specValTemplate.getSpecificValue() instanceof AddExpression)
					|| (specValTemplate.getSpecificValue() instanceof SubstractExpression)
					|| (specValTemplate.getSpecificValue() instanceof MultiplyExpression)
					|| (specValTemplate.getSpecificValue() instanceof DivideExpression)
					|| (specValTemplate.getSpecificValue() instanceof ModuloExpression)
					|| (specValTemplate.getSpecificValue() instanceof RemainderExpression)
					||(specValTemplate.getSpecificValue() instanceof UnaryMinusExpression)) {
				// TODO assignments for indexed bitstrings
				testCaseString.append("rownum="
						+ specValTemplate.getLocation().getLine() + ";\r\n");


				testCaseString.append(tcAssignIdentifiers.get(assignCounter)
						 + tcAssignValues.get(assignCounter) + ";\r\n");

				

				// TODO: add logging here
			}

		}

		return testCaseString.toString();
	}

	public void writeConnectStatement(Connect_Statement tc_connectStatement) {
		testCaseString.append("rownum="
				+ tc_connectStatement.getLocation().getLine() + ";\r\n");

		for(int i=0; i<4;i++){
			if(tcConnectValues.get(connectCounter * 4 + i).equals("self")){
				tcConnectValues.set(connectCounter * 4 + i,testCaseRunsOn);
			}
		}
			
		testCaseString.append("hc.connect(" + "\""
				+ tcConnectValues.get(connectCounter * 4) + "\"," + "\""
				+ tcConnectValues.get(connectCounter * 4 + 1) + "\"," + "\""
				+ tcConnectValues.get(connectCounter * 4 + 2) + "\"," + "\""
				+ tcConnectValues.get(connectCounter * 4 + 3) + "\"); "
				+ "\r\n");

		testCaseString
				.append("TTCN3Logger.writeLog(\"mtc\", \"PARALLEL\", sourcefilename, rownum, \"testcase\", \""
						+ nodeName
						+ "\", \"Connecting port "
						+ tcConnectValues.get(connectCounter * 4 + 1)
						+ " of "
						+ tcConnectValues.get(connectCounter * 4)
						+ " to port "
						+ tcConnectValues.get(connectCounter * 4 + 3)
						+ " of "
						+ tcConnectValues.get(connectCounter * 4 + 2)
						+ "\", false);" + "\r\n");

	}

	public void writeUnknownStartStatement(
			Unknown_Start_Statement tc_startStatement) {
		startStatementCounter++;
		testCaseString.append("rownum="
				+ tc_startStatement.getLocation().getLine() + ";\r\n");

		if (testCaseStartValueParameters.get(startStatementCounter) != null) {
			testCaseString.append("hc.start(" + "\""
					+ tcStartIdentifiers.get(startStatementCounter) + "\",\""
					+ testCaseStartValueParameters.get(startStatementCounter)
					+ "\"); " + "\r\n");
		} else {
			testCaseString.append(tcStartIdentifiers.get(startStatementCounter)
					+ ".start()" + ";\r\n");
		}
		if (testCaseStartValueParameters.get(startStatementCounter) != null) {
			testCaseString
					.append("TTCN3Logger.writeLog(\"mtc\", \"PARALLEL\", sourcefilename, rownum, \"testcase\", \""
							+ nodeName
							+ "\", \"Starting function "
							+ testCaseStartValueParameters
									.get(startStatementCounter)
							+ " on component "
							+ tcStartIdentifiers.get(startStatementCounter)
							+ "\", false);" + "\r\n");
		} else {// timer
			testCaseString
					.append("TTCN3Logger.writeLog(\"mtc\", \"TIMEROP\", sourcefilename, rownum, \"function\", \""
							+ nodeName
							+ "\", \"Timer "
							+ tcStartIdentifiers.get(startStatementCounter)
							+ " started.\", false);" + "\r\n");
			isThereAStartedTimer = true;
			currentTimerName = tcStartIdentifiers.get(startStatementCounter);

		}

	}

	public void writeUnknownStopStatement(
			Unknown_Stop_Statement tc_stopStatement) {
		stopStatementCounter++;
		testCaseString.append("rownum="
				+ tc_stopStatement.getLocation().getLine() + ";\r\n");

		if (testCaseStopValueParameters.get(stopStatementCounter) != null) {
			testCaseString.append("hc.stop(" + "\""
					+ tcStopIdentifiers.get(stopStatementCounter) + "\",\""
					+ testCaseStopValueParameters.get(stopStatementCounter)
					+ "\"); " + "\r\n");
		} else {
			testCaseString.append(tcStopIdentifiers.get(stopStatementCounter)
					+ ".stop()" + ";\r\n");
		}
		if (testCaseStopValueParameters.get(stopStatementCounter) != null) {
			testCaseString
					.append("TTCN3Logger.writeLog(\"mtc\", \"PARALLEL\", sourcefilename, rownum, \"testcase\", \""
							+ nodeName
							+ "\", \"Stopping function "
							+ testCaseStopValueParameters
									.get(stopStatementCounter)
							+ " on component "
							+ tcStopIdentifiers.get(stopStatementCounter)
							+ "\", false);" + "\r\n");
		} else {// timer
			testCaseString
					.append("TTCN3Logger.writeLog(\"mtc\", \"TIMEROP\", sourcefilename, rownum, \"function\", \""
							+ nodeName
							+ "\", \"Timer "
							+ tcStopIdentifiers.get(stopStatementCounter)
							+ " stopped.\", false);" + "\r\n");
			isThereAStartedTimer = true;
			currentTimerName = tcStopIdentifiers.get(stopStatementCounter);

		}

	}

	public void writeMapStatement(Map_Statement tc_mapStatement) {
		StringBuilder mapValueString = new StringBuilder();

		while (Integer.toString(mapCounter).equals(
				tcMapCounter.get(currentMapValueIndex))) {

			mapValueString.append(tcMapValues.get(currentMapValueIndex) + " ");

			currentMapValueIndex++;
			if (currentMapValueIndex == tcMapCounter.size()) {
				break;
			}

		}

		String[] mapValues = mapValueString.toString().split(" ");

		testCaseString.append("rownum="
				+ tc_mapStatement.getLocation().getLine() + ";\r\n");
		testCaseString.append("hc.map(" + "\"" + mapValues[0] + "\",\""
				+ mapValues[1] + "\",\"" + mapValues[2] + "\",\""
				+ mapValues[3] + "\"" + ");\r\n");

		testCaseString
				.append("TTCN3Logger.writeLog(\"mtc\", \"PARALLEL\", sourcefilename, rownum, \"testcase\", \""
						+ nodeName
						+ "\", \"Mapping port "
						+ mapValues[1]
						+ " of "
						+ mapValues[0]
						+ " to port "
						+ mapValues[3]
						+ " of " + mapValues[2] + "\", false);" + "\r\n");
	}

	public void writeIfStatement(If_Statement tc_ifStatement) {
		testCaseString.append("rownum="
				+ tc_ifStatement.getLocation().getLine() + ";\r\n");

		testCaseString.append("if(" + tcIfConditions.get(tcIfConditionCounter)
				+ ".getValue()){\r\n");

		// TODO check if several IfClauses are possible
		writeTestCaseFunction(tc_ifStatement.getIfClauses().getClauses().get(0)
				.getStatementBlock());
		if (blockWriter) {
			testCaseString.append("}" + "\r\n");
		}

		if (tc_ifStatement.getStatementBlock() != null) {
			testCaseString.append("else{\r\n");
			writeTestCaseFunction(tc_ifStatement.getStatementBlock());
			if (blockWriter) {
				testCaseString.append("}" + "\r\n");
			}

		}
	}

	public void writeSetVerdictStatement(
			Setverdict_Statement tc_setVerdictStatement) {
		Verdict_Value tc_VerdictValue = (Verdict_Value) tc_setVerdictStatement
				.getVerdictValue();

		testCaseString.append("rownum="
				+ tc_setVerdictStatement.getLocation().getLine() + ";\r\n");

		if (tc_VerdictValue.getValue().toString().equals("PASS")) {
			testCaseString.append("setVerdict(\"pass\")" + ";\r\n");
		} else if (tc_VerdictValue.getValue().toString().equals("FAIL")) {
			testCaseString.append("setVerdict(\"fail\")" + ";\r\n");
		}

	}

	public String writeSendStatement(Send_Statement tc_SendStatement) {

		StringBuilder testCaseString = new StringBuilder("");

		if (sendParameterType.get(sendCounter).equals("INTEGER")) {
			String parameterValue =sendParameter.get(sendCounter);
			testCaseString.append("rownum="
					+ tc_SendStatement.getLocation().getLine() + ";\r\n");
			testCaseString.append(sendPortReference.get(sendCounter) + ".send("
					+ parameterValue + ");" + "\r\n");
			testCaseString
					.append("TTCN3Logger.writeLog(\"mtc\", \"PORTEVENT\", sourcefilename, rownum, \"function\", \""
							+ nodeName
							+ "\", \"SEND event on port "
							+ sendPortReference.get(sendCounter)
							+ ":INTEGER \""
							+ " + "
							+ parameterValue
							+ ".toString(), false);" + "\r\n");

		}
		
		if (sendParameterType.get(sendCounter).equals("CHARSTRING")) {
			String parameterValue =sendParameter.get(sendCounter);
			testCaseString.append("rownum="
					+ tc_SendStatement.getLocation().getLine() + ";\r\n");
			testCaseString.append(sendPortReference.get(sendCounter) + ".send("
					+ parameterValue + ");" + "\r\n");
			testCaseString
			.append("TTCN3Logger.writeLog(\"mtc\", \"PORTEVENT\", sourcefilename, rownum, \"function\", \""
					+ nodeName
					+ "\", \"SEND event on port "
					+ sendPortReference.get(sendCounter)
					+ ": \""
					+ " + "
					+ parameterValue
					+ ".toString(), false);"
					+ "\r\n");

		}
		
		if (sendParameterType.get(sendCounter).equals("IDENTIFIER")) {
			String parameterValue = sendParameter.get(sendCounter);
			testCaseString.append("rownum="
					+ tc_SendStatement.getLocation().getLine() + ";\r\n");
			testCaseString.append(sendPortReference.get(sendCounter) + ".send("
					+ parameterValue + ");" + "\r\n");
			testCaseString
					.append("TTCN3Logger.writeLog(\"mtc\", \"PORTEVENT\", sourcefilename, rownum, \"function\", \""
							+ nodeName
							+ "\", \"SEND event on port "
							+ sendPortReference.get(sendCounter)
							+ ": \""
							+ " + "
							+ parameterValue
							+ ".toString(), false);"
							+ "\r\n");

		}

		return testCaseString.toString();
	}

	public String writeReceiveStatement(Receive_Port_Statement currentStatement) {
		StringBuilder testCaseString = new StringBuilder("");
		String receiveStatement = "";

		// no alt guard && any port recieve
		if (receivePortReference.get(receiveCounter).equals("any port")) {
			receiveStatement = "anyPortReceive(true)";

		} else {
			// no alt guard && typed port recieve
			if (receiveType.get(receiveCounter).equals("_TYPED_PARAM_")) {

				if (receiveAnyValValue.get(receiveCounter) != null) {
					receiveStatement = "("
							+ receiveAnyValValue.get(receiveCounter) + "="
							+ receivePortReference.get(receiveCounter)
							+ ".receive_" + receiveValue.get(receiveCounter)
							+ "(true))!=null";

				} else {

				}

			} else { // no alt guard && normal port recieve
				receiveStatement = receivePortReference.get(receiveCounter)
						+ ".receive(" + receiveValue.get(receiveCounter)
						+ ",true)!=null";
			}
			if (receiveValue.get(receiveCounter).startsWith("Templates")) {
				receiveType.set(receiveCounter, "Templates");
			}
		}

		testCaseString.append("if(" + receiveStatement + "){\r\n");
		testCaseString.append("rownum="
				+ currentStatement.getLocation().getLine() + ";\r\n");

		if (receiveType.get(receiveCounter).equals("Templates")) {
			String methodName = receiveValue.get(receiveCounter);
			if (methodName.endsWith("()")
					&& methodName.startsWith("Templates.")) {

				methodName = (String) methodName.subSequence(10,
						methodName.length() - 2);
			}

			testCaseString
					.append("	TTCN3Logger.writeLog(\"mtc\", \"PORTEVENT\", sourcefilename, rownum, \"function\", \""
							+ nodeName
							+ "\", \"RECEIVE event on port "
							+ receivePortReference.get(receiveCounter)
							+ ":\\n "
							+ methodName
							+ ":=\" + "
							+ receiveValue.get(receiveCounter)
							+ ".toString(), true);" + "\r\n");
		} else if (receiveType.get(receiveCounter).equals("any port")) {
			testCaseString
					.append("	TTCN3Logger.writeLog(\"mtc\", \"PORTEVENT\", sourcefilename, rownum, \"function\", \""
							+ nodeName
							+ "\", \"RECEIVE event on port any port\", true);"
							+ "\r\n");
		} else if (receiveType.get(receiveCounter).equals("_TYPED_PARAM_")) {
			testCaseString
					.append("	TTCN3Logger.writeLog(\"mtc\", \"PORTEVENT\", sourcefilename, rownum, \"function\", \""
							+ nodeName
							+ "\", \"RECEIVE event on port "
							+ receivePortReference.get(receiveCounter)
							+ ": type "
							+ receiveValue.get(receiveCounter)
							+ "\", true);" + "\r\n");

		} else {
			testCaseString
					.append("	TTCN3Logger.writeLog(\"mtc\", \"PORTEVENT\", sourcefilename, rownum, \"function\", \""
							+ nodeName
							+ "\", \"RECEIVE event on port "
							+ receivePortReference.get(receiveCounter)
							+ ":\" + "
							+ receiveValue.get(receiveCounter)
							+ ".toString(), true);" + "\r\n");
		}

		for (int i = 0; i < receiveStatements.get(receiveCounter).getSize(); i++) {
			if (receiveStatements.get(receiveCounter).getStatementByIndex(i) instanceof Setverdict_Statement) {

				Setverdict_Statement setVerdictStatement = (Setverdict_Statement) receiveStatements
						.get(receiveCounter).getStatementByIndex(i);
				String verdict = "";

				if (setVerdictStatement.getVerdictValue() instanceof Verdict_Value) {
					Verdict_Value verdictValue = (Verdict_Value) setVerdictStatement
							.getVerdictValue();
					if (verdictValue.getValue().toString().equals("PASS")) {
						verdict = "pass";
					} else if (verdictValue.getValue().toString()
							.equals("INCONC")) {
						verdict = "inconc";
					} else {
						verdict = "fail";
					}
				}
				testCaseString
						.append("rownum="
								+ setVerdictStatement.getLocation().getLine()
								+ ";\r\n");
				testCaseString
						.append("TTCN3Logger.writeLog(\"mtc\", \"VERDICTOP\", sourcefilename, rownum, \"function\", \""
								+ nodeName
								+ "\", \"setverdict("
								+ verdict
								+ "): \" + getVerdict() + \" -> "
								+ verdict
								+ "\", true);" + "\r\n");
				testCaseString.append("setVerdict(\"" + verdict + "\");"
						+ "\r\n");

			}
		}

		testCaseString.append("}\r\n");

		return testCaseString.toString();
	}

	public void writeDisconnectStatement(
			Disconnect_Statement tc_disconnectStatement) {

		testCaseString.append("rownum="
				+ tc_disconnectStatement.getLocation().getLine() + ";\r\n");
		
		for(int i=0; i<4;i++){
			if(tcDisconnectValues.get(disconnectCounter * 4 + i).equals("self")){
				tcDisconnectValues.set(disconnectCounter * 4 + i,testCaseRunsOn);
			}
		}

		testCaseString.append("hc.disconnect(" + "\""
				+ tcDisconnectValues.get(disconnectCounter * 4) + "\"," + "\""
				+ tcDisconnectValues.get(disconnectCounter * 4 + 1) + "\","
				+ "\"" + tcDisconnectValues.get(disconnectCounter * 4 + 2)
				+ "\"," + "\""
				+ tcDisconnectValues.get(disconnectCounter * 4 + 3) + "\"); "
				+ "\r\n");

		testCaseString
				.append("TTCN3Logger.writeLog(\"mtc\", \"PARALLEL\", sourcefilename, rownum, \"testcase\", \""
						+ nodeName
						+ "\", \"Disconnecting port "
						+ tcDisconnectValues.get(disconnectCounter * 4 + 1)
						+ " of "
						+ tcDisconnectValues.get(disconnectCounter * 4)
						+ " to port "
						+ tcDisconnectValues.get(disconnectCounter * 4 + 3)
						+ " of "
						+ tcDisconnectValues.get(disconnectCounter * 4 + 2)
						+ "\", false);" + "\r\n");
	}

	public void clearLists() {

		logCreateCounter = 0;
		createCounter = -1;
		connectCounter = -1;
		disconnectCounter = -1;
		currentCounterValue = 0;
		defCounter = -1;
		defValueCounter = -1;
		assignCounter = -1;
		mapCounter = 0;
		tcIfConditionCounter = -1;
		sendCounter = -1;
		startStatementCounter = -1;
		stopStatementCounter = -1;
		currentMapValueIndex = 0;
		receiveCounter = -1;

		tcConnectValues.clear();
		tcStartIdentifiers.clear();
		tcStartCounter.clear();
		tcMapValues.clear();
		tcMapCounter.clear();
		tcIfConditions.clear();
		tcVars.clear();
		tcVarTypes.clear();
		tcVarValues.clear();
		tcAssignIdentifiers.clear();
		tcAssignValues.clear();
		tcValueIsAValueReference.clear();
		tcCreateValues.clear();
		tcCreateCounter.clear();
		sendPortReference.clear();
		sendParameter.clear();
		sendParameterType.clear();

		tcVarIsConstant.clear();
		tcVarIsTemplate.clear();
		tcDisconnectValues.clear();
		testCaseStartValueParameters.clear();
		tcValueTypeIsAReference.clear();
		tcStopIdentifiers.clear();
		tcStopCounter.clear();
		testCaseStopValueParameters.clear();
		doWhileCounter = -1;
		
		doWhileExpressions.clear();
		
		receivePortReference.clear();
		receiveValue.clear();
		receiveAnyValValue.clear();
		receiveType.clear();
		nodeVarIsRecord.clear();
		receiveStatements.clear();
	}

	public void clearAltLists() {
		altStatementCounter = -1;

		altStatements.clear();
	}

}
/******************************************************************************
 * Copyright (c) 2000-2017 Ericsson Telecom AB
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   
 *   Keremi, Andras
 *   Eros, Levente
 *   Kovacs, Gabor
 *
 ******************************************************************************/

package org.eclipse.titan.codegenerator;

import java.util.LinkedHashMap;
import java.util.Map;

import org.eclipse.titan.designer.AST.TTCN3.definitions.Def_Type;
//TODO: duplicate of charstring, ONLY A PLACEHOLDER YET
public class Def_Type_Bitstring_Writer {
	private Def_Type typeNode;
	private StringBuilder charStringString = new StringBuilder("");

	private String charStringValue = null;
	private String nodeName = null;

	private static Map<String, Object> charStringHashes = new LinkedHashMap<String, Object>();

	private Def_Type_Bitstring_Writer(Def_Type typeNode) {
		super();
		this.typeNode = typeNode;
		nodeName = this.typeNode.getIdentifier().toString();

	}

	public static Def_Type_Bitstring_Writer getInstance(Def_Type typeNode) {
		if (!charStringHashes.containsKey(typeNode.getIdentifier().toString())) {
			charStringHashes.put(typeNode.getIdentifier().toString(),
					new Def_Type_Bitstring_Writer(typeNode));

		}
		return (Def_Type_Bitstring_Writer) charStringHashes.get(typeNode
				.getIdentifier().toString());
	}

	public void addCharStringValue(String value) {
		charStringValue = value;
	}

	private void writeConstructor() {
		charStringString.append(nodeName + "(" + "CHARSTRING" + " val){");
		charStringString.append("\r\n" + "super(val);");

		if (charStringValue != null) {

			charStringString.append("\r\n" + "allowedValues.add"
					+ "(new CHARSTRING(\"" + charStringValue + "\"));");

		}
		charStringString.append("\r\n	}\r\n");

	}

	private void writeMatcher() {
		charStringString.append("public static boolean match(" + nodeName
				+ " pattern, " + "Object " + " message){" + "\r\n");
		charStringString.append("if(!(message instanceof " + nodeName
				+ ")) return false;" + "\r\n");
		charStringString.append("	return CHARSTRING.match(pattern.value, (("
				+ nodeName + ")message).value);" + "\r\n");
		charStringString.append("}" + "\r\n");
	}

	private void writeEquals() {
		charStringString.append("public boolean equals(" + nodeName
				+ " v){\r\n");
		charStringString.append("	return value.equals(v.value);\r\n");
		charStringString.append("}\r\n");

	}

	public void clearLists(){
		//TODO put lists and fields here which should be initialized
	}
	
	public String getJavaSource() {
		
		AstWalkerJava.logToConsole("	Starting processing:  Bitstring " + nodeName );
		
		charStringString.append("class " + nodeName
				+ " extends SubTypeDef<CHARSTRING>{" + "\r\n");
		this.writeConstructor();
		this.writeMatcher();
		this.writeEquals();
		charStringString.append("\r\n}");
		String returnString = charStringString.toString();
		charStringString.setLength(0);
		charStringValue = null;
		
		AstWalkerJava.logToConsole("	Finished processing:  Bitstring " + nodeName );
		
		return returnString;
	}

}
package org.eclipse.titan.codegenerator;

import java.util.LinkedHashMap;
import java.util.Map;

import org.eclipse.titan.designer.AST.TTCN3.definitions.Def_Type;

public class Def_Type_Charstring_Writer {
	private SourceCode code = new SourceCode();

	private String charStringValue = null;
	private String nodeName = null;

	private static Map<String, Object> charStringHashes = new LinkedHashMap<>();

	private Def_Type_Charstring_Writer(Def_Type typeNode) {
		super();
		nodeName = typeNode.getIdentifier().toString();

	}

	public static Def_Type_Charstring_Writer getInstance(Def_Type typeNode) {
		if (!charStringHashes.containsKey(typeNode.getIdentifier().toString())) {
			charStringHashes.put(typeNode.getIdentifier().toString(),
					new Def_Type_Charstring_Writer(typeNode));

		}
		return (Def_Type_Charstring_Writer) charStringHashes.get(typeNode
				.getIdentifier().toString());
	}

	public void addCharStringValue(String value) {
		charStringValue = value;
	}

	private void writeTemplateObjects() {
		code.indent(1).line("public static final ", nodeName, " ANY = new ", nodeName, "();");
		code.indent(1).line("public static final ", nodeName, " OMIT = new ", nodeName, "();");
		code.indent(1).line("public static final ", nodeName, " ANY_OR_OMIT = new ", nodeName, "();");
		code.newLine();
		code.indent(1).line("static {");
		code.indent(2).line("ANY.anyField = true;");
		code.indent(2).line("OMIT.omitField = true;");
		code.indent(2).line("ANY_OR_OMIT.anyOrOmitField = true;");
		code.indent(1).line("}");
	}

	private void writeConstructors() {
		code.indent(1).line("public ", nodeName, "(CHARSTRING val) {");
		code.indent(2).line("super(val);");
		if (charStringValue != null) {
			code.indent(2).line("allowedValues.add(new CHARSTRING(\"", charStringValue, "\"));");
		}
		code.indent(1).line("}");
		code.newLine();
		code.indent(1).line("public ", nodeName, "(String val) {");
		code.indent(2).line("this(new CHARSTRING(val));");
		code.indent(1).line("}");
		code.newLine();
		code.indent(1).line("protected ", nodeName, "() {");
		code.indent(2).line("super();");
		code.indent(1).line("}");
	}

	private void writeMatcher() {
		code.indent(1).line("public static boolean match(", nodeName, " pattern, Object message) {");
		code.indent(2).line("if (!(message instanceof ", nodeName, ")) return false;");
		// TODO any / omit / anyOrOmit checking?
		code.indent(2).line("return CHARSTRING.match(pattern.value, ((", nodeName, ")message).value);");
		code.indent(1).line("}");
	}

	private void writeEquals() {
		code.indent(1).line("public BOOLEAN equals(", nodeName, " v) {");
		code.indent(2).line("return value.equals(v.value);");
		code.indent(1).line("}");
	}
	
	public void clearLists(){
		//TODO put lists and fields here which should be initialized
	}
	
	public String getJavaSource() {
		code.clear();
		AstWalkerJava.logToConsole("	Starting processing:  Charstring " + nodeName );
		code.line("public class ", nodeName, " extends SubTypeDef<CHARSTRING> {");
		this.writeTemplateObjects();
		code.newLine();
		this.writeConstructors();
		code.newLine();
		this.writeMatcher();
		code.newLine();
		this.writeEquals();
		code.line("}");
		// TODO why clear charStringValue?
		charStringValue = null;
		AstWalkerJava.logToConsole("	Finished processing:  Charstring " + nodeName );
		return code.toString();
	}

}
/******************************************************************************
 * Copyright (c) 2000-2017 Ericsson Telecom AB
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   
 *   Keremi, Andras
 *   Eros, Levente
 *   Kovacs, Gabor
 *
 ******************************************************************************/

package org.eclipse.titan.codegenerator;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.titan.designer.AST.TTCN3.definitions.Def_Type;

public class Def_Type_Component_Writer {
	private Def_Type typeNode;
	private StringBuilder compString = new StringBuilder("");

	public List<String> compFieldPortTypes = new ArrayList<String>();
	public List<String> compFieldPortNames = new ArrayList<String>();
	public List<String> compFieldVarTypes = new ArrayList<String>();
	public List<String> compFieldVarNames = new ArrayList<String>();
	private String nodeName = null;

	private static Map<String, Object> compHashes = new LinkedHashMap<String, Object>();

	private Def_Type_Component_Writer(Def_Type typeNode) {
		super();
		this.typeNode = typeNode;
		nodeName = this.typeNode.getIdentifier().toString();
	}

	public static Def_Type_Component_Writer getInstance(Def_Type typeNode) {
		if (!compHashes.containsKey(typeNode.getIdentifier().toString())) {
			compHashes.put(typeNode.getIdentifier().toString(),
					new Def_Type_Component_Writer(typeNode));
		}
		return (Def_Type_Component_Writer) compHashes.get(typeNode
				.getIdentifier().toString());
	}

	public void writeCompFields() {

		for (int i = 0; i < compFieldPortTypes.size(); i++) {
			compString.append(compFieldPortTypes.get(i) + " "
					+ compFieldPortNames.get(i) + ";\r\n");
		}
		
		for (int i = 0; i < compFieldVarNames.size(); i++) {

			compString.append(compFieldVarTypes.get(i) +" "+compFieldVarNames.get(i) + ";" + "\r\n");
		}
	}

	public void writeConstructor() {
		compString.append("public " + nodeName
				+ "(HCType hcont, String name, String ID){" + "\r\n");
		compString.append("super(name);" + "\r\n");
		compString.append("hc=hcont;" + "\r\n");

		compString
				.append("if(hc.debugmode)TTCN3Logger.writeLog(name, \"PARALLEL\", \"Test component \" + name + \" created.\", false);"
						+ "\r\n");

		for (int i = 0; i < compFieldPortNames.size(); i++) {

			compString.append(compFieldPortNames.get(i) + " =new "
					+ compFieldPortTypes.get(i) + "(this,\""
					+ compFieldPortNames.get(i) + "\");" + "\r\n");
		}
		
		for (int i = 0; i < compFieldVarNames.size(); i++) {

			compString.append(compFieldVarNames.get(i) + " =new "
					+ compFieldVarTypes.get(i) + "();" + "\r\n");
		}

		compString.append("created = true;" + "\r\n");
		compString.append("compid = ID;" + "\r\n");
		compString.append("}" + "\r\n");
	}

	public void writeAnyPortReceive() {

		compString.append("public boolean anyPortReceive(boolean take){"
				+ "\r\n");
		for (int i = 0; i < compFieldPortNames.size(); i++) {

			compString.append("	if(" + compFieldPortNames.get(i)
					+ ".receive(take)!=null)return true;" + "\r\n");

		}

		compString.append("	return false;" + "\r\n");
		compString.append("}" + "\r\n");
	}

	public void writePrepareForConnection() {
		compString.append("@Override" + "\r\n");
		compString
				.append("public void prepareforconnection(String thisport, int thisportnum) {"
						+ "\r\n");
		for (int i = 0; i < compFieldPortNames.size(); i++) {
			compString.append("if(thisport.equals(\"" + compFieldPortNames.get(i)
					+ "\")) " + compFieldPortNames.get(i)
					+ ".prepareforconnection(thisportnum);" + "\r\n");

		}

		compString.append("	" + "\r\n");
		compString.append("}" + "\r\n");
	}

	public void writeConnect() {
		compString.append("" + "\r\n");
		compString.append("@Override" + "\r\n");
		compString
				.append("public void connect(String port, String ip, String portnum) {"
						+ "\r\n");

		for (int i = 0; i < compFieldPortNames.size(); i++) {
			compString.append("if(port.equals(\"" + compFieldPortNames.get(i)
					+ "\")) " + compFieldPortNames.get(i)
					+ ".connect(ip, Integer.parseInt(portnum));" + "\r\n");

		}

		compString.append("	" + "\r\n");
		compString.append("}" + "\r\n");
	}
	
	public void writeDisconnect() {
		compString.append("" + "\r\n");
		compString.append("@Override" + "\r\n");
		compString
				.append("public void disconnect(String port1, String comp2, String port2) {"
						+ "\r\n");

		for (int i = 0; i < compFieldPortNames.size(); i++) {
			compString.append("if(port1.equals(\"" + compFieldPortNames.get(i)
					+ "\")) " + compFieldPortNames.get(i)
					+ ".disconnect(comp2, port2);" + "\r\n");

		}

		compString.append("	" + "\r\n");
		compString.append("}" + "\r\n");
	}


	public void writeDomap() {
		compString.append("" + "\r\n");
		compString.append("@Override" + "\r\n");
		compString
				.append("public void domap(String thisport, String remotecomp, String remoteport) {"
						+ "\r\n");

		// TODO
		for (int i = 0; i < compFieldPortTypes.size(); i++) {
			if (myASTVisitor.nodeNameNodeTypeHashMap.get(compFieldPortTypes.get(i))
					.equals("port")) {
				if (!(myASTVisitor.portNamePortTypeHashMap.get(compFieldPortTypes
						.get(i)).equals("TP_INTERNAL"))) {
					compString.append("if(thisport.equals(\""
							+ compFieldPortNames.get(i) + "\")) "
							+ compFieldPortNames.get(i)
							+ ".map(remotecomp, remoteport);" + "\r\n");
				}
			}
		}

		compString.append("	" + "\r\n");
		compString.append("}" + "\r\n");
	}

	public void clearLists() {
		compFieldPortTypes.clear();
		compFieldPortNames.clear();
		compFieldVarTypes.clear();
		compFieldVarNames.clear();
	}

	public String getJavaSource() {

		AstWalkerJava.logToConsole("	Starting processing:  Component "
				+ nodeName);

		compString.append("class " + nodeName + " extends ComponentDef{"
				+ "\r\n");
		this.writeCompFields();
		this.writeConstructor();
		this.writeAnyPortReceive();
		this.writePrepareForConnection();
		this.writeConnect();
		this.writeDisconnect();
		this.writeDomap();
		compString.append("\r\n}");

		String returnString = compString.toString();
		compString.setLength(0);

		AstWalkerJava.logToConsole("	Finished processing:  Component "
				+ nodeName);

		return returnString;
	}
}
package org.eclipse.titan.codegenerator;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.titan.designer.AST.TTCN3.definitions.Def_Type;

public class Def_Type_Enum_Writer {
	private Def_Type typeNode;
	private StringBuilder enumString = new StringBuilder("");

	public List<String> enumItems = new ArrayList<String>();
	public List<String> enumItemValues = new ArrayList<String>();
	private String nodeName = null;

	private static Map<String, Object> enumStringHashes = new LinkedHashMap<String, Object>();

	private Def_Type_Enum_Writer(Def_Type typeNode) {
		super();
		this.typeNode = typeNode;
		nodeName = this.typeNode.getIdentifier().toString();
	}

	public static Def_Type_Enum_Writer getInstance(Def_Type typeNode) {
		if (!enumStringHashes.containsKey(typeNode.getIdentifier().toString())) {
			enumStringHashes.put(typeNode.getIdentifier().toString(),
					new Def_Type_Enum_Writer(typeNode));
		}
		return (Def_Type_Enum_Writer) enumStringHashes.get(typeNode
				.getIdentifier().toString());
	}

	private void writeConstructors() {
		enumString.append("public " + nodeName + "(){" + "\r\n");
		int enumValueCounter = 0;
		for (int i = 0; i < enumItems.size(); i++) {
			enumString.append("values.put(\"" + enumItems.get(i) + "\",");
			if (enumItemValues.get(i) != null) {
				enumString.append(enumItemValues.get(i) + ");" + "\r\n");
			} else {
				while (enumItemValues.contains(Integer
						.toString(enumValueCounter))) {
					enumValueCounter++;
				}
				enumString.append(+enumValueCounter + ");" + "\r\n");
				enumValueCounter++;
			}

		}
		enumString.append("}" + "\r\n");

		enumString.append("public " + nodeName + "(String v){" + "\r\n");
		enumString.append("this();" + "\r\n");
		enumString.append("setValue(v);}");
	}

	public void clearLists() {
		enumItems.clear();
		enumItemValues.clear();
	}

	public String getJavaSource() {

		AstWalkerJava.logToConsole("	Starting processing:  Enum " + nodeName);

		enumString
				.append("class " + nodeName + " extends ENUMERATED{" + "\r\n");
		this.writeConstructors();
		enumString.append("\r\n}");
		String returnString = enumString.toString();
		enumString.setLength(0);

		AstWalkerJava.logToConsole("	Finished processing:  Enum " + nodeName);

		return returnString;
	}

}
package org.eclipse.titan.codegenerator;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.StringJoiner;

import org.eclipse.titan.designer.AST.TTCN3.definitions.Def_Type;

public class Def_Type_Integer_Writer {
	private SourceCode code = new SourceCode();

	private String nodeName = null;

	public static List<String> allowedValues = new ArrayList<>();

	private static Map<String, Object> integerHashes = new LinkedHashMap<>();

	private Def_Type_Integer_Writer(Def_Type typeNode) {
		super();
		nodeName = typeNode.getIdentifier().toString();
	}

	public static Def_Type_Integer_Writer getInstance(Def_Type typeNode) {
		if (!integerHashes.containsKey(typeNode.getIdentifier().toString())) {
			integerHashes.put(typeNode.getIdentifier().toString(), new Def_Type_Integer_Writer(typeNode));
		}
		return (Def_Type_Integer_Writer) integerHashes.get(typeNode.getIdentifier().toString());
	}

	private void writeTemplateObjects() {
		code.indent(1).line("public static final ", nodeName, " ANY = new ", nodeName, "();");
		code.indent(1).line("public static final ", nodeName, " OMIT = new ", nodeName, "();");
		code.indent(1).line("public static final ", nodeName, " ANY_OR_OMIT = new ", nodeName, "();");
		code.newLine();
		code.indent(1).line("static {");
		code.indent(2).line("ANY.anyField = true;");
		code.indent(2).line("OMIT.omitField = true;");
		code.indent(2).line("ANY_OR_OMIT.anyOrOmitField = true;");
		code.indent(1).line("}");
	}


	private void writeConstructor() {
		code.indent(1).line("public ", nodeName, "(INTEGER val) {");
		code.indent(2).line("super(val);");

		// TODO move the SymbolDB update elsewhere (parser / visitor)
		if(allowedValues.size()>0){
			StringJoiner values = new StringJoiner(", ");
			allowedValues.forEach(values::add);
			myASTVisitor.nodeNameAllowedValuesHashmap.put(nodeName, values.toString());
		}
		// TODO move data transformation elsewhere (parser / visitor)
		//split values of referenced parameters
		for (int i = 0; i < allowedValues.size(); i++) {
			String[] values=allowedValues.get(i).split(", ");
			allowedValues.remove(i);
			for (int j = values.length-1; j>=0 ; j--){
				if(allowedValues.size()==j){
					allowedValues.add(values[j]);
				} else {
					allowedValues.add(i, values[j]);
				}
			}
		}
		
		//allowedValues=allowedValues.get(0).sp(", ");
		for (String value : allowedValues) {
			if (value.startsWith("new SubTypeInterval")) {
				code.indent(2).line("allowedIntervals.add(", value, ");");
			} else {
				code.indent(2).line("allowedValues.add(", value, ");");
			}
		}
		code.indent(2).line("checkValue();");
		code.indent(1).line("}");
		code.newLine();
		code.indent(1).line("public ", nodeName, "(String val) {");
		code.indent(2).line("this(new INTEGER(val));");
		code.indent(1).line("}");
		code.newLine();
		code.indent(1).line("protected ", nodeName, "() {");
		code.indent(2).line("super();");
		code.indent(1).line("}");
	}

	private void writeMatcher() {
		code.indent(1).line("public static boolean match(", nodeName, " pattern, Object message) {");
		code.indent(2).line("if (!(message instanceof ", nodeName, ")) return false;");
		code.indent(2).line("return INTEGER.match(pattern.value, ((", nodeName, ")message).value);");
		code.indent(1).line("}");
	}

	private void writeEquals() {
		code.indent(1).line("public BOOLEAN equals(", nodeName, " v) {");
		code.indent(2).line("return value.equals(v.value);");
		code.indent(1).line("}");
	}

	public void clearLists() {
		// TODO put lists and fields here which should be initialized
	}

	public String getJavaSource() {
		code.clear();
		AstWalkerJava.logToConsole("	Starting processing:  Integer " + nodeName);
		code.line("public class ", nodeName, " extends SubTypeDef<INTEGER> {");
		this.writeTemplateObjects();
		code.newLine();
		this.writeConstructor();
		code.newLine();
		this.writeMatcher();
		code.newLine();
		this.writeEquals();
		code.line("}");
		return code.toString();
	}

}
/******************************************************************************
 * Copyright (c) 2000-2017 Ericsson Telecom AB
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   
 *   Keremi, Andras
 *   Eros, Levente
 *   Kovacs, Gabor
 *
 ******************************************************************************/

package org.eclipse.titan.codegenerator;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.titan.designer.AST.TTCN3.definitions.Def_Type;

//only supports inout messages
public class Def_Type_Port_Writer {
	private SourceCode code = new SourceCode();

	public List<String> inMessageName = new ArrayList<String>();
	public List<String> outMessageName = new ArrayList<String>();
	public List<String> inOutMessageName = new ArrayList<String>();

	private boolean isPortTypeAReferencedType = false;
	private boolean isPortInternal = false;
	private String nodeName = null;

	private static Map<String, Object> portHashes = new LinkedHashMap<String, Object>();

	private Def_Type_Port_Writer(Def_Type typeNode) {
		super();
		nodeName = typeNode.getIdentifier().toString();

	}

	public static Def_Type_Port_Writer getInstance(Def_Type typeNode) {
		if (!portHashes.containsKey(typeNode.getIdentifier().toString())) {
			portHashes.put(typeNode.getIdentifier().toString(),
					new Def_Type_Port_Writer(typeNode));
		}
		return (Def_Type_Port_Writer) portHashes.get(typeNode.getIdentifier()
				.toString());
	}

	public void setPortTypeAReferencedType(boolean isPortTypeAReferencedType) {
		this.isPortTypeAReferencedType = isPortTypeAReferencedType;
	}

	private void writeExternalPorts() {
		code.indent(1).line("private TP_", nodeName, " testport = new TP_", nodeName, "(this);");
	}

	private void writeReceive() {
		for (String type : inMessageName) {
			code.newLine();
			receiveMatching(type);
		}
		for (String type : outMessageName) {
			code.newLine();
			receiveMatching(type);
		}
		for (String type : inOutMessageName) {
			code.newLine();
			receiveMatching(type);
		}
	}

	private void receiveMatching(String type) {
		code.indent(1).line("public ", type, " receive(", type, " s, boolean take) {");
		code.indent(2).line("while (!mapped) {");
		code.indent(3).line("if (component.hc.debugmode) TTCN3Logger.writeLog(component.compid + \":\" + this.name, \"PORTEVENT\", \"Port not mapped, retrying RECEIVE operation\", false);");
		code.indent(3).line("try { Thread.sleep(1000); } catch (Exception e) {}");
		code.indent(2).line("}");
		code.indent(2).line("if (inBuffer.isEmpty()) return null;");
		if (isPortTypeAReferencedType) {
			code.indent(2).line("if (!(inBuffer.get(0) instanceof ", type, ")) return null;");
		}
		code.indent(2).line("boolean matches = ", type, ".match(s, inBuffer.get(0));");
		code.indent(2).line("if (matches) {");
		code.indent(3).line(type, " msg = (", type, ") inBuffer.get(0);");
		code.indent(3).line("if (take) {");
		code.indent(4).line("TTCN3Logger.writeLog(component.compid + \":\" + this.name, \"PORTEVENT\", \"Received \" + msg, false);");
		code.indent(4).line("inBuffer.remove(0);");
		code.indent(3).line("}");
		code.indent(3).line("return msg;");
		code.indent(2).line("}");
		code.indent(2).line("return null;");
		code.indent(1).line("}");
	}

	private void writeTypedReceive() {
		for (String type : inMessageName) {
			code.newLine();
			receiveType(type);
		}
		for (String type : outMessageName) {
			code.newLine();
			receiveType(type);
		}
		for (String type : inOutMessageName) {
			code.newLine();
			receiveType(type);
		}
	}

	private void receiveType(String type) {
		code.indent(1).line("public ", type, " receive_", type, "(boolean take) {");
		code.indent(2).line("while (!mapped) {");
		code.indent(3).line("if (component.hc.debugmode) TTCN3Logger.writeLog(component.compid + \":\" + this.name, \"PORTEVENT\", \"Port not mapped, retrying RECEIVE operation\", false);");
		code.indent(3).line("try { Thread.sleep(1000); } catch (Exception e) {}");
		code.indent(2).line("}");
		code.indent(2).line("if (inBuffer.isEmpty()) return null;");
		code.indent(2).line("if (inBuffer.get(0) instanceof ", type, ") {");
		code.indent(3).line(type, " msg = (", type, ") inBuffer.get(0);");
		code.indent(3).line("if (take) {");
		code.indent(4).line("TTCN3Logger.writeLog(component.compid + \":\" + this.name, \"PORTEVENT\", \"Received \" + msg, false);");
		code.indent(4).line("inBuffer.remove(0);");
		code.indent(3).line("}");
		code.indent(3).line("return msg;");
		code.indent(2).line("}");
		code.indent(2).line("return null;");
		code.indent(1).line("}");
	}

	private void writeObjectReceive() {
		code.newLine();
		code.indent(1).line("public Object receive(boolean take){");
		code.indent(2).line("while (!mapped) {");
		code.indent(3).line("if (component.hc.debugmode) TTCN3Logger.writeLog(component.compid + \":\" + this.name, \"PORTEVENT\", \"Port not mapped, retrying RECEIVE operation\", false);");
		code.indent(3).line("try { Thread.sleep(1000); } catch (Exception e) {}");
		code.indent(2).line("}");
		code.indent(2).line("if (!inBuffer.isEmpty()) {");
		code.indent(3).line("Object msg = inBuffer.get(0);");
		code.indent(3).line("if (take) {");
		code.indent(4).line("TTCN3Logger.writeLog(component.compid + \":\" + this.name, \"PORTEVENT\", \"Received \" + msg, false);");
		code.indent(4).line("inBuffer.remove(0);");
		code.indent(3).line("}");
		code.indent(3).line("return msg;");
		code.indent(2).line("}");
		code.indent(2).line("return null;");
		code.indent(1).line("}");
	}

	private void send() {
		code.newLine();
		code.indent(1).line("public void send(Object o) {");
		code.indent(2).line("while (!mapped) {");
		code.indent(3).line("if (component.hc.debugmode) TTCN3Logger.writeLog(component.compid + \":\" + this.name, \"PORTEVENT\", \"Port not mapped, retrying RECEIVE operation\", false);");
		code.indent(3).line("try { Thread.sleep(1000); } catch (Exception e) {}");
		code.indent(2).line("}");
		code.indent(2).line("try {");
		if (!isPortInternal) {
			code.indent(3).line("testport.user_send(o);");
		} else {
			code.indent(3).line("owriter.writeObject(o);");
		}
		code.indent(2).line("} catch (Exception e) { e.printStackTrace(); }");
		code.indent(1).line("}");
	}

	private void writeConstructor() {
		code.newLine();
		code.indent(1).line("public ", nodeName, "(ComponentDef c, String name) {");
		code.indent(2).line("super(c, name);");
		code.indent(2).line("inBuffer = new ArrayList<Object>();");
		for (String i : inMessageName) {
			code.indent(2).line("inMessages.add(\"" + i + "\");");
		}
		for (String o : outMessageName) {
			code.indent(2).line("outMessages.add(\"" + o + "\");");
		}
		for (String io : inOutMessageName) {
			code.indent(2).line("inMessages.add(\"" + io + "\");");
			code.indent(2).line("outMessages.add(\"" + io + "\");");
		}
		code.indent(2).line("created=true;");
		code.indent(1).line("}");
	}

	private void writePrepareforconnection() {
		code.newLine();
		code.indent(1).line("ObjectOutputStream owriter;");
		code.indent(1).line("Thread listener;");
		code.newLine();
		code.indent(1).line("public void prepareforconnection (int thisportnum) {");
		code.indent(2).line("if (component.hc.debugmode) TTCN3Logger.writeLog(component.compid + \":\" + this.name, \"PORTEVENT\", \"Preparing for port connection -- Creating buffer daemon\", false);");
		code.indent(2).line("listener = new BufferDaemon(this, thisportnum, false);");
		code.indent(2).line("component.hc.portlistenerpool.add(listener);");
		code.indent(2).line("if (component.hc.debugmode) TTCN3Logger.writeLog(component.compid + \":\" + this.name, \"PORTEVENT\", \"Preparing for port connection -- Starting buffer daemon thread\", false);");
		code.indent(2).line("listener.start();");
		code.indent(1).line("}");
	}

	private void writeConnect() {
		code.newLine();
		code.indent(1).line("public void connect(String ip, int remoteportnum) {");
		code.indent(2).line("if (component.hc.debugmode) TTCN3Logger.writeLog(component.compid + \":\" + this.name, \"PORTEVENT\", \"Establishing port connection -- Creating buffer daemon\", false);");
		code.indent(2).line("listener = new BufferDaemon(this, ip, remoteportnum, true);");
		code.indent(2).line("component.hc.portlistenerpool.add(listener);");
		code.indent(2).line("if (component.hc.debugmode) TTCN3Logger.writeLog(component.compid + \":\" + this.name, \"PORTEVENT\", \"Establishing port connection -- Creating buffer daemon\", false);");
		code.indent(2).line("listener.start();");
		code.indent(1).line("}");
	}
	
	private void writeDisconnect() {
		code.newLine();
		code.indent(1).line("public void disconnect(String comp2, String port2) {");
		code.indent(1).line("try {");
		code.indent(2).line("owriter.writeObject(null);");
		code.indent(2).line("component.hc.portlistenerpool.remove(listener);");
		code.indent(1).line("} catch (Exception e) { e.printStackTrace(); }");
		code.indent(1).line("}");
	}

	private void writeMap() {
		code.newLine();
		code.indent(1).line("public void map(String remotecomp, String remoteport) {");
		if (!isPortInternal) { // TODO check if needed!
			code.indent(2).line("testport.user_map(remotecomp, remoteport);");
		}
		code.indent(1).line("}");
	}

	private void writeBufferDaemon() {
		// TODO migrate this to SourceCode
		StringBuilder portString = new StringBuilder();

		portString.append("class BufferDaemon extends Thread{ " + "\r\n");
		portString.append("	private " + nodeName + " port;" + "\r\n");
		portString.append("	private int portnum;" + "\r\n");
		portString.append("	private String ip;" + "\r\n");
		portString.append("	private boolean isinitiator;" + "\r\n");
		portString.append("	public BufferDaemon(" + nodeName
				+ " p, int pnum, boolean init){" + "\r\n");
		portString.append("		port = p;" + "\r\n");
		portString.append("		portnum = pnum;" + "\r\n");
		portString.append("		isinitiator = init;" + "\r\n");
		portString
				.append("		if(component.hc.debugmode)TTCN3Logger.writeLog(component.compid + \":\" + port.name + \"--buffer-daemon\", \"PORTEVENT\", \"Buffer daemon started. Listening on port \" + portnum + \", in \" + (isinitiator?\"INITIATOR\":\"RESPONDER\") + \" mode\", false);"
						+ "\r\n");

		portString.append("	}" + "\r\n");
		portString.append("	public BufferDaemon(" + nodeName
				+ " p, String ipaddr, int pnum, boolean init){" + "\r\n");
		portString.append("		this(p,pnum,init);" + "\r\n");
		portString.append("		ip=ipaddr;" + "\r\n");
		portString.append("	}" + "\r\n");
		portString.append("	public void run(){" + "\r\n");
		portString.append("		ServerSocket ssock = null;" + "\r\n");
		portString.append("		Socket sock = null;" + "\r\n");
		portString.append("		if(!isinitiator){" + "\r\n");
		portString.append("			try{" + "\r\n");
		portString
				.append("				if(component.hc.debugmode)TTCN3Logger.writeLog(component.compid + \":\" + port.name + \"--buffer-daemon\", \"PORTEVENT\", \"Buffer daemon waiting for connection on port \" + portnum, false);"
						+ "\r\n");
		portString.append("				ssock = new ServerSocket(portnum);" + "\r\n");
		portString.append("				sock = ssock.accept();" + "\r\n");
		portString
				.append("				if(component.hc.debugmode)TTCN3Logger.writeLog(component.compid + \":\" + port.name + \"--buffer-daemon\", \"PORTEVENT\", \"Buffer daemon accepted connection on port \" + portnum, false);"
						+ "\r\n");
		portString.append("			}catch(Exception e){e.printStackTrace();}"
				+ "\r\n");
		portString.append("		}else{" + "\r\n");
		portString.append("			boolean scanning = true;" + "\r\n");
		portString
				.append("			if(component.hc.debugmode)TTCN3Logger.writeLog(component.compid + \":\" + port.name + \"--buffer-daemon\", \"PORTEVENT\", \"Buffer daemon initiating connection on port \" + portnum, false);"
						+ "\r\n");
		portString.append("			while(scanning){" + "\r\n");
		portString.append("				try{" + "\r\n");
		portString.append("					sock = new Socket(ip,portnum);" + "\r\n");
		portString.append("					scanning = false;" + "\r\n");
		portString
				.append("					if(component.hc.debugmode)TTCN3Logger.writeLog(component.compid + \":\" + port.name + \"--buffer-daemon\", \"PORTEVENT\", \"Buffer daemon connectied on port \" + portnum, false);"
						+ "\r\n");
		portString.append("				}catch(Exception e){e.printStackTrace();}"
				+ "\r\n");
		portString.append("			}" + "\r\n");
		portString.append("		}" + "\r\n");
		portString.append("		try{" + "\r\n");
		portString
				.append("			port.owriter = new ObjectOutputStream(sock.getOutputStream());"
						+ "\r\n");
		portString
				.append("			ObjectInputStream oreader = new ObjectInputStream(sock.getInputStream());"
						+ "\r\n");
		portString.append("			port.mapped = true;" + "\r\n");
		portString.append("			for(;;){" + "\r\n");
		portString
				.append("				if(component.hc.debugmode)TTCN3Logger.writeLog(component.compid + \":\" + port.name + \"--buffer-daemon\", \"PORTEVENT\", \"Buffer daemon waiting\", false);"
						+ "\r\n");

		portString.append("				Object o = oreader.readObject(); " + "\r\n");
		portString.append("				if(o==null) break; " + "\r\n");
		portString
				.append("				if(component.hc.debugmode)TTCN3Logger.writeLog(component.compid + \":\" + port.name + \"--buffer-daemon\", \"PORTEVENT\", \"Buffer daemon received message\", false);"
						+ "\r\n");
		portString.append("				port.enqueue(o); " + "\r\n");

		portString.append("			}" + "\r\n");
		portString.append("			if(!isinitiator) ssock.close();" + "\r\n");
		portString.append("			sock.close();" + "\r\n");
		portString.append("		}catch(Exception e){e.printStackTrace();}"
				+ "\r\n");
		portString.append("	}" + "\r\n");
		portString.append("}" + "\r\n");

		code.newLine();
		code.append(portString);
	}

	public void clearLists() {
		isPortTypeAReferencedType = false;
		isPortInternal = false;

		inMessageName.clear();
		outMessageName.clear();
		inOutMessageName.clear();
	}

	public String getJavaSource() {
		code.clear();
		AstWalkerJava.logToConsole("	Starting processing:  Port " + nodeName);
		code.line("public class ", nodeName, " extends MessagePortDef {");

		isPortInternal = myASTVisitor.portNamePortTypeHashMap.get(nodeName).equals("TP_INTERNAL");
		if (!isPortInternal) {
			this.writeExternalPorts();
			Additional_Class_Writer.writeExternalPortClass(nodeName);
		}
		this.writeReceive();
		this.writeTypedReceive();
		this.writeObjectReceive();
		this.send();
		this.writeConstructor();
		this.writePrepareforconnection();
		this.writeConnect();
		this.writeDisconnect();
		this.writeMap();
		this.writeBufferDaemon();
		code.line("}");
		AstWalkerJava.logToConsole("	Finished processing:  Port " + nodeName);
		return code.toString();
	}

}
package org.eclipse.titan.codegenerator;

import java.util.LinkedHashMap;
import java.util.Map;

import org.eclipse.titan.designer.AST.TTCN3.definitions.Def_Type;

public class Def_Type_Record_Of_Writer implements JavaSourceProvider {

	private static Map<String, Def_Type_Record_Of_Writer> writers = new LinkedHashMap<>();

	public static Def_Type_Record_Of_Writer getInstance(Def_Type typeNode) {
		String id = typeNode.getIdentifier().toString();
		if (writers.containsKey(id)) {
			return writers.get(id);
		}
		Def_Type_Record_Of_Writer writer = new Def_Type_Record_Of_Writer(typeNode);
		writers.put(id, writer);
		return writer;
	}

	private SourceCode code = new SourceCode();

	private final String typeName;
	private String fieldType;

	public Def_Type_Record_Of_Writer(Def_Type typeNode) {
		typeName = typeNode.getIdentifier().toString();
	}

	public void setFieldType(String fieldType) {
		this.fieldType = fieldType;
	}

	@Override
	public String getJavaSource() {
		code.clear();
		AstWalkerJava.logToConsole("	Starting processing: RecordOf " + typeName);
		code.line("import java.util.Arrays;");
		code.line();
		code.line("class ", typeName, " extends RecordOfDef<", fieldType, "> {");
		writeTemplateObjects();
		code.line();
		writeConstructors();
		code.line();
		writeMatcher();
		code.line();
		writeEquals();
		code.line();
		this.writeCheckValue();
		code.line();
		code.line("}");
		AstWalkerJava.logToConsole("	Finishing processing: RecordOf " + typeName);
		return code.toString();
	}

	private void writeTemplateObjects() {
		code.indent(1).line("public static final ", typeName, " ANY = new ", typeName, "();");
		code.indent(1).line("public static final ", typeName, " OMIT = new ", typeName, "();");
		code.indent(1).line("public static final ", typeName, " ANY_OR_OMIT = new ", typeName, "();");
		code.newLine();
		code.indent(1).line("static {");
		code.indent(2).line("ANY.anyField = true;");
		code.indent(2).line("OMIT.omitField = true;");
		code.indent(2).line("ANY_OR_OMIT.anyOrOmitField = true;");
		code.indent(1).line("}");
	}

	private void writeConstructors() {
		code.indent(1).line("public ", typeName, "(", fieldType, "... values) {");
		code.indent(2).line("this(Arrays.asList(values));");
		code.indent(1).line("}");
		code.line();
		code.indent(1).line("public ", typeName, "(List<", fieldType, "> list) {");
		code.indent(2).line("value = list;");
		code.indent(1).line("}");
	}

	private void writeMatcher() {
		code.indent(1).line("public static boolean match(", typeName, " pattern, Object message) {");
		code.indent(2).line("if (!(message instanceof ", typeName, ")) return false;");
		// TODO : introduce a type-safe variable instead of casting it each time
		// TODO : simplify the if statements into one boolean expression (eg.: a && b || c)
		code.indent(2).line("if (pattern.omitField && ((", typeName, ")message).omitField) return true;");
		code.indent(2).line("if (pattern.anyOrOmitField) return true;");
		code.indent(2).line("if (pattern.anyField && !((", typeName, ")message).omitField) return true;");
		code.indent(2).line("if (pattern.anyField && !((", typeName, ")message).omitField) return true;");
		code.indent(2).line("if (pattern.omitField && !((", typeName, ")message).omitField) return false;");
		code.indent(2).line("if (pattern.anyField && ((", typeName, ")message).omitField) return false;");
		code.indent(2).line("return pattern.equals((", typeName, ")message).getValue();");
		code.indent(1).line("}");
	}

	private void writeEquals() {
		code.indent(1).line("public BOOLEAN equals(RecordOfDef<", fieldType, "> v) {");
		code.indent(2).line("if (value.size() != v.value.size()) return BOOLEAN.FALSE;");
		code.indent(2).line("for (int i = 0; i < value.size(); ++i) {");
		code.indent(3).line("if (value.get(i) != v.value.get(i)) return BOOLEAN.FALSE;");
		code.indent(2).line("}");
		code.indent(2).line("return BOOLEAN.TRUE;");
		code.indent(1).line("}");
	}
	
	private void writeCheckValue(){
		code.indent(1).line(" public void checkValue() throws IndexOutOfBoundsException {");
		code.indent(2).line("	return;");
		code.indent(1).line("}");
	}
}
/******************************************************************************
 * Copyright (c) 2000-2017 Ericsson Telecom AB
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   
 *   Keremi, Andras
 *   Eros, Levente
 *   Kovacs, Gabor
 *   Meszaros, Mate Robert
 *
 ******************************************************************************/

package org.eclipse.titan.codegenerator;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.StringJoiner;

import org.eclipse.titan.designer.AST.TTCN3.definitions.Def_Type;

public class Def_Type_Record_Writer implements JavaSourceProvider {

	private SourceCode code = new SourceCode();

	private List<Field> fields = new ArrayList<>();

	private final String nodeName;

	private static Map<String, Object> recordHashes = new LinkedHashMap<>();

	Def_Type_Record_Writer(Def_Type typeNode) {
		this.nodeName = typeNode.getIdentifier().toString();
	}

	public static Def_Type_Record_Writer getInstance(Def_Type typeNode) {
		if (!recordHashes.containsKey(typeNode.getIdentifier().toString())) {
			recordHashes.put(typeNode.getIdentifier().toString(),
					new Def_Type_Record_Writer(typeNode));
		}
		return (Def_Type_Record_Writer) recordHashes.get(typeNode
				.getIdentifier().toString());
	}

	public void add(List<String> fieldTypes, List<String> fieldNames) {
		if (fieldTypes.size() != fieldNames.size()) {
			// TODO : log the error, or throw an exception?
			System.err.println("Record field type-name array size mismatch!");
		}
		for (int i = 0; i < fieldTypes.size(); i++) {
			fields.add(new Field(fieldTypes.get(i), fieldNames.get(i)));
		}
	}

	private void writeTemplateObjects() {
		code.indent(1).line("public static final ", nodeName, " ANY = new ", nodeName, "();");
		code.indent(1).line("public static final ", nodeName, " OMIT = new ", nodeName, "();");
		code.indent(1).line("public static final ", nodeName, " ANY_OR_OMIT = new ", nodeName, "();");
		code.newLine();
		code.indent(1).line("static {");
		code.indent(2).line("ANY.anyField = true;");
		code.indent(2).line("OMIT.omitField = true;");
		code.indent(2).line("ANY_OR_OMIT.anyOrOmitField = true;");
		code.indent(1).line("}");
	}

	private void writeCompFields() {
		for (Field f : fields) {
			code.indent(1).line(f, ";");
		}
	}

	private void writeMatcher() {
		code.indent(1).line("public static boolean match(", nodeName, " pattern, Object object) {");
		code.indent(2).line("if (!(object instanceof ", nodeName, ")) return false;");
		code.indent(2).line(nodeName, " message = (", nodeName, ") object;");
		code.indent(2).line("if (pattern.omitField && message.omitField) return true;");
		code.indent(2).line("if (pattern.anyOrOmitField) return true;");
		code.indent(2).line("if (pattern.anyField && !message.omitField) return true;");
		code.indent(2).line("if (pattern.omitField && !message.omitField) return false;");
		code.indent(2).line("if (pattern.anyField && message.omitField) return false;");
		code.indent(2).append("return true");
		for (Field f : fields) {
			code.newLine();
			code.indent(4).append("&& ", f.type, ".match(pattern.", f.name, ", message.", f.name, ")");
		}
		code.append(";").newLine();
		code.indent(1).line("}");
	}

	private void writeEquals() {
		code.indent(1).line("public BOOLEAN equals(", nodeName, " v) {");
		for (Field f : fields) {
			code.indent(2).line("if (!", f.name, ".equals(v.", f.name, ").getValue())return BOOLEAN.FALSE;");
		}
		code.indent(2).line("return BOOLEAN.TRUE;");
		code.indent(1).line("}");
	}

	private void writeConstructor() {
		code.indent(1).line(nodeName, "() {");
		code.indent(2).line("super();");
		for (Field f : fields) {
			code.indent(2).line("fieldsInOrder.add(\"", f.name, "\");");
		}
		code.indent(1).line("}");

		if (0 < fields.size()) {
			code.newLine();
			StringJoiner params = new StringJoiner(", ");
			fields.forEach(f -> params.add(f.toString()));
			code.indent(1).line("public ", nodeName, "(", params, ") {");
			code.indent(2).line("this();");
			for (Field f : fields) {
				code.indent(2).line("this.", f.name, " = ", f.name, ";");
			}
			code.indent(1).line("}");
		}
	}

	private void writeToString() {
		code.indent(1).line("public String toString() {");
		code.indent(2).line("return toString(\"\");");
		code.indent(1).line("}");
	}

	private void writeToStringWithParam() {
		code.indent(1).line("public String toString(String tabs) {");
		code.indent(2).line("if (anyField) return \"?\";");
		code.indent(2).line("if (omitField) return \"omit\";");
		code.indent(2).line("if (anyOrOmitField) return \"*\";");
		code.indent(2).line("return \"{\\n\" + ");
		for (int i = 0; i < fields.size(); i++) {
			String name = fields.get(i).name;
			code.indent(4).append("tabs + \"\\t\" + \"", name, " := \" + ", name, ".toString(tabs + \"\\t\") + \"");
			if (i < fields.size() - 1) {
				code.append(",");
			}
			code.line("\\n\" +");
		}
		code.indent(4).line("tabs + \"}\";");
		code.indent(1).line("}");
	}

	public void clearLists() {
		fields.clear();
	}
	
	private void writeCheckValue(){
		code.indent(1).line(" public void checkValue() throws IndexOutOfBoundsException {");
		code.indent(2).line("	return;");
		code.indent(1).line("}");
	}

	@Override
	public String getJavaSource() {
		code.clear();
		AstWalkerJava.logToConsole("	Starting processing:  Record " + nodeName);
		code.line("public class ", nodeName, " extends RecordDef {");
		this.writeTemplateObjects();
		code.newLine();
		this.writeCompFields();
		code.newLine();
		this.writeConstructor();
		code.newLine();
		this.writeMatcher();
		code.newLine();
		this.writeEquals();
		code.newLine();
		this.writeToStringWithParam();
		code.newLine();
		this.writeToString();
		code.line();
		this.writeCheckValue();
		code.line();
		code.line("}");
		AstWalkerJava.logToConsole("	Finished processing:  Record " + nodeName);
		return code.toString();
	}
}
/******************************************************************************
 * Copyright (c) 2000-2017 Ericsson Telecom AB
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   
 *   Keremi, Andras
 *   Eros, Levente
 *   Kovacs, Gabor
 *   Meszaros, Mate Robert
 *
 ******************************************************************************/

package org.eclipse.titan.codegenerator;

import java.util.LinkedHashMap;
import java.util.Map;

import org.eclipse.titan.designer.AST.TTCN3.definitions.Def_Type;

public class Def_Type_Set_Of_Writer implements JavaSourceProvider {

	private static Map<String, Def_Type_Set_Of_Writer> setOfHashes = new LinkedHashMap<>();

	public static Def_Type_Set_Of_Writer getInstance(Def_Type typeNode) {
		String id = typeNode.getIdentifier().toString();
		if (!setOfHashes.containsKey(id)) {
			setOfHashes.put(id, new Def_Type_Set_Of_Writer(typeNode));
		}
		return setOfHashes.get(id);
	}

	private SourceCode code = new SourceCode();

	private final String typeName;
	private String fieldType;

	public Def_Type_Set_Of_Writer(Def_Type typeNode) {
		typeName = typeNode.getIdentifier().toString();
	}

	public void setFieldType(String fieldType) {
		this.fieldType = fieldType;
	}

	@Override
	public String getJavaSource() {
		code.clear();
		AstWalkerJava.logToConsole("	Starting processing:  Set of " + typeName);
		code.line("import java.util.Arrays;");
		code.line();
		code.line("class ", typeName, " extends SetOfDef<", fieldType, "> {");
		writeTemplateObjects();
		code.line();
		writeConstructor();
		code.line();
		writeMatcher();
		code.line();
		writeEquals();
		code.line();
		writeCheckValue();
		code.line();
		code.line("}");
		AstWalkerJava.logToConsole("	Finished processing:  Set of " + typeName);
		return code.toString();
	}

	private void writeTemplateObjects() {
		code.indent(1).line("public static final ", typeName, " ANY = new ", typeName, "();");
		code.indent(1).line("public static final ", typeName, " OMIT = new ", typeName, "();");
		code.indent(1).line("public static final ", typeName, " ANY_OR_OMIT = new ", typeName, "();");
		code.newLine();
		code.indent(1).line("static {");
		code.indent(2).line("ANY.anyField = true;");
		code.indent(2).line("OMIT.omitField = true;");
		code.indent(2).line("ANY_OR_OMIT.anyOrOmitField = true;");
		code.indent(1).line("}");
	}

	private void writeConstructor() {
		code.indent(1).line("public ", typeName, "(", fieldType, "... values) {");
		code.indent(2).line("this(new HashSet<>(Arrays.asList(values)));");
		code.indent(1).line("}");
		code.line();
		code.indent(1).line("public ", typeName, "(HashSet<", fieldType, "> set) {");
		code.indent(2).line("value = set;");
		code.indent(1).line("}");
	}

	private void writeMatcher() {
		code.indent(1).line("public static boolean match(", typeName, " pattern, Object message) {");
		code.indent(2).line("if (!(message instanceof ", typeName, ")) return false;");
		// TODO : introduce a type-safe variable instead of casting it each time
		// TODO : simplify the if statements into one boolean expression (eg.: a && b || c)
		code.indent(2).line("if (pattern.omitField && ((", typeName, ")message).omitField) return true;");
		code.indent(2).line("if (pattern.anyOrOmitField) return true;");
		code.indent(2).line("if (pattern.anyField && !((", typeName, ")message).omitField) return true;");
		code.indent(2).line("if (pattern.anyField && !((", typeName, ")message).omitField) return true;");
		code.indent(2).line("if (pattern.omitField && !((", typeName, ")message).omitField) return false;");
		code.indent(2).line("if (pattern.anyField && ((", typeName, ")message).omitField) return false;");
		code.indent(2).line("return pattern.equals((", typeName, ")message).getValue();");
		code.indent(1).line("}");
	}

	private void writeEquals() {
		code.indent(1).line("public BOOLEAN equals(SetOfDef<", fieldType, "> v) {");
		code.indent(2).line("if (value.size() != v.value.size()) return BOOLEAN.FALSE;");
		code.indent(2).line("for (", fieldType, " i : value) {");
		code.indent(3).line("boolean found = false;");
		code.indent(3).line("for (", fieldType, " j : v.value) {");
		code.indent(4).line("if (i.equals(j).getValue()) {");
		code.indent(5).line("found = true;");
		code.indent(5).line("break;");
		code.indent(4).line("}");
		code.indent(3).line("}");
		code.indent(3).line("if (!found) return BOOLEAN.FALSE;");
		code.indent(2).line("}");
		code.indent(2).line("return BOOLEAN.TRUE;");
		code.indent(1).line("}");
	}
	
	private void writeCheckValue(){
		code.indent(1).line(" public void checkValue() throws IndexOutOfBoundsException {");
		code.indent(2).line("	return;");
		code.indent(1).line("}");
	}
	
}
package org.eclipse.titan.codegenerator;

import java.util.LinkedHashMap;
import java.util.Map;

import org.eclipse.titan.designer.AST.TTCN3.definitions.Def_Type;

public class Def_Type_Set_Of_Writer implements JavaSourceProvider {

	private static Map<String, Def_Type_Set_Of_Writer> setOfHashes = new LinkedHashMap<>();

	public static Def_Type_Set_Of_Writer getInstance(Def_Type typeNode) {
		String id = typeNode.getIdentifier().toString();
		if (!setOfHashes.containsKey(id)) {
			setOfHashes.put(id, new Def_Type_Set_Of_Writer(typeNode));
		}
		return setOfHashes.get(id);
	}

	private SourceCode code = new SourceCode();

	private final String typeName;
	private String fieldType;

	public Def_Type_Set_Of_Writer(Def_Type typeNode) {
		typeName = typeNode.getIdentifier().toString();
	}

	public void setFieldType(String fieldType) {
		this.fieldType = fieldType;
	}

	@Override
	public String getJavaSource() {
		code.clear();
		AstWalkerJava.logToConsole("	Starting processing:  Set of " + typeName);
		code.line("import java.util.Arrays;");
		code.line();
		code.line("class ", typeName, " extends SetOfDef<", fieldType, "> {");
		writeTemplateObjects();
		code.line();
		writeConstructor();
		code.line();
		writeMatcher();
		code.line();
		writeEquals();
		code.line();
		writeCheckValue();
		code.line();
		code.line("}");
		AstWalkerJava.logToConsole("	Finished processing:  Set of " + typeName);
		return code.toString();
	}

	private void writeTemplateObjects() {
		code.indent(1).line("public static final ", typeName, " ANY = new ", typeName, "();");
		code.indent(1).line("public static final ", typeName, " OMIT = new ", typeName, "();");
		code.indent(1).line("public static final ", typeName, " ANY_OR_OMIT = new ", typeName, "();");
		code.newLine();
		code.indent(1).line("static {");
		code.indent(2).line("ANY.anyField = true;");
		code.indent(2).line("OMIT.omitField = true;");
		code.indent(2).line("ANY_OR_OMIT.anyOrOmitField = true;");
		code.indent(1).line("}");
	}

	private void writeConstructor() {
		code.indent(1).line("public ", typeName, "(", fieldType, "... values) {");
		code.indent(2).line("this(new HashSet<>(Arrays.asList(values)));");
		code.indent(1).line("}");
		code.line();
		code.indent(1).line("public ", typeName, "(HashSet<", fieldType, "> set) {");
		code.indent(2).line("value = set;");
		code.indent(1).line("}");
	}

	private void writeMatcher() {
		code.indent(1).line("public static boolean match(", typeName, " pattern, Object message) {");
		code.indent(2).line("if (!(message instanceof ", typeName, ")) return false;");
		// TODO : introduce a type-safe variable instead of casting it each time
		// TODO : simplify the if statements into one boolean expression (eg.: a && b || c)
		code.indent(2).line("if (pattern.omitField && ((", typeName, ")message).omitField) return true;");
		code.indent(2).line("if (pattern.anyOrOmitField) return true;");
		code.indent(2).line("if (pattern.anyField && !((", typeName, ")message).omitField) return true;");
		code.indent(2).line("if (pattern.anyField && !((", typeName, ")message).omitField) return true;");
		code.indent(2).line("if (pattern.omitField && !((", typeName, ")message).omitField) return false;");
		code.indent(2).line("if (pattern.anyField && ((", typeName, ")message).omitField) return false;");
		code.indent(2).line("return pattern.equals((", typeName, ")message).getValue();");
		code.indent(1).line("}");
	}

	private void writeEquals() {
		code.indent(1).line("public BOOLEAN equals(SetOfDef<", fieldType, "> v) {");
		code.indent(2).line("if (value.size() != v.value.size()) return BOOLEAN.FALSE;");
		code.indent(2).line("for (", fieldType, " i : value) {");
		code.indent(3).line("boolean found = false;");
		code.indent(3).line("for (", fieldType, " j : v.value) {");
		code.indent(4).line("if (i.equals(j).getValue()) {");
		code.indent(5).line("found = true;");
		code.indent(5).line("break;");
		code.indent(4).line("}");
		code.indent(3).line("}");
		code.indent(3).line("if (!found) return BOOLEAN.FALSE;");
		code.indent(2).line("}");
		code.indent(2).line("return BOOLEAN.TRUE;");
		code.indent(1).line("}");
	}
	
	private void writeCheckValue(){
		code.indent(1).line(" public void checkValue() throws IndexOutOfBoundsException {");
		code.indent(2).line("	return;");
		code.indent(1).line("}");
	}
	
}
package org.eclipse.titan.codegenerator;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.StringJoiner;

import org.eclipse.titan.designer.AST.TTCN3.definitions.Def_Type;

public class Def_Type_Set_Writer implements JavaSourceProvider {

	private static Map<String, Object> setHashes = new LinkedHashMap<>();

	public static Def_Type_Set_Writer getInstance(Def_Type typeNode) {
		if (!setHashes.containsKey(typeNode.getIdentifier().toString())) {
			setHashes.put(typeNode.getIdentifier().toString(),
					new Def_Type_Set_Writer(typeNode));
		}
		return (Def_Type_Set_Writer) setHashes.get(typeNode.getIdentifier()
				.toString());
	}

	private SourceCode code = new SourceCode();
	private List<Field> fields = new ArrayList<>();
	private final String nodeName;

	Def_Type_Set_Writer(Def_Type typeNode) {
		super();
		nodeName = typeNode.getIdentifier().toString();
	}

	public void add(List<String> fieldTypes, List<String> fieldNames) {
		if (fieldTypes.size() != fieldNames.size()) {
			// TODO : log the error, or throw an exception?
			System.err.println("Record field type-name array size mismatch!");
		}
		for (int i = 0; i < fieldTypes.size(); i++) {
			fields.add(new Field(fieldTypes.get(i), fieldNames.get(i)));
		}
	}

	private void writeTemplateObjects() {
		code.indent(1).line("public static final ", nodeName, " ANY = new ", nodeName, "();");
		code.indent(1).line("public static final ", nodeName, " OMIT = new ", nodeName, "();");
		code.indent(1).line("public static final ", nodeName, " ANY_OR_OMIT = new ", nodeName, "();");
		code.newLine();
		code.indent(1).line("static {");
		code.indent(2).line("ANY.anyField = true;");
		code.indent(2).line("OMIT.omitField = true;");
		code.indent(2).line("ANY_OR_OMIT.anyOrOmitField = true;");
		code.indent(1).line("}");
	}

	private void writeCompFields() {
		for (Field f : fields) {
			code.indent(1).line(f, ";");
		}
	}

	private void writeConstructors() {
		code.indent(1).line("public ", nodeName, "() {");
		code.indent(1).line("}");
		if (0 < fields.size()) {
			code.newLine();
			StringJoiner params = new StringJoiner(", ");
			fields.forEach(f -> params.add(f.toString()));
			code.indent(1).line("public ", nodeName, "(", params, ") {");
			code.indent(2).line("this();");
			for (Field f : fields) {
				code.indent(2).line("this.", f.name, " = ", f.name, ";");
			}
			code.indent(1).line("}");
		}
	}

	private void writeMatcher() {
		code.indent(1).line("public static boolean match(", nodeName, " pattern, Object object) {");
		code.indent(2).line("if (!(object instanceof ", nodeName, ")) return false;");
		code.indent(2).line(nodeName, " message = (", nodeName, ") object;");
		code.indent(2).line("if (pattern.omitField && message.omitField) return true;");
		code.indent(2).line("if (pattern.anyOrOmitField) return true;");
		code.indent(2).line("if (pattern.anyField && !message.omitField) return true;");
		code.indent(2).line("if (pattern.omitField && !message.omitField) return false;");
		code.indent(2).line("if (pattern.anyField && message.omitField) return false;");

		code.indent(2).append("return true");
		for (Field f : fields) {
			code.newLine().indent(4);
			code.append(" && ", f.type, ".match(pattern.", f.name, ", (message)." + f.name + ")");
		}
		code.append(";").newLine();

		code.indent(1).line("}");
	}

	private void writeEquals() {
		code.indent(1).line("public BOOLEAN equals(", nodeName, " v) {");
		for (Field f : fields) {
			code.indent(2).line("if (!", f.name, ".equals(v.", f.name, ").getValue()) return BOOLEAN.FALSE;");
		}
		code.indent(2).line("return BOOLEAN.TRUE;");
		code.indent(1).line("}");
	}

	private void writeToString() {
		code.indent(1).line("public String toString() {");
		code.indent(2).line("return toString(\"\");");
		code.indent(1).line("}");
	}

	private void writeToStringWithParam() {
		code.indent(1).line("public String toString(String tabs) {");
		code.indent(2).line("if (anyField) return \"?\";");
		code.indent(2).line("if (omitField) return \"omit\";");
		code.indent(2).line("if (anyOrOmitField) return \"*\";");
		code.indent(2).line("return \"{\\n\" + ");
		for (int i = 0; i < fields.size(); i++) {
			String name = fields.get(i).name;
			code.indent(4).append("tabs + \"\\t\" + \"", name, " := \" + ", name, ".toString(tabs + \"\\t\") + \"");
			if (i < fields.size() - 1) {
				code.append(",");
			}
			code.line("\\n\" +");
		}
		code.indent(4).line("tabs + \"}\";");
		code.indent(1).line("}");
	}

	private void writeCheckValue(){
		code.indent(1).line(" public void checkValue() throws IndexOutOfBoundsException {");
		code.indent(2).line("	return;");
		code.indent(1).line("}");
	}
	
	public void clearLists() {
		fields.clear();
	}

	@Override
	public String getJavaSource() {
		code.clear();
		AstWalkerJava.logToConsole("	Starting processing:  Set " + nodeName);
		code.line("public class ", nodeName, " extends SetDef {");
		this.writeTemplateObjects();
		code.newLine();
		this.writeCompFields();
		code.line();
		this.writeConstructors();
		code.line();
		this.writeMatcher();
		code.line();
		this.writeEquals();
		code.line();
		this.writeToStringWithParam();
		code.line();
		this.writeToString();
		code.line();
		this.writeCheckValue();
		code.line();
		code.line("}");
		AstWalkerJava.logToConsole("	Finished processing:  Set " + nodeName);
		return code.toString();
	}
}
/******************************************************************************
 * Copyright (c) 2000-2017 Ericsson Telecom AB
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   
 *   Keremi, Andras
 *   Eros, Levente
 *   Kovacs, Gabor
 *   Meszaros, Mate Robert
 *
 ******************************************************************************/

package org.eclipse.titan.codegenerator;

import java.util.ArrayList;
import java.util.List;

import org.eclipse.titan.designer.AST.TTCN3.definitions.Def_Type;

public class Def_Type_Union_Writer {
	private SourceCode code = new SourceCode();

	private List<Field> fields = new ArrayList<>();

	private String nodeName = null;

	public Def_Type_Union_Writer(Def_Type typeNode) {
		super();
		nodeName = typeNode.getIdentifier().toString();
	}

	public void add(List<String> fieldTypes, List<String> fieldNames) {
		if (fieldTypes.size() != fieldNames.size()) {
			// TODO : log the error, or throw an exception?
			System.err.println("Record field type-name array size mismatch!");
		}
		for (int i = 0; i < fieldTypes.size(); i++) {
			fields.add(new Field(fieldTypes.get(i), fieldNames.get(i)));
		}
	}

	private String getClassName(Field field) {
		return "SC_" + field.name + "_" + nodeName;
	}

	private void writeMatcher() {
		code.indent(1).line("public static boolean match(", nodeName, " pattern, Object message) {");
		code.indent(2).line("if (!(message instanceof ", nodeName, ")) return false;");
		code.indent(2).line("if (pattern.omitField && ((" + nodeName + ") message).omitField) return true;");
		code.indent(2).line("if (pattern.anyOrOmitField) return true;");
		code.indent(2).line("if (pattern.anyField && !((", nodeName, ") message).omitField) return true;");
		code.indent(2).line("if (pattern.omitField && !((", nodeName, ") message).omitField) return false;");
		code.indent(2).line("if (pattern.anyField && ((", nodeName, ") message).omitField) return false;");
		for (Field f : fields) {
			String className = getClassName(f);
			code.indent(2).line("if (pattern instanceof ", className, " && message instanceof ", className, ")");
			code.indent(3).line("return ", className, ".match((", className, ") pattern, (", className, ") message);");
		}
		code.indent(2).line("return false;");
		code.indent(1).line("}").newLine();
	}

	private void writeEquals() {
		code.indent(1).line("public BOOLEAN equals(" + nodeName + " v) {");
		for (Field f : fields) {
			String className = getClassName(f);
			code.indent(2).line("if (this instanceof ", className, " && v instanceof ", className, ")");
			code.indent(3).line("return ((", className, ") this).equals((", className, ") v);");
		}
		code.indent(2).line("return BOOLEAN.FALSE;");
		code.indent(1).line("}");
	}

	public void writeUnionClasses() {
		String fileNameBackup = myASTVisitor.currentFileName;

		for (Field f : fields) {
			SourceCode code = new SourceCode();
			// set file name
			String className = getClassName(f);
			myASTVisitor.currentFileName = className;
			myASTVisitor.visualizeNodeToJava(myASTVisitor.importListStrings);

			code.line("public class ", className, " extends ", nodeName, " {");

			String type = f.type;
			String name = f.name;

			code.indent(1).line("public ", type, " ", name, ";").newLine();

			code.indent(1).line("public ", className, "() {}").newLine();
			code.indent(1).line("public ", className, "(", type, " ", name,") {");
			code.indent(2).line("this.", name, " = ", name, ";");
			code.indent(1).line("}").newLine();

			code.indent(1).line("public static boolean match(", className, " pattern, Object message) {");
			code.indent(2).line("if (!(message instanceof ", className, ")) return false;");
			code.indent(2).line("if (pattern.omitField && ((" + className + ") message).omitField) return true;");
			code.indent(2).line("if (pattern.anyOrOmitField) return true;");
			code.indent(2).line("if (pattern.anyField && !((", className, ") message).omitField) return true;");
			code.indent(2).line("if (pattern.omitField && !((", className, ") message).omitField) return false;");
			code.indent(2).line("if (pattern.anyField && ((", className, ") message).omitField) return false;");
			code.indent(2).line("return ", type, ".match(pattern.", name, ", ((", className, ")message).", name, ");");
			code.indent(1).line("}").newLine();

			code.indent(1).line("public BOOLEAN equals(", className, " v) {");
			code.indent(2).line("return this.", name, ".equals(v.", name, ");");
			code.indent(1).line("}").newLine();

			code.indent(1).line("public String toString() {");
			code.indent(2).line("return toString(\"\");");
			code.indent(1).line("}").newLine();

			code.indent(1).line("public String toString(String tabs) {");
			code.indent(2).line("if(anyField) return \"?\";");
			code.indent(2).line("if(omitField) return \"omit\";");
			code.indent(2).line("if(anyOrOmitField) return \"*\";");
			code.indent(2).line("return ", name, ".toString(tabs);");
			code.indent(1).line("}").newLine();

			code.line("}");

			myASTVisitor.visualizeNodeToJava(code.toString());
		}
		myASTVisitor.currentFileName = fileNameBackup;
	}

	public void writeToString() {
		code.indent(1).line("public String toString() {");
		code.indent(2).line("return toString(\"\");");
		code.indent(1).line("}");
	}

	public void writeToStringWithParam() {
		code.indent(1).line("public String toString(String tabs) {");
		code.indent(2).line("if (anyField) return \"?\";");
		code.indent(2).line("if (omitField) return \"omit\";");
		code.indent(2).line("if (anyOrOmitField) return \"*\";");
		for (Field f : fields) {
			String className = getClassName(f);
			code.indent(2).line("if (this instanceof ", className, ")");
			code.indent(3).line("return ((", className, ") this).toString(tabs);");
		}
		code.indent(2).line("return \"\";");
		code.indent(1).line("}");
	}
	
	public void writeCheckValue(){
		code.indent(1).line("public void checkValue() throws IndexOutOfBoundsException {");
		code.indent(1).line("}");
	}

	public String getJavaSource() {
		code.clear();
		AstWalkerJava.logToConsole("	Starting processing:  Union " + nodeName);
		code.line("public class ", nodeName, " extends UnionDef {");
		this.writeMatcher();
		code.newLine();
		this.writeEquals();
		code.newLine();
		this.writeToString();
		code.newLine();
		this.writeCheckValue();
		code.newLine();
		this.writeToStringWithParam();
		code.newLine();
		code.line("}");

		this.writeUnionClasses();

		AstWalkerJava.logToConsole("	Finished processing:  Union " + nodeName);
		return code.toString();
	}

}
/******************************************************************************
 * Copyright (c) 2000-2017 Ericsson Telecom AB
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   
 *   Keremi, Andras
 *   Eros, Levente
 *   Kovacs, Gabor
 *   Meszaros, Mate Robert
 *
 ******************************************************************************/

package org.eclipse.titan.codegenerator;

import java.util.ArrayList;
import java.util.List;

import org.eclipse.titan.designer.AST.IVisitableNode;
import org.eclipse.titan.designer.AST.Reference;
import org.eclipse.titan.designer.AST.TTCN3.definitions.Def_Port;
import org.eclipse.titan.designer.AST.TTCN3.definitions.Def_Type;
import org.eclipse.titan.designer.AST.TTCN3.definitions.Def_Var;
import org.eclipse.titan.designer.AST.TTCN3.types.CharString_Type;
import org.eclipse.titan.designer.AST.TTCN3.types.CompField;
import org.eclipse.titan.designer.AST.TTCN3.types.EnumerationItems;
import org.eclipse.titan.designer.AST.TTCN3.types.Integer_Type;
import org.eclipse.titan.designer.AST.TTCN3.types.PortTypeBody;
import org.eclipse.titan.designer.AST.TTCN3.types.Referenced_Type;
import org.eclipse.titan.designer.AST.TTCN3.types.SequenceOf_Type;
import org.eclipse.titan.designer.AST.TTCN3.types.SetOf_Type;
import org.eclipse.titan.designer.AST.TTCN3.types.TTCN3_Enumerated_Type;
import org.eclipse.titan.designer.AST.TTCN3.types.subtypes.Range_ParsedSubType;
import org.eclipse.titan.designer.AST.TTCN3.values.Charstring_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Integer_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Real_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Undefined_LowerIdentifier_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.AddExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.DivideExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.EqualsExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.GreaterThanExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.GreaterThanOrEqualExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.LessThanExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.LessThanOrEqualExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.Log2StrExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.ModuloExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.MultiplyExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.NotExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.NotequalesExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.RemainderExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.Str2IntExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.SubstractExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.ValueofExpression;
import org.eclipse.titan.designer.AST.Type;
import org.eclipse.titan.designer.parsers.CompilationTimeStamp;

import static org.eclipse.titan.designer.AST.IType.Type_type.TYPE_COMPONENT;
import static org.eclipse.titan.designer.AST.IType.Type_type.TYPE_PORT;
import static org.eclipse.titan.designer.AST.IType.Type_type.TYPE_SEQUENCE_OF;
import static org.eclipse.titan.designer.AST.IType.Type_type.TYPE_SET_OF;
import static org.eclipse.titan.designer.AST.IType.Type_type.TYPE_TTCN3_CHOICE;
import static org.eclipse.titan.designer.AST.IType.Type_type.TYPE_TTCN3_SEQUENCE;
import static org.eclipse.titan.designer.AST.IType.Type_type.TYPE_TTCN3_SET;

public class Def_Type_Visit_Handler {

	private static String setOfFieldType = null;
	private static String recordOfFieldType = null;
	private static String currentPortName;
	private static String charstringValue = null;
	private static String parentName = null;

	private static boolean waitForSetOfFieldType = false;
	private static boolean waitForRecordOfFieldType = false;
	private static boolean isPortTypeAReferencedType = false;
	private static boolean waitingForPortAttriburtes = false;
	private static boolean waitForCompReference = false;
	private static boolean waitForDefType = false;
	private static boolean waitForValue = false;

	public static List<String> portTypeList = new ArrayList<String>();
	private static List<String> componentPortTypes = new ArrayList<String>();
	private static List<String> componentPortNames = new ArrayList<String>();
	private static List<String> componentVarTypes = new ArrayList<String>();
	private static List<String> componentVarNames = new ArrayList<String>();
	private static List<String> compFieldTypes = new ArrayList<String>();
	private static List<String> compFieldNames = new ArrayList<String>();
	private static List<String> enumItems = new ArrayList<String>();
	private static List<String> enumItemValues = new ArrayList<String>();
	private static List<String> inMessageName = new ArrayList<String>();
	private static List<String> outMessageName = new ArrayList<String>();
	private static List<String> inOutMessageName = new ArrayList<String>();

	private static List<String> expressionValue = new ArrayList<String>();
	private boolean isInteger = false;

	CompilationTimeStamp compilationCounter = CompilationTimeStamp.getNewCompilationCounter();
	
	public void visit(IVisitableNode node) {
		if (node instanceof Def_Type) {
			Def_Type_Integer_Writer.allowedValues.clear();
			expressionValue.clear();// Str2IntExpression Log2StrExpression
									// ValueofExpression
			visitDefTypeNodes(node);
			charstringValue = null;
			waitForDefType = true;
			waitForValue = true;

		}

		if (waitForDefType) {
			visitDefTypeChildrenNodes(node);
			visitExpressionTypeSelectors(node);
		}
	}

	public void evaluateExpression() {
		int size = expressionValue.size() - 1;
		boolean operatorFound = false;
		boolean unaryOperatorFound = false;
		String rightHand = "";
		String leftHand = "";

		for (int i = size; i >= 0; i--) {

			if (myASTVisitor.nodeNameNodeTypeHashMap.containsKey(expressionValue.get(i))) {

				if (myASTVisitor.nodeNameNodeTypeHashMap.get(expressionValue.get(i)).equals("constant")) {
					expressionValue.set(i, "Constants." + expressionValue.get(i) + "().value");

				} else if (myASTVisitor.nodeNameNodeTypeHashMap.get(expressionValue.get(i)).equals("template")) {
					expressionValue.set(i, "Templates." + expressionValue.get(i) + "()");

				} else if (myASTVisitor.nodeNameNodeTypeHashMap.get(expressionValue.get(i)).equals("INTEGER")
						||myASTVisitor.nodeNameNodeTypeHashMap.get(expressionValue.get(i)).equals("CHARSTRING")
						||myASTVisitor.nodeNameNodeTypeHashMap.get(expressionValue.get(i)).equals("BITSTRING")
						||myASTVisitor.nodeNameNodeTypeHashMap.get(expressionValue.get(i)).equals("BOOLEAN")
						||myASTVisitor.nodeNameNodeTypeHashMap.get(expressionValue.get(i)).equals("OCTETSTRING")
						||myASTVisitor.nodeNameNodeTypeHashMap.get(expressionValue.get(i)).equals("HEXSTRING")
						) {
					if (myASTVisitor.nodeNameAllowedValuesHashmap.containsKey(expressionValue.get(i))) {

						expressionValue.set(i, myASTVisitor.nodeNameAllowedValuesHashmap.get(expressionValue.get(i)));

					}
				}

			}

			if (i <= size - 2) {
				leftHand = expressionValue.get(i + 1);
				rightHand = expressionValue.get(i + 2);
			}

			//
			if (expressionValue.get(i).equals("Str2IntExpression")) {
				expressionValue.set(i, "(" + expressionValue.get(i + 1) + ".str2int())");
				unaryOperatorFound = true;
			} else if (expressionValue.get(i).equals("Log2StrExpression")) {
				expressionValue.set(i, "(" + expressionValue.get(i + 1) + ".log2str())");
				unaryOperatorFound = true;
			} else if (expressionValue.get(i).equals("ValueofExpression")) {
				expressionValue.set(i, "(" + expressionValue.get(i + 1) + ").value");
				unaryOperatorFound = true;
			} else if (expressionValue.get(i).equals("NotExpression")) {
				expressionValue.set(i, "(" + expressionValue.get(i + 1) + ").not()");
				unaryOperatorFound = true;
			} else if (expressionValue.get(i).equals("AddExpression")) {
				expressionValue.set(i, "(" + leftHand + ").plus(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("SubstractExpression")) {
				expressionValue.set(i, "(" + leftHand + ").minus(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("MultiplyExpression")) {
				expressionValue.set(i, "(" + leftHand + ").multipleBy(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("DivideExpression")) {
				expressionValue.set(i, "(" + leftHand + ").divideBy(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("ModuloExpression")) {
				expressionValue.set(i, "(" + leftHand + ").mod(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("RemainderExpression")) {
				expressionValue.set(i, "(" + leftHand + ").rem(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("NotequalesExpression")) {
				expressionValue.set(i, "(" + leftHand + ").equalsWith(" + rightHand + ").not()");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("LessThanExpression")) {
				expressionValue.set(i, "(" + leftHand + ").isLessThan(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("LessThanOrEqualExpression")) {
				expressionValue.set(i, "(" + leftHand + ").isLessOrEqualThan(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("GreaterThanExpression")) {
				expressionValue.set(i, "(" + leftHand + ").isGreaterThan(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("GreaterThanOrEqualExpression")) {
				expressionValue.set(i, "(" + leftHand + ").isGreaterOrEqualThan(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("EqualsExpression")) {
				expressionValue.set(i, "(" + leftHand + ").equalsWith(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("Range_ParsedSubType")) {
				expressionValue.set(i, "new SubTypeInterval<INTEGER>(" + expressionValue.get(i + 1) + ","
						+ expressionValue.get(i + 2) + ")");
				operatorFound = true;

			}

			if (unaryOperatorFound) {
				unaryOperatorFound = false;
				expressionValue.remove(i + 1);
				size = expressionValue.size() - 1;
				i = size;
			} else if (operatorFound) {
				operatorFound = false;
				expressionValue.remove(i + 2);
				expressionValue.remove(i + 1);
				size = expressionValue.size() - 1;
				i = size;
			}

		}

		if (isInteger) {
			Def_Type_Integer_Writer.allowedValues.addAll(expressionValue);
		}

		expressionValue.clear();
	}

	public void visitExpressionTypeSelectors(IVisitableNode node) {

		if (waitForValue && (node instanceof AddExpression)) {
			expressionValue.add("AddExpression");
		}

		if (waitForValue && (node instanceof SubstractExpression)) {
			expressionValue.add("SubstractExpression");
		}

		if (waitForValue && (node instanceof MultiplyExpression)) {
			expressionValue.add("MultiplyExpression");
		}

		if (waitForValue && (node instanceof DivideExpression)) {
			expressionValue.add("DivideExpression");
		}

		if (waitForValue && (node instanceof ModuloExpression)) {
			expressionValue.add("ModuloExpression");
		}

		if (waitForValue && (node instanceof RemainderExpression)) {
			expressionValue.add("RemainderExpression");
		}

		if (waitForValue && (node instanceof NotequalesExpression)) {
			expressionValue.add("NotequalesExpression");
		}

		if (waitForValue && (node instanceof LessThanExpression)) {
			expressionValue.add("LessThanExpression");
		}

		if (waitForValue && (node instanceof LessThanOrEqualExpression)) {
			expressionValue.add("LessThanOrEqualExpression");
		}

		if (waitForValue && (node instanceof GreaterThanExpression)) {
			expressionValue.add("GreaterThanExpression");
		}

		if (waitForValue && (node instanceof GreaterThanOrEqualExpression)) {
			expressionValue.add("GreaterThanOrEqualExpression");
		}

		if (waitForValue && (node instanceof EqualsExpression)) {
			expressionValue.add("EqualsExpression");
		}

		if (waitForValue && (node instanceof NotExpression)) {
			expressionValue.add("NotExpression");
		}

		if (node instanceof Range_ParsedSubType) {
			expressionValue.add("Range_ParsedSubType");
		}

		if (node instanceof Str2IntExpression) {
			expressionValue.add("Str2IntExpression");
		}

		if (node instanceof Log2StrExpression) {
			expressionValue.add("Log2StrExpression");
		}

		if (node instanceof ValueofExpression) {
			expressionValue.add("ValueofExpression");
		}

		/*
		 * if (waitForValue && ((node instanceof RemainderExpression) || (node
		 * instanceof ModuloExpression) || (node instanceof DivideExpression) ||
		 * (node instanceof MultiplyExpression) || (node instanceof
		 * SubstractExpression) || (node instanceof AddExpression || (node
		 * instanceof NotequalesExpression) || (node instanceof
		 * LessThanExpression) || (node instanceof LessThanOrEqualExpression) ||
		 * (node instanceof GreaterThanExpression) || (node instanceof
		 * GreaterThanOrEqualExpression) || (node instanceof
		 * EqualsExpression)))) {
		 * 
		 * }
		 */

	}

	public void visitDefTypeNodes(IVisitableNode node) {

		Def_Type typeNode = (Def_Type) node;

		

		String nodeName = typeNode.getIdentifier().toString();
		myASTVisitor.currentFileName = nodeName;

		myASTVisitor.visualizeNodeToJava(myASTVisitor.importListStrings);

		Type type = typeNode.getType(compilationCounter);
		if (type.getTypetype().equals(TYPE_TTCN3_SEQUENCE)) {// record

			myASTVisitor.nodeNameNodeTypeHashMap.put(nodeName, "record");
			parentName = nodeName;

		} else if (type.getTypetype().equals(TYPE_TTCN3_SET)) {

			myASTVisitor.nodeNameNodeTypeHashMap.put(nodeName, "set");
			parentName = nodeName;

		} else if (type.getTypetype().equals(TYPE_TTCN3_CHOICE)) {

			myASTVisitor.nodeNameNodeTypeHashMap.put(nodeName, "union");
			parentName = nodeName;

		} else if (type instanceof Integer_Type) {

			Def_Type_Integer_Writer.getInstance(typeNode);

			myASTVisitor.nodeNameNodeTypeHashMap.put(nodeName, "INTEGER");
			parentName = nodeName;
			isInteger = true;

		} else if (type instanceof CharString_Type) {

			Def_Type_Charstring_Writer.getInstance(typeNode);

			myASTVisitor.nodeNameNodeTypeHashMap.put(nodeName, "CHARSTRING");
			parentName = nodeName;

		} else if (type instanceof TTCN3_Enumerated_Type) {

			Def_Type_Enum_Writer.getInstance(typeNode);

			myASTVisitor.nodeNameNodeTypeHashMap.put(nodeName, "enum");
			parentName = nodeName;

		} else if (type.getTypetype().equals(TYPE_SET_OF)) {

			waitForSetOfFieldType = true;
			myASTVisitor.nodeNameNodeTypeHashMap.put(nodeName, "setof");
			parentName = nodeName;

		} else if (type.getTypetype().equals(TYPE_SEQUENCE_OF)) {

			waitForRecordOfFieldType = true;
			myASTVisitor.nodeNameNodeTypeHashMap.put(nodeName, "recordof");
			parentName = nodeName;

		} else if (type.getTypetype().equals(TYPE_PORT)) {

			Def_Type_Port_Writer.getInstance(typeNode);

			waitingForPortAttriburtes = true;
			currentPortName = nodeName;
			myASTVisitor.nodeNameNodeTypeHashMap.put(nodeName, "port");
			parentName = nodeName;

		} else if (type.getTypetype().equals(TYPE_COMPONENT)) {

			Def_Type_Component_Writer.getInstance(typeNode);
			waitForCompReference = true;

			AstWalkerJava.componentList.add(nodeName);
			myASTVisitor.nodeNameNodeTypeHashMap.put(nodeName, "component");
			parentName = nodeName;
		}
	}

	public void visitDefTypeChildrenNodes(IVisitableNode node) {

		if (node instanceof Def_Port) {
			Def_Port port = (Def_Port) node;
			componentPortNames.add(port.getIdentifier().toString());
		}
		
		if (node instanceof Def_Var){
			Def_Var var = (Def_Var) node;
			componentVarNames.add(var.getIdentifier().toString());
			if(var.getType(compilationCounter) instanceof Integer_Type){
				componentVarTypes.add("INTEGER");
			}
		}

		if (waitForCompReference && (node instanceof Reference)) {
			componentPortTypes.add(((Reference) node).getId().toString());
		}

		if (waitForSetOfFieldType) {
			if (node instanceof Reference) {
				setOfFieldType = node.toString();
				myASTVisitor.nodeNameSetOfTypesHashMap.put(parentName, setOfFieldType);
				waitForSetOfFieldType = false;
			} else if (node instanceof Type && !(node instanceof Referenced_Type) && !(node instanceof SetOf_Type)) {
				Type type = (Type) node;
				setOfFieldType = TypeMapper.map(type.getTypename());
				myASTVisitor.nodeNameSetOfTypesHashMap.put(parentName, setOfFieldType);
				waitForSetOfFieldType = false;
			}
		}

		if (waitForRecordOfFieldType) {
			if (node instanceof Reference) {
				recordOfFieldType = node.toString();
				myASTVisitor.nodeNameRecordOfTypesHashMap.put(parentName, recordOfFieldType);
				waitForRecordOfFieldType = false;
			} else if (node instanceof Type && !(node instanceof Referenced_Type)
					&& !(node instanceof SequenceOf_Type)) {
				Type type = (Type) node;
				recordOfFieldType = TypeMapper.map(type.getTypename());
				myASTVisitor.nodeNameRecordOfTypesHashMap.put(parentName, recordOfFieldType);
				waitForRecordOfFieldType = false;
			}
		}

		if (node instanceof CompField) { // component

			CompField compFieldNode = (CompField) node;

			if (compFieldNode.getType() instanceof Referenced_Type) {

				compFieldTypes.add(((Referenced_Type) compFieldNode.getType()).getReference().getId().toString());
			} else {
				compFieldTypes.add(myASTVisitor.cutModuleNameFromBeginning(compFieldNode.getType().getTypename()));
			}
			compFieldNames.add(compFieldNode.getIdentifier().toString());

		}

		if (node instanceof Charstring_Value) {// charstring

			Charstring_Value singleValuedNode = (Charstring_Value) node;

			charstringValue = singleValuedNode.getValue();

		}

		if (node instanceof Integer_Value) {
			String value = ((Integer_Value) node).toString();
			if (myASTVisitor.isNextIntegerNegative) {
				value = "-" + value;
			}

			expressionValue.add("new INTEGER(\"" + value + "\")");
		}

		if (node instanceof Real_Value) {
			String value = ((Real_Value) node).toString();
			if (myASTVisitor.isNextIntegerNegative) {
				value = "-" + value;
			}

			if (value.equals("-Infinity") || value.equals("Infinity")) {
				value = "null";
			}

			expressionValue.add(value);
		}

		if (node instanceof Undefined_LowerIdentifier_Value) {
			String value = ((Undefined_LowerIdentifier_Value) node).getIdentifier().toString();
			if (myASTVisitor.isNextIntegerNegative) {
				value = "-" + value;
			}

			expressionValue.add(value);
		}

		if (node instanceof EnumerationItems) {// enum

			for (int i = 0; i < ((EnumerationItems) node).getItems().size(); i++) {
				enumItems.add(((EnumerationItems) node).getItems().get(i).getId().toString());
				if (((EnumerationItems) node).getItems().get(i).getValue() != null) {
					enumItemValues.add(((EnumerationItems) node).getItems().get(i).getValue().toString());
				} else {
					enumItemValues.add(null);
				}
			}
		}

		if (waitingForPortAttriburtes && (node instanceof Referenced_Type)) {
			isPortTypeAReferencedType = true;

		}

		if (waitingForPortAttriburtes && (node instanceof PortTypeBody)) {
			PortTypeBody body = (PortTypeBody) node;
			int inCount = body.getInMessages().getNofTypes();
			int outCount = body.getOutMessage().getNofTypes();

			for (int i = 0; i < inCount; i++) {
				inMessageName.add(
						myASTVisitor.cutModuleNameFromBeginning(body.getInMessages().getTypeByIndex(i).getTypename()));
			}
			for (int i = 0; i < outCount; i++) {
				outMessageName.add(
						myASTVisitor.cutModuleNameFromBeginning(body.getOutMessage().getTypeByIndex(i).getTypename()));
			}

			int shorterListSize = inMessageName.size() <= outMessageName.size() ? inMessageName.size()
					: outMessageName.size();

			// check if one of the messages is inout
			// if inout delete from both lists and add to inout
			for(int i =0; i<inMessageName.size();i++){
				for(int j =0; j<outMessageName.size();j++){
					if (inMessageName.get(i).equals(outMessageName.get(j))){
						inOutMessageName.add(inMessageName.get(i));
						inMessageName.remove(i);
						if(j==(outMessageName.size()-1)){
							i--;
							}
						outMessageName.remove(j);
						j--;
					}
				}
			}
			
			myASTVisitor.portNamePortTypeHashMap.put(currentPortName, body.getTestportType().toString());
			portTypeList.add(body.getTestportType().toString());
		}
	}

	public void leave(IVisitableNode node) {
		if (node instanceof Def_Type) {
			evaluateExpression();
			handleDefTypeNodes(node);
			waitForDefType = false;
			waitForValue = false;

			isInteger = false;
		}
	}

	public void handleDefTypeNodes(IVisitableNode node) {
		Def_Type typeNode = (Def_Type) node;

		CompilationTimeStamp compilationCounter = CompilationTimeStamp.getNewCompilationCounter();

		myASTVisitor.currentFileName = typeNode.getIdentifier().toString();

		Type type = typeNode.getType(compilationCounter);
		if (type.getTypetype().equals(TYPE_TTCN3_SEQUENCE)) {// record

			Def_Type_Record_Writer recordNode = new Def_Type_Record_Writer(typeNode);
			// add component fields
			recordNode.add(compFieldTypes, compFieldNames);

			String[] typeArray = (String[]) compFieldTypes.toArray(new String[compFieldTypes.size()]);
			String[] nameArray = (String[]) compFieldNames.toArray(new String[compFieldNames.size()]);

			myASTVisitor.nodeNameChildrenTypesHashMap.put(parentName, typeArray);
			myASTVisitor.nodeNameChildrenNamesHashMap.put(parentName, nameArray);

			compFieldTypes.clear();
			compFieldNames.clear();

			myASTVisitor.visualizeNodeToJava(recordNode.getJavaSource());

		} else if (type.getTypetype().equals(TYPE_TTCN3_SET)) {// set

			Def_Type_Set_Writer setNode = new Def_Type_Set_Writer(typeNode);
			// add component fields
			setNode.add(compFieldTypes, compFieldNames);

			String[] typeArray = (String[]) compFieldTypes.toArray(new String[compFieldTypes.size()]);
			String[] nameArray = (String[]) compFieldNames.toArray(new String[compFieldNames.size()]);

			myASTVisitor.nodeNameChildrenTypesHashMap.put(parentName, typeArray);
			myASTVisitor.nodeNameChildrenNamesHashMap.put(parentName, nameArray);

			compFieldTypes.clear();
			compFieldNames.clear();

			myASTVisitor.visualizeNodeToJava(setNode.getJavaSource());

		} else if (type.getTypetype().equals(TYPE_TTCN3_CHOICE)) {// union

			Def_Type_Union_Writer union_writer = new Def_Type_Union_Writer(typeNode);
			// add component fields
			union_writer.add(compFieldTypes, compFieldNames);

			String[] typeArray = compFieldTypes.toArray(new String[compFieldTypes.size()]);
			String[] nameArray = compFieldNames.toArray(new String[compFieldNames.size()]);

			myASTVisitor.nodeNameChildrenTypesHashMap.put(parentName, typeArray);
			myASTVisitor.nodeNameChildrenNamesHashMap.put(parentName, nameArray);

			compFieldTypes.clear();
			compFieldNames.clear();

			myASTVisitor.visualizeNodeToJava(union_writer.getJavaSource());

		} else if (type instanceof Integer_Type) {

			Def_Type_Integer_Writer integerNode = Def_Type_Integer_Writer.getInstance(typeNode);
			integerNode.clearLists();

			myASTVisitor.visualizeNodeToJava(integerNode.getJavaSource());

		} else if (type instanceof CharString_Type) {

			Def_Type_Charstring_Writer charstringNode = Def_Type_Charstring_Writer.getInstance(typeNode);
			charstringNode.clearLists();

			charstringNode.addCharStringValue(charstringValue);
			charstringValue = null;

			myASTVisitor.visualizeNodeToJava(charstringNode.getJavaSource());

		} else if (type instanceof TTCN3_Enumerated_Type) {

			Def_Type_Enum_Writer enumTypeNode = Def_Type_Enum_Writer.getInstance(typeNode);
			enumTypeNode.clearLists();

			enumTypeNode.enumItems.addAll(enumItems);
			enumTypeNode.enumItemValues.addAll(enumItemValues);

			enumItemValues.clear();
			enumItems.clear();

			myASTVisitor.visualizeNodeToJava(enumTypeNode.getJavaSource());

		} else if (type.getTypetype().equals(TYPE_SET_OF)) {

			Def_Type_Set_Of_Writer setOfNode = new Def_Type_Set_Of_Writer(typeNode);
			setOfNode.setFieldType(setOfFieldType);
			setOfFieldType = null;

			myASTVisitor.visualizeNodeToJava(setOfNode.getJavaSource());

		} else if (type.getTypetype().equals(TYPE_SEQUENCE_OF)) {

			Def_Type_Record_Of_Writer writer = new Def_Type_Record_Of_Writer(typeNode);
			writer.setFieldType(recordOfFieldType);
			myASTVisitor.visualizeNodeToJava(writer.getJavaSource());

		} else if (type.getTypetype().equals(TYPE_PORT)) {

			Def_Type_Port_Writer portNode = Def_Type_Port_Writer.getInstance(typeNode);
			portNode.clearLists();

			portNode.inMessageName.addAll(inMessageName);
			portNode.outMessageName.addAll(outMessageName);
			portNode.inOutMessageName.addAll(inOutMessageName);

			portNode.setPortTypeAReferencedType(isPortTypeAReferencedType);

			waitingForPortAttriburtes = false;
			isPortTypeAReferencedType = false;
			inMessageName.clear();
			outMessageName.clear();
			inOutMessageName.clear();
			myASTVisitor.visualizeNodeToJava(portNode.getJavaSource());

		} else if (type.getTypetype().equals(TYPE_COMPONENT)) {

			Def_Type_Component_Writer compNode = Def_Type_Component_Writer.getInstance(typeNode);
			compNode.clearLists();

			// add component fields

			compNode.compFieldPortTypes.addAll(componentPortTypes);
			compNode.compFieldPortNames.addAll(componentPortNames);
			compNode.compFieldVarTypes.addAll(componentVarTypes);
			compNode.compFieldVarNames.addAll(componentVarNames);

			componentPortTypes.clear();
			componentPortNames.clear();
			componentVarTypes.clear();
			componentVarNames.clear();
			waitForCompReference = false;
			myASTVisitor.visualizeNodeToJava(compNode.getJavaSource());

		}
		parentName = null;
	}
}
package org.eclipse.titan.codegenerator;

import org.eclipse.titan.designer.AST.IVisitableNode;
import org.eclipse.titan.designer.AST.Identifier;
import org.eclipse.titan.designer.AST.TTCN3.definitions.Def_ModulePar;
import org.eclipse.titan.designer.AST.TTCN3.types.BitString_Type;
import org.eclipse.titan.designer.AST.TTCN3.types.Boolean_Type;
import org.eclipse.titan.designer.AST.TTCN3.types.CharString_Type;
import org.eclipse.titan.designer.AST.TTCN3.types.HexString_Type;
import org.eclipse.titan.designer.AST.TTCN3.types.Integer_Type;
import org.eclipse.titan.designer.AST.TTCN3.types.OctetString_Type;
import org.eclipse.titan.designer.AST.TTCN3.types.Referenced_Type;
import org.eclipse.titan.designer.AST.TTCN3.values.Bitstring_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Boolean_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Charstring_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Hexstring_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Integer_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Octetstring_Value;

class ModuleParameterParser implements Scope {

	private final myASTVisitor visitor;

	private String name;
	private String type;
	private String value;

	ModuleParameterParser(myASTVisitor visitor) {
		this.visitor = visitor;
	}

	@Override
	public Scope process(IVisitableNode node) {
		if (node instanceof Identifier) {
			name = node.toString();
			myASTVisitor.nodeNameNodeTypeHashMap.put(name, "modulePar");
		}

		// TODO : generalize type parsing / handling
		if ((node instanceof Boolean_Type)) {
			type = "BOOLEAN";
		}
		if ((node instanceof Integer_Type)) {
			type = "INTEGER";
		}
		if ((node instanceof CharString_Type)) {
			type = "CHARSTRING";
		}
		if ((node instanceof BitString_Type)) {
			type = "BITSTRING";
		}
		if ((node instanceof HexString_Type)) {
			type = "HEXSTRING";
		}
		if ((node instanceof OctetString_Type)) {
			type = "OCTETSTRING";
		}
		if (node instanceof Referenced_Type) {
			type = ((Referenced_Type) node).getReference().toString();
			// TODO : the value should be created as this type of object
			// e.g.:
			// type integer Digit (0..9);
			// modulepar Digit d := 3;
		}

		// TODO : generalize value parsing / handling
		if ((node instanceof Boolean_Value)) {
			value = ((Boolean_Value) node).getValue() ? "BOOLEAN.TRUE" : "BOOLEAN.FALSE";
		}
		if ((node instanceof Integer_Value)) {
			value = "new INTEGER(\"" + node.toString() + "\")";
		}
		if ((node instanceof Charstring_Value)) {
			value = ((Charstring_Value) node).getValue();
			value = "new CHARSTRING(\"" + value + "\")";
		}
		if ((node instanceof Bitstring_Value)) {
			value = ((Bitstring_Value) node).getValue();
			value = "new BITSTRING(\"" + value + "\")";
		}
		if ((node instanceof Hexstring_Value)) {
			value = ((Hexstring_Value) node).getValue();
			value = "new HEXSTRING(\"" + value + "\")";
		}
		if ((node instanceof Octetstring_Value)) {
			value = ((Octetstring_Value) node).getValue();
			value = "new OCTETSTRING(\"" + value + "\")";
		}
		// TODO : handle (referenced) subtype values
		// TODO : handle record, set, record of and set of subtypes and values
		return this;
	}

	@Override
	public Scope finish(IVisitableNode node) {
		if (node instanceof Def_ModulePar) {
			visitor.parameters.add(type, name, value);
			return visitor;
		}
		return this;
	}
}
/******************************************************************************
 * Copyright (c) 2000-2017 Ericsson Telecom AB
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   
 *   Keremi, Andras
 *   Eros, Levente
 *   Kovacs, Gabor
 *   Meszaros, Mate Robert
 *
 ******************************************************************************/

package org.eclipse.titan.codegenerator;

import java.util.ArrayList;
import java.util.List;
import org.eclipse.titan.designer.AST.ArraySubReference;
import org.eclipse.titan.designer.AST.ISubReference;
import org.eclipse.titan.designer.AST.IVisitableNode;
import org.eclipse.titan.designer.AST.Identifier;
import org.eclipse.titan.designer.AST.ParameterisedSubReference;
import org.eclipse.titan.designer.AST.Reference;
import org.eclipse.titan.designer.AST.TTCN3.definitions.Def_Const;
import org.eclipse.titan.designer.AST.TTCN3.definitions.Def_Function;
import org.eclipse.titan.designer.AST.TTCN3.definitions.Def_Testcase;
import org.eclipse.titan.designer.AST.TTCN3.definitions.Def_Timer;
import org.eclipse.titan.designer.AST.TTCN3.definitions.Def_Var;
import org.eclipse.titan.designer.AST.TTCN3.definitions.Def_Var_Template;
import org.eclipse.titan.designer.AST.TTCN3.definitions.FormalParameter;
import org.eclipse.titan.designer.AST.TTCN3.statements.Alt_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.Assignment_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.Connect_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.Definition_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.Disconnect_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.DoWhile_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.If_Clause;
import org.eclipse.titan.designer.AST.TTCN3.statements.If_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.Map_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.Operation_Altguard;
import org.eclipse.titan.designer.AST.TTCN3.statements.Receive_Port_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.Return_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.Send_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.Setverdict_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.StatementBlock;
import org.eclipse.titan.designer.AST.TTCN3.statements.Timeout_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.Unknown_Start_Statement;
import org.eclipse.titan.designer.AST.TTCN3.statements.Unknown_Stop_Statement;
import org.eclipse.titan.designer.AST.TTCN3.templates.Any_Value_Template;
import org.eclipse.titan.designer.AST.TTCN3.templates.SpecificValue_Template;
import org.eclipse.titan.designer.AST.TTCN3.templates.TemplateInstance;
import org.eclipse.titan.designer.AST.TTCN3.types.BitString_Type;
import org.eclipse.titan.designer.AST.TTCN3.types.Boolean_Type;
import org.eclipse.titan.designer.AST.TTCN3.types.CharString_Type;
import org.eclipse.titan.designer.AST.TTCN3.types.Float_Type;
import org.eclipse.titan.designer.AST.TTCN3.types.Integer_Type;
import org.eclipse.titan.designer.AST.TTCN3.types.OctetString_Type;
import org.eclipse.titan.designer.AST.TTCN3.values.Bitstring_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Boolean_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Charstring_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Integer_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Octetstring_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Real_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.SequenceOf_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.Undefined_LowerIdentifier_Value;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.AddExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.And4bExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.ComponentCreateExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.DivideExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.EqualsExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.GreaterThanExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.GreaterThanOrEqualExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.Int2StrExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.IsBoundExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.IsChoosenExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.IsPresentExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.IsValueExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.LengthofExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.LessThanExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.LessThanOrEqualExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.MTCComponentExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.ModuloExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.MultiplyExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.Not4bExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.NotExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.NotequalesExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.Or4bExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.RemainderExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.RotateLeftExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.RotateRightExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.SelfComponentExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.ShiftLeftExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.ShiftRightExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.StringConcatenationExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.SubstractExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.SystemComponentExpression;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.Xor4bExpression;

public class TestCase_Function_Visit_Handler {

	private static StatementBlock functionStatementBlock = null;
	private StatementBlock tcStatementBlock = null;

	private Def_Testcase_Writer currentTestCaseWriter;
	private Def_Function_Writer currentFunctionWriter;

	private static String returnType = null;
	private static String returnStatementValue = null;
	private List<String> unknownStartReference = new ArrayList<String>();
	private List<String> unknownStopReference = new ArrayList<String>();
	
	private static String runsOnValue = null;
	private static String currentIdentifier = null;

	// Counters
	private int tcCreateCounter = -1;
	private int tcStartCounter = -1;
	private int mapCounter = 0;
	private int mapValueCounter = 0;

	private int currentRecordCounter = 0;

	public boolean waitForDefStatement = false;
	public static boolean waitForStatementBlock = false;
	public static boolean waitForValue = false;
	private static boolean waitForRunsOnValue = false;
	private static boolean waitForReturnType = false;
	private static boolean waitForReturnStatementValue = false;
	private static boolean waitForReceiveStatement = false;
	private static boolean checkAnyport = false;
	private static boolean waitForUnknownStartStatement = false;
	private static boolean waitForTypedParam = false;
	private static boolean waitForInt2StrExpression = false;
	private boolean waitForTC = false;
	private boolean waitForAssignmentIdentifiers = false;
	private boolean waitForMapIdentifiers = false;;
	private boolean waitForTcIfCondition = false;

	private boolean isSendStatement = false;
	private boolean isDoWhileStatement = false;
	private boolean waitForTcStartParameter = false;
	private boolean waitForTcStopParameter = false;
	private boolean isAltGuards = false;

	private boolean waitForAltStatements = false;
	private boolean isReceiveValue = false;
	private boolean waitForAltTimeout = false;
	private boolean isNextValueTemplate = false;
	private boolean isNextValueConstant = false;
	private boolean waitForTcDisconnectValues = false;
	private boolean waitForTcCreateValues = false;
	private boolean waitForTcConnectValues = false;
	private boolean waitForTcStartValues = false;
	private boolean waitForFunction = false;
	private boolean waitForStatements = true;
	private boolean waitForReceiveParameter = false;
	private boolean isAnyValValue = false;
	private boolean waitForReceiveAnyValTemplateValue = false;
	private boolean isDefinition = false;
	private boolean isAssignment = false;
	private boolean isIf = false;
	public static boolean isThereAFormalParameter = false;
	private boolean waitForIndexSetValue = false;

	// Lists
	private List<String> nodeVars = new ArrayList<String>();
	private List<String> nodeVarTypes = new ArrayList<String>();
	private List<String> nodeVarValues = new ArrayList<String>();
	private List<Boolean> nodeVarIsAValueReference = new ArrayList<Boolean>();
	private List<Boolean> nodeVarTypeIsAReference = new ArrayList<Boolean>();
	private List<Boolean> nodeVarIsConstant = new ArrayList<Boolean>();
	private List<Boolean> nodeVarIsTemplate = new ArrayList<Boolean>();
	private List<Boolean> nodeVarIsRecord = new ArrayList<Boolean>();

	private List<String> nodeVarRecordValues = new ArrayList<String>();

	private List<String> nodeAssignIdentifiers = new ArrayList<String>();
	private List<String> nodeAssignValues = new ArrayList<String>();

	private List<String> testCaseCreateValues = new ArrayList<String>();
	private List<String> testCaseCreateCounter = new ArrayList<String>();
	private List<String> testCaseCreateRefValues = new ArrayList<String>();
	private List<String> testCaseCreateCharValues = new ArrayList<String>();

	private List<String> testCaseIfConditions = new ArrayList<String>();

	private List<String> nodeSendPortReference = new ArrayList<String>();
	private List<String> nodeSendParameter = new ArrayList<String>();
	private List<String> nodeSendParameterType = new ArrayList<String>();

	private List<String> altGuardConditions = new ArrayList<String>();
	private List<String> altGuardPortReference = new ArrayList<String>();
	private List<String> altGuardReceiveValue = new ArrayList<String>();
	private List<String> altGuardReceiveAnyValValue = new ArrayList<String>();
	private List<String> altGuardReceiveType = new ArrayList<String>();
	private List<String> altGuardTimeout = new ArrayList<String>();

	private List<String> doWhileExpressions = new ArrayList<String>();
	
	private List<String> receivePortReference = new ArrayList<String>();
	private List<String> receiveValue = new ArrayList<String>();
	private List<String> receiveAnyValValue = new ArrayList<String>();
	private List<String> receiveType = new ArrayList<String>();

	private List<String> testCaseDisconnectValues = new ArrayList<String>();

	private List<String> testCaseMapValues = new ArrayList<String>();
	private List<String> testCaseMapCounter = new ArrayList<String>();

	private List<String> testCaseStartValues = new ArrayList<String>();
	private List<String> testCaseStartValueParameters = new ArrayList<String>();
	private List<String> testCaseStartCounter = new ArrayList<String>();

	private List<String> testCaseStopValues = new ArrayList<String>();
	private List<String> testCaseStopValueParameters = new ArrayList<String>();
	private List<String> testCaseStopCounter = new ArrayList<String>();

	private List<String> testCaseConnectValues = new ArrayList<String>();

	private List<String> operatorList = new ArrayList<String>();

	private List<String> expressionValue = new ArrayList<String>();

	private List<StatementBlock> receiveStatements = new ArrayList<StatementBlock>();

	private boolean waitForTcStopValues = false;
	private int tcStopCounter = -1;
	private boolean waitForUnknownStopStatement = false;

	private boolean waitForRecord = false;
	private boolean isCreate = false;
	private boolean isSendValue = false;
	private boolean blockReferenceListing = false;
	Statement currentAltGuardStatement = null;

	public void visit(IVisitableNode node) {

		if (node instanceof Def_Function) {

			currentFunctionWriter = Def_Function_Writer.getInstance(((Def_Function) node));
			currentFunctionWriter.clearAltLists();
			myASTVisitor.nodeNameNodeTypeHashMap.put(((Def_Function) node).getIdentifier().toString(), "function");

			runsOnValue = null;

			waitForReturnType = true;
			waitForRunsOnValue = true;
			waitForStatementBlock = true;
			waitForFunction = true;

			expressionValue.clear();
		}

		if (node instanceof Def_Testcase) {

			currentTestCaseWriter = Def_Testcase_Writer.getInstance(((Def_Testcase) node));
			currentTestCaseWriter.clearAltLists();
			myASTVisitor.nodeNameNodeTypeHashMap.put(((Def_Testcase) node).getIdentifier().toString(), "testcase");

			AstWalkerJava.testCaseList.add(((Def_Testcase) node).getIdentifier().toString());

			waitForStatementBlock = true;
			waitForRunsOnValue = true;
			waitForTC = true;

			expressionValue.clear();
		}

		// Check for TC
		visitNodes(node);

		// Check Functions
		visitFunctionNodes(node);

		// Check for TC
		visitTcNodes(node);

		// Check for TC If cases
		visitTcIfCases(node);

		// Check for TC Alt cases
		visitAltCases(node);

		if (node instanceof Reference) {
			checkReference(node);
		}

		if ((currentAltGuardStatement != null) && (currentAltGuardStatement.equals(node))) {
			evaluateExpression();
		}

		// testcases
		// FormalParameter might come up for other types too, leave it here
		if (node instanceof FormalParameter) {
			isThereAFormalParameter = true;
		}

		if (isThereAFormalParameter && (node instanceof Reference)) {
			// TODO: formal parameter reference handling (tpye name)
			isThereAFormalParameter = false;
		}

		if (isThereAFormalParameter && (node instanceof Identifier)) {
			// TODO: formal parameter identifier handling
		}

	}

	public void leave(IVisitableNode node) {

		if (waitForTC || waitForFunction) {
			
			if (node instanceof Definition_Statement) {

				if (!waitForRecord) {
					nodeVarIsRecord.add(false);
				}
				waitForRecord = false;
				waitForValue = false;

				evaluateExpression();
			}

			if (node instanceof Undefined_LowerIdentifier_Value) {
				blockReferenceListing = false;
			}

			if ((node instanceof Assignment_Statement) || ((node instanceof If_Clause))) {
				waitForValue = false;

				// if assignment is a createExpression
				if (node instanceof Assignment_Statement) {
					if (((Assignment_Statement) node).getTemplate() instanceof SpecificValue_Template) {
						SpecificValue_Template specValTemplate = (SpecificValue_Template) ((Assignment_Statement) node)
								.getTemplate();
						if (specValTemplate.getSpecificValue() instanceof ComponentCreateExpression) {
							isCreate = true;
						}
					}
				}

				evaluateExpression();

			}

			if (node instanceof SequenceOf_Value) {
				evaluateExpression();
			}

			if ((waitForFunction && (node instanceof Return_Statement))
					|| (waitForTC && (node instanceof ComponentCreateExpression)) || (node instanceof Send_Statement)
					|| (node instanceof Receive_Port_Statement)) {
				evaluateExpression();
			}

			if (waitForTcStartValues && (node instanceof Identifier) && myASTVisitor.blockIdListing) {
				myASTVisitor.blockIdListing = false;
			}

			if (waitForTcStopValues && (node instanceof Identifier) && myASTVisitor.blockIdListing) {
				myASTVisitor.blockIdListing = false;
			}

			if (node instanceof Connect_Statement) {
				waitForTcConnectValues = false;
			}

			if (node instanceof Disconnect_Statement) {
				waitForTcDisconnectValues = false;

			}
			if (node instanceof Unknown_Start_Statement) {
				waitForTcStartValues = false;
			}

			if (node instanceof Unknown_Stop_Statement) {
				waitForTcStopValues = false;
			}

			if (node instanceof Definition_Statement) {
				waitForDefStatement = false;
				if (waitForValue) {
					nodeVarValues.add(null);
					nodeVarIsAValueReference.add(false);

					waitForValue = false;
				}

			}

			if (node instanceof Map_Statement) {
				waitForMapIdentifiers = false;
			}

			if (node instanceof ComponentCreateExpression) {

				// switch first two values
				testCaseCreateValues.add(testCaseCreateCharValues.get(0));
				testCaseCreateValues.add(testCaseCreateRefValues.get(0));

				for (int i = 1; i < testCaseCreateCharValues.size(); i++) {
					testCaseCreateValues.add(testCaseCreateCharValues.get(i));
				}

				testCaseCreateCharValues.clear();
				testCaseCreateRefValues.clear();
				waitForTcCreateValues = false;
			}

			if (node instanceof Assignment_Statement) {

				waitForAssignmentIdentifiers = false;
				waitForValue = true;
			}

			if (waitForTcIfCondition && (node instanceof If_Clause)) {
				waitForTcIfCondition = false;

			}

			if (waitForTcStartParameter && (node instanceof Unknown_Start_Statement)) {
				testCaseStartValueParameters.add(null);
			}

			if (waitForTcStopParameter && (node instanceof Unknown_Stop_Statement)) {
				testCaseStopValueParameters.add(null);
			}

			if (isAltGuards && (node instanceof Operation_Altguard)) {
				altGuardConditions.add(null);
			}

			if (node instanceof Operation_Altguard) {

				waitForAltStatements = false;
				isAltGuards = false;

				isReceiveValue = false;

			}

			handleAltCases(node);

			if (node instanceof Unknown_Start_Statement) {
				waitForUnknownStartStatement = false;
			}

			if (node instanceof Unknown_Stop_Statement) {
				waitForUnknownStopStatement = false;
			}
			
			
			if (node instanceof Receive_Port_Statement) {
				if(waitForReceiveParameter){
					altGuardReceiveType.add("noparam");
				}
				//TODO checkAnyport = true;
				
				
			}
		}

		if (node instanceof Def_Testcase) {
			handleTestcase(node);
			waitForTC = false;
		}

		if (node instanceof Def_Function) {
			handleFunction(node);
			waitForTC = false;
		}

		if (waitForAssignmentIdentifiers && (node instanceof ArraySubReference)) {
			waitForAssignmentIdentifiers = false;
		}

	}

	public void evaluateExpression() {
		int size = expressionValue.size() - 1;
		boolean arrayOperatorFound = false;
		boolean operatorFound = false;
		boolean unaryOperatorFound = false;
		String rightHand = "";
		String leftHand = "";
		String currentType = "";

		if (nodeVars.contains(currentIdentifier)) {

				currentType = nodeVarTypes.get(nodeVars.indexOf(currentIdentifier));
			
		}
		
		if(isSendStatement){
			currentType=nodeSendParameterType.get(nodeSendParameterType.size()-1);
			if(currentType.equals("IDENTIFIER")){
				currentType="CHARSTRING";
			}
			
		}
		
		for (int i = size; i >= 0; i--) {

			if (myASTVisitor.nodeNameNodeTypeHashMap.containsKey(expressionValue.get(i))) {

				if (myASTVisitor.nodeNameNodeTypeHashMap.get(expressionValue.get(i)).equals("constant")) {
					expressionValue.set(i, "Constants." + expressionValue.get(i) + "()");

				} else if (myASTVisitor.nodeNameNodeTypeHashMap.get(expressionValue.get(i)).equals("template")) {
					expressionValue.set(i, "Templates." + expressionValue.get(i) + "()");

				}
			}

			if (i <= size - 2) {
				leftHand = expressionValue.get(i + 1);
				rightHand = expressionValue.get(i + 2);
			}

			if (expressionValue.get(i).equals("ArraySubReference")) {
				String[] index = expressionValue.get(i + 1).split("\"");

				expressionValue.set(i - 1, expressionValue.get(i - 1) + ".get(" + index[1] + ")");
				arrayOperatorFound = true;
			} else if (expressionValue.get(i).equals("LengthofExpression")) {
				expressionValue.set(i, "(" + expressionValue.get(i + 1) + ").lengthof()");
				unaryOperatorFound = true;
			} else if (expressionValue.get(i).equals("IsChoosenExpression")) {
				expressionValue.set(i, "(" + expressionValue.get(i + 1) + ").isChosen()");
				unaryOperatorFound = true;
			} else if (expressionValue.get(i).equals("IsPresentExpression")) {
				expressionValue.set(i, "(" + expressionValue.get(i + 1) + ").isPresent()");
				unaryOperatorFound = true;
			} else if (expressionValue.get(i).equals("IsValueExpression")) {
				expressionValue.set(i, "(" + expressionValue.get(i + 1) + ").isValue()");
				unaryOperatorFound = true;
			} else if (expressionValue.get(i).equals("IsBoundExpression")) {
				expressionValue.set(i, "(" + expressionValue.get(i + 1) + ").isBound()");
				unaryOperatorFound = true;
			} else if (expressionValue.get(i).equals("NotExpression")) {
				expressionValue.set(i, "(" + expressionValue.get(i + 1) + ").not()");
				unaryOperatorFound = true;
			} else if (expressionValue.get(i).equals("Not4bExpression")) {
				expressionValue.set(i, "(" + expressionValue.get(i + 1) + ").bitwiseNot()");
				unaryOperatorFound = true;
			} else if (expressionValue.get(i).equals("Xor4bExpression")) {
				expressionValue.set(i, "(" + expressionValue.get(i + 1) + ").bitwiseXor(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("Or4bExpression")) {
				expressionValue.set(i, "(" + expressionValue.get(i + 1) + ").bitwiseOr(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("And4bExpression")) {
				expressionValue.set(i, "(" + expressionValue.get(i + 1) + ").bitwiseAnd(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("ShiftRightExpression")) {
				expressionValue.set(i, "((" + currentType + ")(" + leftHand + ").shiftRight(" + rightHand + "))");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("ShiftLeftExpression")) {
				expressionValue.set(i, "((" + currentType + ")(" + leftHand + ").shiftLeft(" + rightHand + "))");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("RotateRightExpression")) {
				expressionValue.set(i, "((" + currentType + ")(" + leftHand + ").rotateRight(" + rightHand + "))");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("RotateLeftExpression")) {
				expressionValue.set(i, "((" + currentType + ")(" + leftHand + ").rotateLeft(" + rightHand + "))");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("StringConcatenationExpression")) {
				expressionValue.set(i, "((" + currentType + ")(" + leftHand + ").concatenate(" + rightHand + "))");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("AddExpression")) {
				expressionValue.set(i, "(" + leftHand + ").plus(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("SubstractExpression")) {
				expressionValue.set(i, "(" + leftHand + ").minus(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("MultiplyExpression")) {
				expressionValue.set(i, "(" + leftHand + ").multipleBy(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("DivideExpression")) {
				expressionValue.set(i, "(" + leftHand + ").divideBy(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("ModuloExpression")) {
				expressionValue.set(i, "(" + leftHand + ").mod(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("RemainderExpression")) {
				expressionValue.set(i, "(" + leftHand + ").rem(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("NotequalesExpression")) {
				expressionValue.set(i, "(" + leftHand + ").equalsWith(" + rightHand + ").not()");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("LessThanExpression")) {
				expressionValue.set(i, "(" + leftHand + ").isLessThan(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("LessThanOrEqualExpression")) {
				expressionValue.set(i, "(" + leftHand + ").isLessOrEqualThan(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("GreaterThanExpression")) {
				expressionValue.set(i, "(" + leftHand + ").isGreaterThan(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("GreaterThanOrEqualExpression")) {
				expressionValue.set(i, "(" + leftHand + ").isGreaterOrEqualThan(" + rightHand + ")");
				operatorFound = true;
			} else if (expressionValue.get(i).equals("EqualsExpression")) {
				expressionValue.set(i, "(" + leftHand + ").equalsWith(" + rightHand + ")");
				operatorFound = true;
			}

			if (arrayOperatorFound) {
				arrayOperatorFound = false;
				expressionValue.remove(i + 1);
				expressionValue.remove(i);
				size = expressionValue.size() - 1;
				i = size;
			} else if (unaryOperatorFound) {
				unaryOperatorFound = false;
				expressionValue.remove(i + 1);
				size = expressionValue.size() - 1;
				i = size;
			} else if (operatorFound) {
				operatorFound = false;
				expressionValue.remove(i + 2);
				expressionValue.remove(i + 1);
				size = expressionValue.size() - 1;
				i = size;
			}

		}

		String value = null;

		if (expressionValue.size() > 0) {
			value = expressionValue.get(0);
		}

		if (waitForIndexSetValue) {
			value = value + ")";
			waitForIndexSetValue = false;

		}

		// Set value for the appropriate list
		if (isCreate) {
			testCaseCreateCharValues.addAll(expressionValue);
			testCaseCreateCounter.add(String.valueOf(tcCreateCounter));
		} else if(isDoWhileStatement) {
			doWhileExpressions.add(value);
		//	isDoWhileStatement=false;
		} else if (isDefinition) {

			if (isNextValueConstant) {
				nodeVarIsConstant.add(true);
			} else {
				nodeVarIsConstant.add(false);
			}

			if (isNextValueTemplate) {
				nodeVarIsTemplate.add(true);
			} else {
				nodeVarIsTemplate.add(false);
			}

			if (waitForRecord) {
				nodeVarValues.addAll(expressionValue);
				// waitForRecord = false;
			} else {
				nodeVarValues.add(value);
			}

			nodeVarIsAValueReference.add(true);

		} else if (isAssignment) {

			nodeAssignValues.add(value);

		} else if (isIf) {

			testCaseIfConditions.add(value);

		} else if (isSendStatement) {
			nodeSendParameter.add(value);
		} else if (isReceiveValue) {
			if (waitForAltStatements) {
				if (!waitForReceiveAnyValTemplateValue) {
					altGuardReceiveValue.add(value);
				}
			} else {
				receiveValue.add(value);
			}
			//waitForReceiveParameter=false;
		} else if (isAltGuards) {
			altGuardConditions.add(value);
			isAltGuards = false;

		} else if (waitForReturnStatementValue) {
			returnStatementValue = value;
		}

		if (isAltGuards) {
			altGuardConditions.add(null);
			isAltGuards = false;
		}

		isNextValueTemplate = false;
		isNextValueConstant = false;

		waitForReceiveAnyValTemplateValue = false;

		isSendStatement = false;
		isSendValue = false;
		isReceiveValue = false;
		isDefinition = false;
		isAssignment = false;

		isCreate = false;
		expressionValue.clear();
	}

	public void visitNodes(IVisitableNode node) {

		if (waitForStatementBlock && (node instanceof StatementBlock)) {
			functionStatementBlock = (StatementBlock) node;
			tcStatementBlock = ((StatementBlock) node);

			waitForRunsOnValue = false;
			waitForReturnType = false;
			waitForStatementBlock = false;

			waitForStatements = true;
		}

		if (waitForAltStatements && (node instanceof StatementBlock)) {
			evaluateExpression();
			isReceiveValue = false;

			if (!isAnyValValue) {
				altGuardReceiveAnyValValue.add(null);

			}
			isAnyValValue = false;
		}

		if (waitForStatements) {
			visitStatementSelector(node);
		}

		if (waitForDefStatement) {
			visitDefStatements(node);
		}

		if (waitForTC || waitForFunction) {
			// Check expression operators

			// Check expression values
			if (!waitForAssignmentIdentifiers) {
				visitExpressionTypeSelectors(node);
				visitExpressionValueSetters(node);
			}
		}
		if (isIf && (node instanceof StatementBlock)) {
			// has to be here, If always has a statemnt block
			evaluateExpression();
			isIf = false;

		}
		if (isDoWhileStatement && (node instanceof StatementBlock)) {
			// has to be here, If always has a statemnt block
			evaluateExpression();
			isDoWhileStatement = false;

		}


		if (waitForTC && (node instanceof Unknown_Start_Statement)) {
			waitForTcStartValues = true;
			tcStartCounter++;
		}

		if (waitForTC && (node instanceof Unknown_Stop_Statement)) {
			waitForTcStopValues = true;
			tcStopCounter++;
		}

		if (waitForTcStartValues) {
			visitStartValueSetters(node);
		}

		if (waitForTcStopValues) {
			visitStopValueSetters(node);
		}

		if (waitForTC && (node instanceof Map_Statement)) {
			waitForMapIdentifiers = true;
			mapCounter++;
			mapValueCounter = 0;
		}

		if (waitForMapIdentifiers) {
			visitMapIdentifiers(node);
		}

	/*	if (isSendStatement) {
			visitSendStatements(node);
		}*/

		if (waitForTcDisconnectValues) {
			visitDisconnectValueSetters(node);
		}

	}

	public void visitStatementSelector(IVisitableNode node) {

		if (waitForStatements && (node instanceof Definition_Statement)) {
			waitForDefStatement = true;
			waitForValue = true;
			isDefinition = true;
		}

		if (waitForStatements && (node instanceof Send_Statement)) {
			isSendStatement = true;
		}
		
		if (waitForStatements && (node instanceof DoWhile_Statement)) {
			isDoWhileStatement = true;
			waitForValue=true;
		}
		
		

		if (waitForStatements && (node instanceof Operation_Altguard)) {
			isAltGuards = true;
			waitForAltStatements = true;
			currentAltGuardStatement = ((Operation_Altguard) node).getGuardStatement();
			waitForValue = true;

		}

		if (waitForStatements && (node instanceof Assignment_Statement)) {
			waitForAssignmentIdentifiers = true;
			waitForValue = true;
			isAssignment = true;
		}

		if (waitForStatements && (node instanceof Disconnect_Statement)) {
			waitForTcDisconnectValues = true;
		}
	}

	public void visitDefStatements(IVisitableNode node) {

		if (waitForDefStatement && (node instanceof Def_Var)) {
			nodeVars.add(((Def_Var) node).getIdentifier().toString());
			currentIdentifier = ((Def_Var) node).getIdentifier().toString();
		}

		if (waitForDefStatement && (node instanceof Def_Var_Template)) {
			nodeVars.add(((Def_Var_Template) node).getIdentifier().toString());
			isNextValueTemplate = true;
			currentIdentifier = ((Def_Var_Template) node).getIdentifier().toString();
		}

		if (waitForDefStatement && (node instanceof Def_Const)) {
			// TODO const spec
			nodeVars.add(((Def_Const) node).getIdentifier().toString());
			isNextValueConstant = true;
			currentIdentifier = ((Def_Const) node).getIdentifier().toString();
		}

		if (waitForDefStatement && (node instanceof BitString_Type)) {
			nodeVarTypes.add("BITSTRING");
			nodeVarTypeIsAReference.add(false);

		}
		if (waitForDefStatement && (node instanceof Integer_Type)) {
			nodeVarTypes.add("INTEGER");
			nodeVarTypeIsAReference.add(false);
		}
		
		if (waitForDefStatement && (node instanceof Float_Type)) {
			nodeVarTypes.add("FLOAT");
			nodeVarTypeIsAReference.add(false);
		}

		if (waitForDefStatement && (node instanceof CharString_Type)) {
			nodeVarTypes.add("CHARSTRING");
			nodeVarTypeIsAReference.add(false);
		}

		if (waitForDefStatement && (node instanceof OctetString_Type)) {
			nodeVarTypes.add("OCTETSTRING");
			waitForValue = true;
			nodeVarTypeIsAReference.add(false);
		}

		if (waitForDefStatement && (node instanceof Boolean_Type)) {
			nodeVarTypes.add("BOOLEAN");
			nodeVarTypeIsAReference.add(false);
		}

		if (waitForDefStatement && (node instanceof Def_Timer)) {
			nodeVars.add(((Def_Timer) node).getIdentifier().toString());
			currentIdentifier = ((Def_Timer) node).getIdentifier().toString();
			nodeVarTypes.add("TIMER");
			waitForDefStatement = false;
			nodeVarTypeIsAReference.add(false);

		}

	}

	public void visitExpressionTypeSelectors(IVisitableNode node) {

		if (waitForValue && (node instanceof If_Clause)) {
			isIf = true;
		}

		if (waitForValue && !waitForAssignmentIdentifiers && (node instanceof ArraySubReference)) {
			expressionValue.add("ArraySubReference");
		}

		if (waitForValue && (node instanceof AddExpression)) {
			expressionValue.add("AddExpression");
		}

		if (waitForValue && (node instanceof IsValueExpression)) {
			expressionValue.add("IsValueExpression");
		}

		if (waitForValue && (node instanceof IsChoosenExpression)) {
			expressionValue.add("IsChoosenExpression");
		}

		if (waitForValue && (node instanceof IsBoundExpression)) {
			expressionValue.add("IsBoundExpression");
		}

		if (waitForValue && (node instanceof IsPresentExpression)) {
			expressionValue.add("IsPresentExpression");
		}

		if (waitForValue && (node instanceof Not4bExpression)) {
			expressionValue.add("Not4bExpression");
		}

		if (waitForValue && (node instanceof And4bExpression)) {
			expressionValue.add("And4bExpression");
		}

		if (waitForValue && (node instanceof Or4bExpression)) {
			expressionValue.add("Or4bExpression");
		}

		if (waitForValue && (node instanceof Xor4bExpression)) {
			expressionValue.add("Xor4bExpression");
		}

		if (waitForValue && (node instanceof ShiftLeftExpression)) {
			expressionValue.add("ShiftLeftExpression");
		}

		if (waitForValue && (node instanceof ShiftRightExpression)) {
			expressionValue.add("ShiftRightExpression");
		}

		if (waitForValue && (node instanceof RotateRightExpression)) {
			expressionValue.add("RotateRightExpression");
		}

		if (waitForValue && (node instanceof RotateLeftExpression)) {
			expressionValue.add("RotateLeftExpression");
		}

		if (waitForValue && (node instanceof StringConcatenationExpression)) {
			expressionValue.add("StringConcatenationExpression");
		}

		if (waitForValue && (node instanceof LengthofExpression)) {
			expressionValue.add("LengthofExpression");
		}

		if (waitForValue && (node instanceof SubstractExpression)) {
			expressionValue.add("SubstractExpression");
		}

		if (waitForValue && (node instanceof MultiplyExpression)) {
			expressionValue.add("MultiplyExpression");
		}

		if (waitForValue && (node instanceof DivideExpression)) {
			expressionValue.add("DivideExpression");
		}

		if (waitForValue && (node instanceof ModuloExpression)) {
			expressionValue.add("ModuloExpression");
		}

		if (waitForValue && (node instanceof RemainderExpression)) {
			expressionValue.add("RemainderExpression");
		}

		if (waitForValue && (node instanceof NotequalesExpression)) {
			expressionValue.add("NotequalesExpression");
		}

		if (waitForValue && (node instanceof LessThanExpression)) {
			expressionValue.add("LessThanExpression");
		}

		if (waitForValue && (node instanceof LessThanOrEqualExpression)) {
			expressionValue.add("LessThanOrEqualExpression");
		}

		if (waitForValue && (node instanceof GreaterThanExpression)) {
			expressionValue.add("GreaterThanExpression");
		}

		if (waitForValue && (node instanceof GreaterThanOrEqualExpression)) {
			expressionValue.add("GreaterThanOrEqualExpression");
		}

		if (waitForValue && (node instanceof EqualsExpression)) {
			expressionValue.add("EqualsExpression");
		}

		if (waitForValue && (node instanceof NotExpression)) {
			expressionValue.add("NotExpression");
		}

	}

	public void visitExpressionValueSetters(IVisitableNode node) {

		if (node instanceof Real_Value) {

			String value = ((Real_Value) node).createStringRepresentation();

			value = "new FLOAT(" + value + ")";
			
			expressionValue.add(value);

		}

		if (node instanceof Integer_Value) {

			String value = ((Integer_Value) node).toString();

			if (myASTVisitor.isNextIntegerNegative) {
				value = "-" + ((Integer_Value) node).toString();
			}
			value = "new INTEGER(\"" + value + "\")";

			expressionValue.add(value);

			if (isSendStatement) {
				nodeSendParameterType.add("INTEGER");
			}

			if (isReceiveValue) {
				if (waitForAltStatements) {
					altGuardReceiveType.add("INTEGER");
				} else {
					receiveType.add("INTEGER");
				}
				waitForReceiveParameter=false;
			}

			myASTVisitor.isNextIntegerNegative = false;

		}

		if (node instanceof Undefined_LowerIdentifier_Value) {
			String value = ((Undefined_LowerIdentifier_Value) node).getIdentifier().toString();

			if (myASTVisitor.isNextIntegerNegative) {
				value = value + ".negate()";
			}

			if (waitForInt2StrExpression) {
				value = value + ".int2str()";
				waitForInt2StrExpression = false;
			}

			expressionValue.add(value);

			if (isSendStatement) {
				nodeSendParameterType.add("IDENTIFIER");
			}

			if (isReceiveValue) {
				if (waitForAltStatements) {
					altGuardReceiveType.add("IDENTIFIER");
				} else {
					receiveType.add("IDENTIFIER");
				}
				waitForReceiveParameter=false;
			}

			myASTVisitor.isNextIntegerNegative = false;
			/*
			 * if (nodeVarTypes.size() > 0) { if
			 * (myASTVisitor.nodeNameNodeTypeHashMap.containsKey(nodeVarTypes.
			 * get(nodeVarTypes.size() - 1))) {
			 * 
			 * if (myASTVisitor.nodeNameNodeTypeHashMap.get(nodeVarTypes.get(
			 * nodeVarTypes.size() - 1)) .equals("record")) {
			 * 
			 * if (currentRecordCounter <
			 * myASTVisitor.nodeNameChildrenNamesHashMap
			 * .get(nodeVarTypes.get(nodeVarTypes.size() - 1)).length) {
			 * waitForRecord = true; nodeVarIsRecord.add(true);
			 * 
			 * } } } }
			 */
			blockReferenceListing = true;

		}

		if (node instanceof Boolean_Value) {

			String value = ((Boolean_Value) node).getValue() ? "BOOLEAN.TRUE" : "BOOLEAN.FALSE";
			expressionValue.add(value);
		}

		if (node instanceof Charstring_Value) {
			String value = "";
			if (isCreate) {
				value = ((Charstring_Value) node).getValue();
			} else {
				value = "new CHARSTRING(\"" + ((Charstring_Value) node).getValue() + "\")";
			}
			expressionValue.add(value);

			if (isSendStatement) {
				nodeSendParameterType.add("CHARSTRING");
			}

			if (isReceiveValue) {
				if (waitForAltStatements) {
					altGuardReceiveType.add("CHARSTRING");
				} else {
					receiveType.add("CHARSTRING");
				}
				waitForReceiveParameter=false;
			}
		}

		if (node instanceof Octetstring_Value) {
			String value = "";
			if (isCreate) {
				value = ((Octetstring_Value) node).getValue();
			} else {
				value = "new OCTETSTRING(\"" + ((Octetstring_Value) node).getValue() + "\")";
			}
			expressionValue.add(value);

			if (isSendStatement) {
				nodeSendParameterType.add("OCTETSTRING");
			}

			if (isReceiveValue) {
				if (waitForAltStatements) {
					altGuardReceiveType.add("OCTETSTRING");
				} else {
					receiveType.add("OCTETSTRING");
				}
				waitForReceiveParameter=false;
			}
		}

		if (node instanceof Bitstring_Value) {
			String value = "(new BITSTRING(\"" + ((Bitstring_Value) node).getValue().toString() + "\"))";

			expressionValue.add(value);
		}

	}

	public void visitStartValueSetters(IVisitableNode node) {
		if (waitForTcStartValues && (node instanceof ParameterisedSubReference)) {
			testCaseStartValueParameters.add(((ParameterisedSubReference) node).getId().toString());
			myASTVisitor.blockIdListing = true;
			waitForTcStartParameter = false;
		}

		if (waitForTcStartValues && (node instanceof Identifier) && !myASTVisitor.blockIdListing) {
			myASTVisitor.blockIdListing = false;
			testCaseStartValues.add(((Identifier) node).toString());
			testCaseStartCounter.add(String.valueOf(tcStartCounter));
			waitForTcStartParameter = true;
		}
	}

	public void visitStopValueSetters(IVisitableNode node) {
		if (waitForTcStopValues && (node instanceof ParameterisedSubReference)) {
			testCaseStopValueParameters.add(((ParameterisedSubReference) node).getId().toString());
			myASTVisitor.blockIdListing = true;
			waitForTcStopParameter = false;
		}

		if (waitForTcStopValues && (node instanceof Identifier) && !myASTVisitor.blockIdListing) {
			myASTVisitor.blockIdListing = false;
			testCaseStopValues.add(((Identifier) node).toString());
			testCaseStopCounter.add(String.valueOf(tcStopCounter));
			waitForTcStopParameter = true;
		}
	}

	public void visitDisconnectValueSetters(IVisitableNode node) {

		if (waitForTcDisconnectValues && (node instanceof Identifier)) {
			testCaseDisconnectValues.add(((Identifier) node).toString());
		}

		if (waitForTcDisconnectValues && (node instanceof SelfComponentExpression)) {
			testCaseDisconnectValues.add("self");
		}
	}

	public void visitMapIdentifiers(IVisitableNode node) {

		if (waitForMapIdentifiers && (node instanceof SystemComponentExpression) && (mapValueCounter <= 4)) {
			testCaseMapValues.add("system");
			testCaseMapCounter.add(Integer.toString(mapCounter));
			mapValueCounter++;
		}
		
		if (waitForMapIdentifiers && (node instanceof MTCComponentExpression) && (mapValueCounter <= 4)) {
			testCaseMapValues.add("mtc");
			testCaseMapCounter.add(Integer.toString(mapCounter));
			mapValueCounter++;
		}
	}

	public void checkReference(IVisitableNode node) {
		String value = ((Reference) node).getId().toString();
		
		List<ISubReference> subrefs=((Reference) node).getSubreferences();
		if(subrefs!=null){
			value="";
			for(int i=0;i<subrefs.size();i++){
				value+=subrefs.get(i).getId();
				if(i<subrefs.size()-1){
					if(!(subrefs.get(i+1) instanceof ArraySubReference)){
						value+=".";
					}
				}
			}
		}
		
		if (waitForMapIdentifiers && (mapValueCounter <= 4)) {
			testCaseMapValues.add(value);
			testCaseMapCounter.add(Integer.toString(mapCounter));
			mapValueCounter++;
		} else if (isSendStatement && !isSendValue) {
			nodeSendPortReference.add(value);
			isSendValue = true;

		} else if (waitForTcCreateValues) {
			testCaseCreateRefValues.add(value);
			testCaseCreateCounter.add(String.valueOf(tcCreateCounter));

		} else if (waitForReceiveStatement && !waitForTypedParam && !waitForReceiveAnyValTemplateValue
				&& !isReceiveValue) {

			if (waitForAltStatements) {
				altGuardPortReference.add(value);
			} else {
				receivePortReference.add(value);
			}

			waitForValue = true;
			isReceiveValue = true;
			waitForReceiveParameter = true;
			checkAnyport = false;
		} else if (waitForTypedParam) {
			if (waitForAltStatements) {
				altGuardReceiveValue.add(value);
				altGuardReceiveType.add("_TYPED_PARAM_");
				
			} else {
				receiveValue.add(value);
				receiveType.add("_TYPED_PARAM_");
			}
			waitForTypedParam = false;
			waitForReceiveParameter=false;
		} else if (waitForReceiveAnyValTemplateValue && !waitForTypedParam) {

			if (waitForAltStatements) {
				altGuardReceiveAnyValValue.add(value);
			} else {
				receiveAnyValValue.add(value);
			}
			isAnyValValue = true;

		} else if (waitForUnknownStartStatement) {
			unknownStartReference.add(value);
		} else if (waitForRunsOnValue && !isThereAFormalParameter) {
			runsOnValue = value;

			waitForRunsOnValue = false;

			if (waitForFunction) {
				AstWalkerJava.functionRunsOnList.add(value);
			}
		} else if (waitForUnknownStopStatement) {
			unknownStopReference.add(value);
		} else if (waitForAssignmentIdentifiers) {

			nodeAssignIdentifiers.add(value);
			currentIdentifier = value;

			if (((Reference) node).getSubreferences().size() > 1) {
				if (((Reference) node).getSubreferences().get(1) instanceof ArraySubReference) {
					ArraySubReference subref = (ArraySubReference) ((Reference) node).getSubreferences().get(1);
					nodeAssignIdentifiers.set(nodeAssignIdentifiers.size() - 1,
							nodeAssignIdentifiers.get(nodeAssignIdentifiers.size() - 1) + ".set("
									+ subref.getValue().toString() + ",");
					waitForIndexSetValue = true;
				}
			} else {

				nodeAssignIdentifiers.set(nodeAssignIdentifiers.size() - 1,
						nodeAssignIdentifiers.get(nodeAssignIdentifiers.size() - 1) + "=");

				// Only set to false if there are no arraysubrefs
				// For arraysubrefs the flag is set to false in the
				// arraysubref leave part
				waitForAssignmentIdentifiers = false;
			}

		} else if (waitForDefStatement && !blockReferenceListing) {

			nodeVarTypes.add(value);
			nodeVarTypeIsAReference.add(true);

			if (myASTVisitor.nodeNameNodeTypeHashMap.containsKey(nodeVarTypes.get(nodeVarTypes.size() - 1))) {

				if (myASTVisitor.nodeNameNodeTypeHashMap.get(nodeVarTypes.get(nodeVarTypes.size() - 1))
						.equals("record")) {

					if (currentRecordCounter < myASTVisitor.nodeNameChildrenNamesHashMap
							.get(nodeVarTypes.get(nodeVarTypes.size() - 1)).length) {
						waitForRecord = true;
						nodeVarIsRecord.add(true);

					}
				}
			}

		} else if (waitForValue && !isReceiveValue && !blockReferenceListing) {
			// has to be the last one
			// sends the Reference value to be processed as an assignment
			// identifier
			expressionValue.add(value);
		} /*
			 * else if (nodeVarTypes.size() > 0) { if
			 * (myASTVisitor.nodeNameNodeTypeHashMap.containsKey(value)) {
			 * 
			 * if (myASTVisitor.nodeNameNodeTypeHashMap.get(nodeVarTypes.get(
			 * nodeVarTypes.size() - 1)) .equals("record")) {
			 * 
			 * if (currentRecordCounter <
			 * myASTVisitor.nodeNameChildrenNamesHashMap
			 * .get(nodeVarTypes.get(nodeVarTypes.size() - 1)).length) {
			 * waitForRecord = true; nodeVarIsRecord.add(true);
			 * 
			 * } } } }
			 */

	}

	public void visitSendStatements(IVisitableNode node) {

	}

	public void visitTcNodes(IVisitableNode node) {

		if (waitForTC && (node instanceof ComponentCreateExpression)) {
			isCreate = true;
			waitForTcCreateValues = true;
			tcCreateCounter++;
		}

		if (waitForTC && (node instanceof Connect_Statement)) {
			waitForTcConnectValues = true;
		}

		if (waitForTcConnectValues && (node instanceof Identifier)) {
			testCaseConnectValues.add(((Identifier) node).toString());

		}

		if (waitForTcConnectValues && (node instanceof SelfComponentExpression)) {
			testCaseConnectValues.add("self");

		}

	}

	public void visitTcIfCases(IVisitableNode node) {

		if (waitForTC && (node instanceof If_Statement)) {

			waitForValue = true;
			isIf = true;

		}

	}

	public void visitAltCases(IVisitableNode node) {

		if (node instanceof Receive_Port_Statement) {
			waitForReceiveStatement = true;
			checkAnyport = true;
			
			
		}

		if (waitForReceiveStatement && (node instanceof StatementBlock)) {

			if (!waitForAltStatements) {
				receiveStatements.add((StatementBlock) node);
			}
			waitForReceiveStatement = false;
		}

		if (node instanceof TemplateInstance) {
			if (((TemplateInstance) node).getType() != null) {
				waitForTypedParam = true;
				checkAnyport = true;
			}
		}

		if (checkAnyport && (node instanceof Setverdict_Statement)) {
			if (waitForAltStatements) {
				altGuardPortReference.add("any port");
				altGuardReceiveValue.add(null);
				altGuardReceiveType.add("any port");
			} else {
				receivePortReference.add("any port");
				receiveValue.add("null");
				receiveType.add("any port");
			}

			waitForReceiveStatement = false;

			checkAnyport = false;
		}

		if ((waitForTC || waitForFunction) && (node instanceof Any_Value_Template)) {

			waitForReceiveAnyValTemplateValue = true;

			checkAnyport = false;
		}

		if (waitForAltStatements && (node instanceof Timeout_Statement)) {

			waitForAltTimeout = true;
		}

		if (waitForAltTimeout && (node instanceof Identifier)) {
			altGuardTimeout.add(((Identifier) node).toString());
			waitForAltTimeout = false;

		}

	}

	public void visitFunctionNodes(IVisitableNode node) {

		if (waitForReturnType && (node instanceof Integer_Type)) {
			returnType = "Integer_Type";
		}

		if (waitForReturnType && (node instanceof Boolean_Type)) {
			returnType = "Boolean_Type";
		}

		if (waitForFunction && (node instanceof Return_Statement)) {
			waitForReturnStatementValue = true;
		}

		if (node instanceof Unknown_Start_Statement) {
			waitForUnknownStartStatement = true;
		}

		if (node instanceof Unknown_Stop_Statement) {
			waitForUnknownStopStatement = true;
		}

		if (node instanceof Int2StrExpression) {
			waitForInt2StrExpression = true;
		}

	}

	public void handleFunction(IVisitableNode node) {
		Def_Function_Writer functionNode = Def_Function_Writer.getInstance(((Def_Function) node));
		functionNode.clearLists();
		functionNode.setStatementBlock(functionStatementBlock);

		functionNode.runsOnValue = runsOnValue;
		functionNode.returnType = returnType;
		functionNode.returnStatementValue = returnStatementValue;

		returnType = null;
		returnStatementValue = null;

		myASTVisitor.currentFileName = ((Def_Function) node).getIdentifier().toString();

		functionNode.functionVars.addAll(nodeVars);
		functionNode.functionVarTypes.addAll(nodeVarTypes);
		functionNode.functionVarValues.addAll(nodeVarValues);

		functionNode.functionVarIsConstant.addAll(nodeVarIsConstant);
		functionNode.functionValueIsAValueReference.addAll(nodeVarIsAValueReference);
		functionNode.functionAssignIdentifiers.addAll(nodeAssignIdentifiers);
		functionNode.functionAssignValues.addAll(nodeAssignValues);

		functionNode.receivePortReference.addAll(receivePortReference);
		functionNode.receiveValue.addAll(receiveValue);
		functionNode.receiveAnyValValue.addAll(receiveAnyValValue);
		functionNode.receiveType.addAll(receiveType);

		functionNode.doWhileExpressions.addAll(doWhileExpressions);
		
		functionNode.receiveStatements.addAll(receiveStatements);

		Def_Function_Writer.sendPortReference.addAll(nodeSendPortReference);
		Def_Function_Writer.sendParameter.addAll(nodeSendParameter);
		Def_Function_Writer.sendParameterType.addAll(nodeSendParameterType);

		functionNode.unknownStartReference.addAll( unknownStartReference);
		functionNode.unknownStopReference = unknownStopReference;

		if (runsOnValue != null) {

			AstWalkerJava.functionList.add(((Def_Function) node).getIdentifier().toString());

			myASTVisitor.visualizeNodeToJava(myASTVisitor.importListStrings);
			myASTVisitor.visualizeNodeToJava(functionNode.writeFunctionFile());
			myASTVisitor.currentFileName = runsOnValue;
			myASTVisitor.deleteLastBracket(myASTVisitor.currentFileName);

		} else {
			myASTVisitor.currentFileName = "TTCN_functions";
			myASTVisitor.deleteLastBracket(myASTVisitor.currentFileName);
		}

		myASTVisitor.visualizeNodeToJava(functionNode.getJavaSource() + "\r\n}");

		clearEverything();

	}

	public void handleTestcase(IVisitableNode node) {
		Def_Testcase_Writer testNode = Def_Testcase_Writer.getInstance(((Def_Testcase) node));

		testNode.clearLists();

		myASTVisitor.currentFileName = ((Def_Testcase) node).getIdentifier().toString();

		testNode.testCaseRunsOn = runsOnValue;
		testNode.tcMainStatementBlock = tcStatementBlock;
		AstWalkerJava.testCaseRunsOnList.add(runsOnValue);

		testNode.tcConnectValues.addAll(testCaseConnectValues);
		testNode.tcStartIdentifiers.addAll(testCaseStartValues);
		testNode.tcStartCounter.addAll(testCaseStartCounter);
		testNode.tcMapValues.addAll(testCaseMapValues);
		testNode.tcMapCounter.addAll(testCaseMapCounter);
		testNode.tcIfConditions.addAll(testCaseIfConditions);
		testNode.tcVars.addAll(nodeVars);
		testNode.tcVarTypes.addAll(nodeVarTypes);
		testNode.tcVarValues.addAll(nodeVarValues);
		testNode.tcAssignIdentifiers.addAll(nodeAssignIdentifiers);
		testNode.tcAssignValues.addAll(nodeAssignValues);
		testNode.tcValueIsAValueReference.addAll(nodeVarIsAValueReference);
		testNode.tcCreateValues.addAll(testCaseCreateValues);
		testNode.tcCreateCounter.addAll(testCaseCreateCounter);
		Def_Testcase_Writer.sendPortReference.addAll(nodeSendPortReference);
		Def_Testcase_Writer.sendParameter.addAll(nodeSendParameter);
		Def_Testcase_Writer.sendParameterType.addAll(nodeSendParameterType);

		testNode.tcVarIsConstant.addAll(nodeVarIsConstant);
		testNode.tcVarIsTemplate.addAll(nodeVarIsTemplate);
		testNode.tcDisconnectValues.addAll(testCaseDisconnectValues);
		testNode.testCaseStartValueParameters.addAll(testCaseStartValueParameters);
		testNode.tcValueTypeIsAReference.addAll(nodeVarTypeIsAReference);
		testNode.tcStopIdentifiers.addAll(testCaseStopValues);
		testNode.tcStopCounter.addAll(testCaseStopCounter);
		testNode.testCaseStopValueParameters.addAll(testCaseStopValueParameters);

		testNode.receivePortReference.addAll(receivePortReference);
		testNode.receiveValue.addAll(receiveValue);
		testNode.receiveAnyValValue.addAll(receiveAnyValValue);
		testNode.receiveType.addAll(receiveType);

		testNode.receiveStatements.addAll(receiveStatements);
		testNode.nodeVarIsRecord.addAll(nodeVarIsRecord);

		testNode.doWhileExpressions.addAll(doWhileExpressions);
		
		myASTVisitor.visualizeNodeToJava(myASTVisitor.importListStrings);
		myASTVisitor.visualizeNodeToJava(testNode.writeTestcaseFile((Def_Testcase) node));

		myASTVisitor.currentFileName = runsOnValue;
		myASTVisitor.deleteLastBracket(myASTVisitor.currentFileName);
		myASTVisitor.visualizeNodeToJava(testNode.getJavaSource() + "\r\n}");

		clearEverything();

	}

	public void handleAltCases(IVisitableNode node) {

		if (waitForTC && (node instanceof Alt_Statement)) {

			currentTestCaseWriter.altStatements
					.add(new Def_AltStatement_Writer((Alt_Statement) node, currentTestCaseWriter.nodeName));

			currentTestCaseWriter.altStatements.get(currentTestCaseWriter.altStatements.size() - 1).setType("TestCase");

			currentTestCaseWriter.altStatements.get(currentTestCaseWriter.altStatements.size() - 1)
					.setParent(currentTestCaseWriter);

			currentTestCaseWriter.altStatements.get(currentTestCaseWriter.altStatements.size() - 1).altGuardConditions
					.addAll(altGuardConditions);

			currentTestCaseWriter.altStatements
					.get(currentTestCaseWriter.altStatements.size() - 1).altGuardPortReference
							.addAll(altGuardPortReference);

			currentTestCaseWriter.altStatements.get(currentTestCaseWriter.altStatements.size() - 1).altGuardReceiveValue
					.addAll(altGuardReceiveValue);

			currentTestCaseWriter.altStatements.get(currentTestCaseWriter.altStatements.size() - 1).altGuardReceiveType
					.addAll(altGuardReceiveType);

			currentTestCaseWriter.altStatements.get(currentTestCaseWriter.altStatements.size() - 1).altGuardTimeout
					.addAll(altGuardTimeout);

			currentTestCaseWriter.altStatements
			.get(currentTestCaseWriter.altStatements.size() - 1).altGuardReceiveAnyValValue
					.addAll(altGuardReceiveAnyValValue);
			
			clearAltLists();

		}

		if (waitForFunction && (node instanceof Alt_Statement)) {

			currentFunctionWriter.altStatements
					.add(new Def_AltStatement_Writer((Alt_Statement) node, currentFunctionWriter.nodeName));

			currentFunctionWriter.altStatements.get(currentFunctionWriter.altStatements.size() - 1).setType("Function");
			currentFunctionWriter.altStatements.get(currentFunctionWriter.altStatements.size() - 1)
					.setParent(currentFunctionWriter);

			currentFunctionWriter.altStatements.get(currentFunctionWriter.altStatements.size() - 1).altGuardConditions
					.addAll(altGuardConditions);

			currentFunctionWriter.altStatements
					.get(currentFunctionWriter.altStatements.size() - 1).altGuardPortReference
							.addAll(altGuardPortReference);

			currentFunctionWriter.altStatements.get(currentFunctionWriter.altStatements.size() - 1).altGuardReceiveValue
					.addAll(altGuardReceiveValue);

			currentFunctionWriter.altStatements.get(currentFunctionWriter.altStatements.size() - 1).altGuardReceiveType
					.addAll(altGuardReceiveType);

			currentFunctionWriter.altStatements.get(currentFunctionWriter.altStatements.size() - 1).altGuardTimeout
					.addAll(altGuardTimeout);

			currentFunctionWriter.altStatements
					.get(currentFunctionWriter.altStatements.size() - 1).altGuardReceiveAnyValValue
							.addAll(altGuardReceiveAnyValValue);

			clearAltLists();
		}

	}

	public void clearAltLists() {
		altGuardConditions.clear();
		altGuardPortReference.clear();
		altGuardReceiveValue.clear();
		altGuardReceiveType.clear();
		altGuardTimeout.clear();
		altGuardReceiveAnyValValue.clear();
	}

	public void clearEverything() {

		tcCreateCounter = -1;
		tcStartCounter = -1;
		mapCounter = 0;
		mapValueCounter = 0;

		tcStopCounter = -1;

		waitForTcStopValues = false;
		waitForDefStatement = false;
		waitForStatementBlock = false;
		waitForValue = false;
		waitForRunsOnValue = false;
		waitForReturnType = false;
		waitForReturnStatementValue = false;
		waitForReceiveStatement = false;
		checkAnyport = false;
		waitForUnknownStartStatement = false;
		waitForTypedParam = false;
		waitForInt2StrExpression = false;
		waitForTC = false;

		waitForAssignmentIdentifiers = false;
		waitForMapIdentifiers = false;
		waitForTcIfCondition = false;
		isSendStatement = false;
		waitForTcStartParameter = false;
		isAltGuards = false;
		waitForAltStatements = false;
		isReceiveValue = false;
		waitForAltTimeout = false;
		isNextValueConstant = false;
		waitForTcDisconnectValues = false;
		waitForTcCreateValues = false;
		waitForTcConnectValues = false;
		waitForTcStartValues = false;
		waitForFunction = false;

		waitForStatements = false;
		waitForValue = false;
		isAnyValValue = false;
		waitForReceiveAnyValTemplateValue = false;

		nodeVars.clear();
		nodeVarTypes.clear();
		nodeVarValues.clear();
		nodeVarIsAValueReference.clear();
		nodeVarTypeIsAReference.clear();
		nodeAssignIdentifiers.clear();
		nodeVarIsConstant.clear();
		nodeVarIsTemplate.clear();
		nodeAssignValues.clear();
		testCaseCreateValues.clear();
		testCaseCreateCounter.clear();
		testCaseCreateRefValues.clear();
		nodeSendParameter.clear();
		testCaseCreateCharValues.clear();
		testCaseIfConditions.clear();
		nodeSendPortReference.clear();
		nodeSendParameterType.clear();
		altGuardConditions.clear();
		altGuardPortReference.clear();
		altGuardReceiveValue.clear();
		altGuardReceiveAnyValValue.clear();
		altGuardReceiveType.clear();
		altGuardTimeout.clear();
		testCaseDisconnectValues.clear();
		testCaseStartValues.clear();
		testCaseMapValues.clear();
		testCaseMapCounter.clear();
		testCaseStartCounter.clear();
		testCaseStartValueParameters.clear();
		testCaseConnectValues.clear();
		operatorList.clear();

		doWhileExpressions.clear();
		
		testCaseStopValues.clear();
		testCaseStopValueParameters.clear();
		testCaseStopCounter.clear();

		receiveStatements.clear();
		receivePortReference.clear();
		receiveValue.clear();
		receiveAnyValValue.clear();
		receiveType.clear();

		nodeVarRecordValues.clear();
		nodeVarIsRecord.clear();
		
		unknownStartReference.clear();
		unknownStopReference.clear();
		

		isIf = false;
		isDefinition = false;
		isAssignment = false;

	}
}
/******************************************************************************
 * Copyright (c) 2000-2017 Ericsson Telecom AB
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   
 *   Keremi, Andras
 *   Eros, Levente
 *   Kovacs, Gabor
 *   Meszaros, Mate Robert
 *
 ******************************************************************************/

package org.eclipse.titan.codegenerator;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.RandomAccessFile;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;

import org.eclipse.titan.codegenerator.constant.ConstantParser;
import org.eclipse.titan.codegenerator.constant.ModuleConstants;
import org.eclipse.titan.codegenerator.template.ModuleTemplates;
import org.eclipse.titan.codegenerator.template.TemplateParser;
import org.eclipse.titan.designer.AST.ASTVisitor;
import org.eclipse.titan.designer.AST.IVisitableNode;
import org.eclipse.titan.designer.AST.TTCN3.definitions.Def_Const;
import org.eclipse.titan.designer.AST.TTCN3.definitions.Def_Extfunction;
import org.eclipse.titan.designer.AST.TTCN3.definitions.Def_ModulePar;
import org.eclipse.titan.designer.AST.TTCN3.definitions.Def_Template;
import org.eclipse.titan.designer.AST.TTCN3.values.expressions.UnaryMinusExpression;

public final class myASTVisitor extends ASTVisitor implements Scope {

	private Scope scope = this;

	ModuleParameters parameters = new ModuleParameters();
	private ModuleTemplates templates = new ModuleTemplates();
	private ModuleConstants constants = new ModuleConstants();

	public static TestCase_Function_Visit_Handler myFunctionTestCaseVisitHandler = new TestCase_Function_Visit_Handler();
	public static Def_Type_Visit_Handler myDefTypeVisitHandler = new Def_Type_Visit_Handler();

	public static String currentFileName = "";

	public static boolean blockIdListing = false;
	public static boolean isNextIntegerNegative = false;


	public static Map<String, String[]> nodeNameChildrenNamesHashMap = new LinkedHashMap<String, String[]>();
	public static Map<String, String[]> nodeNameChildrenTypesHashMap = new LinkedHashMap<String, String[]>();
	public static Map<String, String> nodeNameSetOfTypesHashMap = new LinkedHashMap<String, String>();
	public static Map<String, String> nodeNameRecordOfTypesHashMap = new LinkedHashMap<>();
	public static Map<String, String> nodeNameNodeTypeHashMap = new LinkedHashMap<String, String>();
	public static Map<String, String> portNamePortTypeHashMap = new LinkedHashMap<String, String>();
	public static Map<String, String> templateIdValuePairs = new LinkedHashMap<String, String>();
	public static Map<String, String> nodeNameAllowedValuesHashmap = new LinkedHashMap<String,  String>();
	
	public static Set<String> constOmitHashes = new HashSet<String>();
	public static Set<String> templateIDs = new HashSet<String>();

	public static String importListStrings = "package org.eclipse.titan.codegenerator.javagen;"
			+ "\r\n"
			+ "import org.eclipse.titan.codegenerator.TTCN3JavaAPI.*;"
			+ "\r\n"
			+ "import java.util.ArrayList;"
			+ "\r\n"
			+ "import java.util.HashSet;"
			+ "\r\n"
			+ "import java.util.List;"
			+ "\r\n"
			+ "import java.util.Vector;"
			+ "\r\n"
			+ "import java.util.concurrent.TimeUnit;"
			+ "\r\n"
			+ "import java.io.ObjectInputStream;"
			+ "\r\n"
			+ "import java.io.ObjectOutputStream;"
			+ "\r\n"
			+ "import java.io.BufferedReader;"
			+ "\r\n"
			+ "import java.io.BufferedWriter;"
			+ "\r\n"
			+ "import java.io.InputStreamReader;"
			+ "\r\n"
			+ "import java.io.OutputStreamWriter;"
			+ "\r\n"
			+ "import java.math.BigInteger;"
			+ "\r\n"
			+ "import java.net.Socket;"
			+ "\r\n"
			+ "import java.net.ServerSocket;" + "\r\n" + "\r\n";

	public static void visualizeNodeToJava(String string) {

		File file = new File(AstWalkerJava.props.getProperty("javafile.path")
				+ currentFileName + ".java");
		FileWriter writer;
		try {
			writer = new FileWriter(file, true);
			PrintWriter printer = new PrintWriter(writer);

			printer.append(string);

			printer.close();
		} catch (IOException e) {
			e.printStackTrace();
		}

	}

	public static String changeTypeToJava(String string) {
		// TODO : why only CHARSTRING? does it belong here?
		if (string.equals("CHARSTRING")) {
			return "SubTypeDef<CHARSTRING>";
		}
		return TypeMapper.map(string);
	}

	public static String cutModuleNameFromBeginning(String string) {
		String[] parts = string.split("\\.");

		if (parts.length > 1) {
			String part1 = parts[0];
			String part2 = parts[1];

			if (part1.equals(AstWalkerJava.moduleElementName)) {
				string = part2;
			}
		}
		return changeTypeToJava(string);
	}

	public static void deleteLastBracket(String currentFileName) {
		try {

			RandomAccessFile file = new RandomAccessFile(
					AstWalkerJava.props.getProperty("javafile.path")
							+ currentFileName + ".java", "rw");

			long length = file.length();
			file.setLength(length - 3);
			file.close();

		} catch (Exception ex) {

			System.out.println("ERROE :" + ex);
		}
	}

	@Override
	public int visit(IVisitableNode node) {
		scope = scope.process(node);
		return V_CONTINUE;
	}

	@Override
	public Scope process(IVisitableNode node) {
		// visit* submethods only serve increased readability and
		// categorization

		myDefTypeVisitHandler.visit(node);

		if (node instanceof Def_Const) {
			return new ConstantParser(this, constants);
		}

		if (node instanceof Def_Template) {
			return new TemplateParser(this, templates);
		}

		if (node instanceof Def_ModulePar) {
			return new ModuleParameterParser(this);
		}

		if (node instanceof UnaryMinusExpression) {
			myASTVisitor.isNextIntegerNegative = true;
		}

		if (node instanceof Def_Extfunction) {//FormalParameterList Boolean_Type
			
			String nodeName=((Def_Extfunction)node).getIdentifier().toString();
			nodeName.toString();
			//((Def_Extfunction)node).getFormalParameterList();
			// return type is the next *_Type after the Formalparamlist
			//TODO process 
		}

		// Check for Function & TC nodes
		myFunctionTestCaseVisitHandler.visit(node);

		return this;
	}

	@Override
	public int leave(IVisitableNode node) {
		scope = scope.finish(node);
		return V_CONTINUE;
	}

	@Override
	public Scope finish(IVisitableNode node) {

		myDefTypeVisitHandler.leave(node);

		if (node instanceof UnaryMinusExpression) {
			myASTVisitor.isNextIntegerNegative = false;
		}

		myFunctionTestCaseVisitHandler.leave(node);

		return this;
	}

	/**
	 * Finish the visitor by writing the static parts:
	 * - module parameters
	 * - templates
	 * - constants
	 */
	// TODO : move Constants and Templates here
	void finish() {
		currentFileName = parameters.getClassName();
		visualizeNodeToJava(importListStrings);
		visualizeNodeToJava(parameters.getJavaSource());
		currentFileName = templates.getClassName();
		visualizeNodeToJava(importListStrings);
		visualizeNodeToJava(templates.getJavaSource());
		currentFileName = constants.getClassName();
		visualizeNodeToJava(importListStrings);
		visualizeNodeToJava(constants.getJavaSource());
	}
}
log.path=D:\\temp\\AstWriter.log
ast.log.enabled=true
ast.log.console=false
ast.log.file=D:\\temp\\ast.xml
javafile.path=D:\\temp\\ttcn\\
ttcn3file.path=D:\\temp\\out.txt
serverportnum=5557
hostIPaddress=127.0.0.1